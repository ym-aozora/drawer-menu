<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/highendrawer.js | highendrawer</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Highendrawer provides javascript and css drawers to your website and applications."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="highendrawer"><meta property="twitter:description" content="Highendrawer provides javascript and css drawers to your website and applications."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ym-aozora/highendrawer"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/highendrawer.js~Highendrawer.html">Highendrawer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-addEventListenerWithOptions">addEventListenerWithOptions</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-generateId">generateId</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hasStyle">hasStyle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isHTMLElement">isHTMLElement</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setStyle">setStyle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unsetStyle">unsetStyle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isArray">isArray</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ucFirst">ucFirst</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DEFAULT_DRAWER_PROPERTY">DEFAULT_DRAWER_PROPERTY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DEFAULT_OVERLAY_PROPERTY">DEFAULT_OVERLAY_PROPERTY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DEFAULT_PROCESS">DEFAULT_PROCESS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DRAWER_STYLE">DRAWER_STYLE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-OVERLAY_STYLE">OVERLAY_STYLE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PREFIX">PREFIX</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TOUCH_EVENTS">TOUCH_EVENTS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TRANSITION_STYLE">TRANSITION_STYLE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-support">support</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Drawer">Drawer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Overlay">Overlay</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/highendrawer.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {
  DEFAULT_DRAWER_PROPERTY,
  DEFAULT_OVERLAY_PROPERTY,
  DEFAULT_PROCESS,
  DRAWER_STYLE,
  OVERLAY_STYLE,
  TOUCH_EVENTS,
  TRANSITION_STYLE,
} from &apos;./const&apos;;

import {isArray} from &apos;./util&apos;;
import * as helper from &apos;./helper&apos;;
import {support} from &apos;./support&apos;;

/**
 * Class providing a drawer function.
 *
 * @public
 * @class
 * @example
 * var drawer = new Highendrawer({
 *   element: document.getElementById(&apos;drawer&apos;)
 * });
 */
export default class Highendrawer {
  /**
   * Initialize object.
   *
   * @constructor
   * @param {Drawer} drawer Initial parameters of drawer.
   */
  constructor(drawer) {
    /**
     * Drawer status (&apos;open&apos; or &apos;close&apos;)
     *
     * @public
     * @type {string}
     */
    this.state = &apos;close&apos;;

    this._id = helper.generateId();
    this._drawer = Object.assign({}, DEFAULT_DRAWER_PROPERTY, drawer);
    this._overlay = this._drawer.overlay === false ?
      false :
      Object.assign({}, DEFAULT_OVERLAY_PROPERTY, this._drawer.overlay);
    this._timeoutId = null;
    this._intervalId = null;
    this._process = Object.assign({}, DEFAULT_PROCESS);
    this._enabled = false;
    this._handler = this._getDrawerHandler();

    if (!this._drawer.element) {
      throw new Error(`&apos;element&apos; is required.`);
    }

    if (!helper.isHTMLElement(this._drawer.element)) {
      throw new Error(`Invalid HTMLElement specified for &apos;element&apos;.`);
    }

    if (this._drawer.enabledMaxWidth &gt; -1) {
      helper.addEventListenerWithOptions(window, &apos;resize&apos;, () =&gt; {
        if (this._enabled
          &amp;&amp; window.innerWidth &gt; this._drawer.enabledMaxWidth) {
          this.destroy();
        } else if (!this._enabled
          &amp;&amp; window.innerWidth &lt;= this._drawer.enabledMaxWidth) {
          this.create();
        }
      });
    }

    if (window.history
      &amp;&amp; window.history.pushState
      &amp;&amp; this._drawer.history
    ) {
      window.history.replaceState({
        id: this._id,
      }, null, null);
    }

    if (this._drawer.initCreate
      &amp;&amp; (this._drawer.enabledMaxWidth &lt; 0
        || window.innerWidth &lt;= this._drawer.enabledMaxWidth)
    ) {
      this.create();
    }
  }

  /**
   * Create the drawer set.
   *
   * @public
   */
  create() {
    try {
      this._createDrawer();
      this._createOverlay();
      this._enabled = true;

      if (this._drawer.onCreate) {
        this._drawer.onCreate.apply(this, [this._drawer]);
      }
    } catch (e) {
      if (this._drawer &amp;&amp; this._drawer.onError &amp;&amp; typeof this._drawer.onError === &apos;function&apos;) {
        this._drawer.onError.apply(this, [e]);
      } else {
        throw e;
      }
    }
  }

  /**
   * Destroy the drawer set.
   *
   * @public
   */
  destroy() {
    try {
      if (this.state === &apos;open&apos;) {
        this.close(0, true, true);
      }

      this._destroyDrawer();
      this._destroyOverlay();
      this._enabled = false;

      if (this._drawer.onDestroy) {
        this._drawer.onDestroy.apply(this, [this._drawer]);
      }
    } catch (e) {
      if (this._drawer &amp;&amp; this._drawer.onError &amp;&amp; typeof this._drawer.onError === &apos;function&apos;) {
        this._drawer.onError.apply(this, [e]);
      } else {
        throw e;
      }
    }
  }

  /**
   * Open drawer.
   *
   * @public
   * @param {number} [duration] Drawer moving time.
   * @param {boolean} [isFireEvent] Whether to fire an event on the drawer.
   * @param {boolean} [isChangeHistory=false] Make a change in history.
   * @return {Promise} Promise object for open.
   */
  open(duration = null, isFireEvent = true, isChangeHistory = true) {
    return this._changeState(
      0,
      duration,
      {
        onChangeState: isFireEvent ? this._drawer.onChangeState : null,
        done: isFireEvent ? this._drawer.onOpen : null,
        fail: isFireEvent ? this._drawer.onError : null,
      },
      isChangeHistory
    );
  }

  /**
   * Close drawer.
   *
   * @public
   * @param {number} [duration] Drawer moving time.
   * @param {boolean} [isFireEvent] Whether to fire an event on the drawer.
   * @param {boolean} [isChangeHistory=false] Make a change in history.
   * @return {Promise} Promise object for close.
   */
  close(duration = null, isFireEvent = true, isChangeHistory = true) {
    return this._changeState(
      this._getMinPosition(),
      duration,
      {
        onChangeState: isFireEvent ? this._drawer.onChangeState : null,
        done: isFireEvent ? this._drawer.onClose : null,
        fail: isFireEvent ? this._drawer.onError : null,
      },
      isChangeHistory
    );
  }

  /**
   * Toggle drawer.
   *
   * @public
   * @param {number} [duration] Drawer moving time.
   * @param {boolean} [isFireEvent] Whether to fire an event on the drawer.
   * @param {boolean} [isChangeHistory=false] Make a change in history.
   * @return {Promise} Promise object for toggle.
   */
  toggle(duration = null, isFireEvent = true, isChangeHistory = true) {
    return new Promise((resolve, reject) =&gt; {
      try {
        this[this.state === &apos;open&apos; ? &apos;close&apos; : &apos;open&apos;](duration, isFireEvent, isChangeHistory)
          .then(resolve, reject);
      } catch (e) {
        reject(e);
      }
    });
  }

  /**
   * Create drawer.
   */
  _createDrawer() {
    helper.setStyle(
      this._drawer.element,
      Object.assign(
        {},
        DRAWER_STYLE,
        support.cssAnim ? TRANSITION_STYLE : {}
      )
    );

    this._resetDrawer();

    Object.keys(this._handler).forEach((name) =&gt; {
      helper.addEventListenerWithOptions(window, name, this._handler[name], {
        passive: name !== &apos;touchmove&apos;,
      });
    });
  }

  /**
   * Destroy drawer.
   */
  _destroyDrawer() {
    Object.keys(this._handler).forEach((name) =&gt; {
      window.removeEventListener(name, this._handler[name]);
    });

    this._resetDrawer(true);

    helper.unsetStyle(
      this._drawer.element,
      Object.keys(
        Object.assign(
          {},
          DRAWER_STYLE,
          support.cssAnim ? TRANSITION_STYLE : {}
        )
      )
    );
  }

  /**
   * Create overlay.
   */
  _createOverlay() {
    if (this._overlay === false) {
      return;
    }

    if (this._overlay.zIndex === -1) {
      this._overlay.zIndex = this._drawer.zIndex - 1;
    }

    if (!this._overlay.element) {
      this._overlay.element = window.document.createElement(&apos;div&apos;);
      this._overlay.autoCreated = true;

      helper.setStyle(
        this._overlay.element,
        Object.assign(
          {},
          OVERLAY_STYLE,
          support.cssAnim ? TRANSITION_STYLE : {}
        )
      );
    }

    if (!this._overlay.touchHandler) {
      this._overlay.touchHandler = (e) =&gt; {
        this.close();
      };
    }

    window.document.body.appendChild(this._overlay.element);
  }

  /**
   * Destroy overlay.
   */
  _destroyOverlay() {
    if (this._overlay === false) {
      return;
    }

    if (this._overlay.element) {
      this._overlay.element.removeEventListener(&apos;click&apos;, this._overlay.touchHandler);

      if (this._overlay.autoCreated) {
        this._overlay.element.parentNode.removeChild(this._overlay.element);
      }
    }
  }

  /**
   * Reset drawer.
   *
   * @param {boolean} [isUnset] Unset style.
   */
  _resetDrawer(isUnset = false) {
    try {
      this._setProps();

      const ims = this._getInitDrawerStyle();

      if (isUnset) {
        helper.unsetStyle(this._drawer.element, Object.keys(ims));
      } else {
        helper.setStyle(this._drawer.element, ims);
      }
    } catch (e) {
      if (this._drawer.onError &amp;&amp; typeof this._drawer.onError === &apos;function&apos;) {
        this._drawer.onError.apply(this, [e]);
      } else {
        throw e;
      }
    }
  }

  /**
   * Show drawer.
   */
  _showDrawer() {
    helper.setStyle(this._drawer.element, {
      zIndex: this._drawer.zIndex,
      opacity: 1,
    });
  }

  /**
   * Hide drawer.
   */
  _hideDrawer() {
    helper.setStyle(this._drawer.element, {
      zIndex: -1,
      opacity: 0,
    });
  }

  /**
   * Show overlay.
   */
  _showOverlay() {
    helper.setStyle(this._overlay.element, {
      zIndex: this._overlay.zIndex,
      display: &apos;block&apos;,
    });
  }

  /**
   * Hide overlay.
   */
  _hideOverlay() {
    helper.setStyle(this._overlay.element, {
      zIndex: -1,
      display: &apos;none&apos;,
    });
  }

  /**
   * Set properties.
   */
  _setProps() {
    // set sizePixel
    let sizePixel = this._normalizePixel(
      this._drawer.size
    );

    if (this._drawer.maxSize &amp;&amp; this._drawer.maxSize !== -1) {
      let maxSizePixel = this._normalizePixel(
        this._drawer.maxSize
      );

      if (sizePixel &gt; maxSizePixel) {
        sizePixel = maxSizePixel;
      }
    }

    this._sizePixel = sizePixel;

    // set position
    this._position = typeof this._position === &apos;undefined&apos; ?
      null :
      this._position;
  }

  /**
   * Return initial style of drawer.
   *
   * @return {Object} Style for drawer.
   */
  _getInitDrawerStyle() {
    let style = null;

    switch (this._drawer.direction) {
      case &apos;top&apos;:
        style = {
          width: &apos;100%&apos;,
          height: `${this._sizePixel}px`,
          top: `-${this._sizePixel}px`,
          right: &apos;auto&apos;,
          bottom: &apos;auto&apos;,
          left: 0,
        };
        break;
      case &apos;right&apos;:
        style = {
          width: `${this._sizePixel}px`,
          height: &apos;100%&apos;,
          top: 0,
          right: `-${this._sizePixel}px`,
          bottom: &apos;auto&apos;,
          left: &apos;auto&apos;,
        };
        break;
      case &apos;bottom&apos;:
        style = {
          width: &apos;100%&apos;,
          height: `${this._sizePixel}px`,
          top: &apos;auto&apos;,
          right: &apos;auto&apos;,
          bottom: `-${this._sizePixel}px`,
          left: 0,
        };
        break;
      case &apos;left&apos;:
        style = {
          width: `${this._sizePixel}px`,
          height: &apos;100%&apos;,
          top: 0,
          right: &apos;auto&apos;,
          bottom: &apos;auto&apos;,
          left: `-${this._sizePixel}px`,
        };
        break;
      default:
        throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
    }

    return Object.assign(style, this._drawer.style || {});
  }

  /**
   * Return style for moving the drawer.
   *
   * @param {number} position Moving position.
   * @param {number} [duration] Drawer moving time.
   * @return {Object} Move style for drawer.
   */
  _getDrawerStyle(position, duration = null) {
    const minp = this._getMinPosition(this._drawer);
    const style = {};

    if (support.cssAnim) {
      style.transitionDuration = `${duration === null ? this._drawer.duration : duration}ms`;

      switch (this._drawer.direction) {
        case &apos;top&apos;:
          style.transform = `${support.transrate}(0,${-(minp - position)}px,0)`;
          break;
        case &apos;right&apos;:
          style.transform = `${support.transrate}(${minp - position}px,0,0)`;
          break;
        case &apos;bottom&apos;:
          style.transform = `${support.transrate}(0,${minp - position}px,0)`;
          break;
        case &apos;left&apos;:
          style.transform = `${support.transrate}(${-(minp - position)}px,0,0)`;
          break;
        default:
          throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
      }
    } else {
      style[this._drawer.direction] = `${position}px`;
    }

    return style;
  }

  /**
   * Return style for moving the overlay.
   *
   * @param {float} opacity Overlay opacity.
   * @param {number} [duration] Drawer moving time.
   * @return {Object} Move style for overlay.
   */
  _getOverlayStyle(opacity, duration = null) {
    const style = {
      opacity,
    };

    if (support.cssAnim) {
      style.transitionDuration = `${duration === null ? this._drawer.duration : duration}ms`;
    }

    return style;
  }

  /**
   * Change overlay state.
   *
   * @param {string} state Drawer status (&apos;open&apos; or &apos;close&apos;)
   */
  _changeOverlayState(state) {
    if (state === &apos;open&apos;) {
      helper.addEventListenerWithOptions(this._overlay.element, &apos;click&apos;, this._overlay.touchHandler);
    } else {
      this._hideDrawer();
      this._hideOverlay();
    }
  }

  /**
   * Make animation with CSS3.
   *
   * @param {number} duration Drawer moving time.
   */
  _cssAnimate(duration) {
    helper.setStyle(
      this._overlay.element,
      this._getOverlayStyle(
        this._getOverlayOpacityFromPosition(this._position),
        duration
      )
    );

    helper.setStyle(
      this._drawer.element,
      this._getDrawerStyle(this._position, duration)
    );
  }

  /**
   * Make animation with Javascript.
   *
   * @param {number} duration Drawer moving time.
   */
  _jsAnimate(duration) {
    const start = +new Date();
    const fromOpy = this._getOverlayOpacityFromStyle();
    const toOpy = this._getOverlayOpacityFromPosition(this._position);
    const fromPos = this._getDrawerPositionFromStyle();
    const toPos = this._position;

    if (this._intervalId) {
      clearInterval(this._intervalId);
    }

    this._intervalId = setInterval(() =&gt; {
      let time = new Date() - start;
      let nowPos = null;
      let nowOpy = null;

      if (time &gt; duration) {
        clearInterval(this._intervalId);
        this._intervalId = null;
        nowOpy = toOpy;
        nowPos = toPos;
      } else {
        const prp = (time /= duration) * (time - 2);
        nowOpy = fromOpy - ((toOpy - fromOpy) * prp);
        nowPos = fromPos - ((toPos - fromPos) * prp);
      }

      helper.setStyle(
        this._overlay.element,
        this._getOverlayStyle(nowOpy, duration)
      );

      helper.setStyle(
        this._drawer.element,
        this._getDrawerStyle(nowPos, duration)
      );
    }, 10);
  }

  /**
   * Return state by touch movement.
   *
   * @return {string} State by touch movement.
   */
  _getTouchMoveState() {
    if (this._process.time.end - this._process.time.start &lt;= 300) {
      const len = this._process.touches.length;
      const moveInfo = this._getTouchMoveInfo(
        this._process.touches[len - 2],
        this._process.touches[len - 1]
      );
      const vertical = moveInfo.axis === &apos;vertical&apos;;
      const horizontal = moveInfo.axis === &apos;horizontal&apos;;
      const top = this._drawer.direction === &apos;top&apos; &amp;&amp; moveInfo.y &gt;= 0;
      const right = this._drawer.direction === &apos;right&apos; &amp;&amp; moveInfo.x &lt; 0;
      const bottom = this._drawer.direction === &apos;bottom&apos; &amp;&amp; moveInfo.y &lt; 0;
      const left = this._drawer.direction === &apos;left&apos; &amp;&amp; moveInfo.x &gt;= 0;

      return (vertical &amp;&amp; (bottom || top)) ||
        (horizontal &amp;&amp; (right || left)) ?
        &apos;open&apos; :
        &apos;close&apos;;
    }

    return this._getStateFromPosition();
  }

  /**
   * Return drawer event handler.
   *
   * @return {Object} Drawer event handler.
   */
  _getDrawerHandler() {
    const handler = {};

    handler.resize = () =&gt; {
      this._resetDrawer();
      this[this.state](0, false, false);

      if (this._drawer.onResize) {
        this._drawer.onResize.apply(
          this,
          [this._drawer]
        );
      }
    };

    if (this._drawer.swipeable) {
      for (let event of TOUCH_EVENTS) {
        handler[event] = this._touchHandler.bind(this);
      }
    }

    if (window.history
      &amp;&amp; window.history.pushState
      &amp;&amp; this._drawer.history
    ) {
      handler.popstate = (e) =&gt; {
        if (e.state &amp;&amp; e.state.id === this._id &amp;&amp; this.state === &apos;open&apos;) {
          this.close(null, true, false);
        }
      };
    }

    return handler;
  }

  /**
   * Touch event handler.
   *
   * @param {Event} ev Touch event object.
   * @return {boolean} Event bubbling.
   */
  _touchHandler(ev) {
    try {
      if (ev.touches.length &gt; 1) {
        return true;
      }

      let touch = ev.touches[0];

      if (touch) {
        this._process.touches.push(touch);
      }

      switch (ev.type) {
        case &apos;touchstart&apos;:
          this._onTouchStart(ev);
          break;
        case &apos;touchmove&apos;:
          this._onTouchMove(ev);
          break;
        case &apos;touchcancel&apos;:
        case &apos;touchend&apos;:
          this._onTouchFinish(ev);
          break;
        default:
          break;
      }
    } catch (e) {
      if (this._drawer.onError &amp;&amp; typeof this._drawer.onError === &apos;function&apos;) {
        this._drawer.onError.apply(this, [e]);
      } else {
        throw e;
      }
    }

    return true;
  }

  /**
   * Touch start event handler.
   *
   * @param {Event} ev Touch event object.
   */
  _onTouchStart(ev) {
    this._process.time.start = new Date().getTime();
  }

  /**
   * Touch move event handler.
   *
   * @param {Event} ev Touch event object.
   */
  _onTouchMove(ev) {
    const len = this._process.touches.length;

    if (len &lt; 2) {
      return;
    }

    if (!this._process.isTouchPointActive) {
      this._process.isTouchPointActive = this._isTouchPointActive();
    }

    if (!this._process.isTouchPointActive) {
      return;
    }

    if (this._process.isTouchDirectionActive === null) {
      this._process.isTouchDirectionActive = this._isTouchDirectionActive();
    }

    if (!this._process.isTouchDirectionActive) {
      return;
    }

    let isFireTouchStart = false;
    const isTouchActive = this._process.isTouchPointActive &amp;&amp;
        this._process.isTouchDirectionActive;

    if (!isTouchActive) {
      return;
    }

    if (!this._process.isTouchActive) {
      this._process.isTouchActive = isTouchActive;
      this._showOverlay();
      this._showDrawer();

      if (this._drawer.onTouchStart) {
        isFireTouchStart = true;
      }
    }

    ev.stopPropagation();
    ev.preventDefault();

    this._position = this._getDrawerPositionFromTouches(
      this._process.touches[len - 2],
      this._process.touches[len - 1]
    );

    if (isFireTouchStart) {
      this._drawer.onTouchStart.apply(
        this,
        [this._drawer, this._position]
      );
    }

    helper.setStyle(
      this._overlay.element,
      this._getOverlayStyle(
        this._getOverlayOpacityFromPosition(this._position),
        0
      )
    );

    helper.setStyle(
      this._drawer.element,
      this._getDrawerStyle(this._position, 0)
    );

    if (this._drawer.onTouchMove) {
      this._drawer.onTouchMove.apply(
        this,
        [this._drawer, this._position]
      );
    }
  }

  /**
   * Touch finish event handler.
   *
   * @param {Event} ev Touch event object.
   */
  _onTouchFinish(ev) {
    const len = this._process.touches.length;

    if (this._process.isTouchActive &amp;&amp; len &gt;= 2) {
      this._process.time.end = new Date().getTime();

      const state = this._getTouchMoveState();
      const changeState = this.state !== state;

      this[state](null, changeState, changeState);

      if (this._drawer.onTouchFinish) {
        this._drawer.onTouchFinish.apply(
          this,
          [
            this._drawer,
            this._getDrawerPositionFromTouches(
              this._process.touches[len - 2],
              this._process.touches[len - 1]
            ),
          ]
        );
      }
    }

    this._process.touches = [];
    this._process.isTouchActive = null;
    this._process.isTouchPointActive = null;
    this._process.isTouchDirectionActive = null;
    this._process.time.start = 0;
    this._process.time.end = 0;
  }

  /**
   * Return whether or not a valid touch.
   *
   * @param {number} position Moving position.
   * @param {number} [duration=null] Drawer moving time.
   * @param {Object} [callbacks=null] Callback objects.
   * @param {boolean} [isChangeHistory=false] Make a change in history.
   * @return {Promise} Promise object.
   */
  _changeState(
    position,
    duration = null,
    callbacks = null,
    isChangeHistory = true
  ) {
    return this._handleCallback(new Promise((resolve, reject) =&gt; {
      try {
        if (!this._enabled) {
          throw new Error(&apos;Drawer is disabled.&apos;);
        }

        this._position = position;

        const du = duration === null ? this._drawer.duration : duration;

        if (this._timeoutId !== null) {
          clearTimeout(this._timeoutId);
          this._timeoutId = null;
        }

        const state = this._getStateFromPosition();

        if (state === &apos;open&apos;) {
          this._showOverlay();
          this._showDrawer();
        } else {
          this._overlay.element.removeEventListener(&apos;click&apos;, this._overlay.touchHandler);
        }

        if (isChangeHistory
          &amp;&amp; this._drawer.history
          &amp;&amp; window.history
          &amp;&amp; window.history.pushState
        ) {
          if (state === &apos;open&apos;) {
            window.history.pushState({
              id: this._id,
            }, null, null);
          } else {
            window.history.back();
          }
        }

        this[support.cssAnim
          ? &apos;_cssAnimate&apos;
          : &apos;_jsAnimate&apos;](du);

        if (du &gt; 0) {
          this._timeoutId = setTimeout(
            () =&gt; {
              this._changeOverlayState(state);
              this._timeoutId = null;
            },
            du
          );
        } else {
          this._changeOverlayState(state);
        }

        this.state = state;

        if (typeof callbacks === &apos;object&apos; &amp;&amp; callbacks.onChangeState) {
          callbacks.onChangeState.apply(
            this,
            [this._drawer, state]
          );
        }

        resolve.apply(this, [this._drawer]);
      } catch (e) {
        reject(e);
      }
    }), {
      done: typeof callbacks === &apos;object&apos; &amp;&amp; callbacks.done ? callbacks.done : null,
      fail: typeof callbacks === &apos;object&apos; &amp;&amp; callbacks.fail ? callbacks.fail : null,
    });
  }

  /**
   * Return whether or not a valid touch point.
   *
   * @return {boolean} Result of valid touch point.
   */
  _isTouchPointActive() {
    const rg = this._getRange(
      this.state === &apos;open&apos; ?
        this._sizePixel :
        this._drawer.swipeArea
    );
    const len = this._process.touches.length;

    return (rg.from.x &lt;= this._process.touches[len - 2].clientX &amp;&amp;
      this._process.touches[len - 2].clientX &lt;= rg.to.x &amp;&amp;
      rg.from.y &lt;= this._process.touches[len - 2].clientY &amp;&amp;
      this._process.touches[len - 2].clientY &lt;= rg.to.y);
  }

  /**
   * Return whether or not a valid touch direction.
   *
   * @return {boolean} Result of valid touch direction.
   */
  _isTouchDirectionActive() {
    const len = this._process.touches.length;
    const moveInfo = this._getTouchMoveInfo(
      this._process.touches[len - 2],
      this._process.touches[len - 1]
    );
    const vertical = moveInfo.axis === &apos;vertical&apos;;
    const horizontal = moveInfo.axis === &apos;horizontal&apos;;

    if (!(vertical &amp;&amp;
      (this._drawer.direction === &apos;top&apos; ||
      this._drawer.direction === &apos;bottom&apos;) ||
      horizontal &amp;&amp;
      (this._drawer.direction === &apos;right&apos; ||
      this._drawer.direction === &apos;left&apos;))
    ) {
      return false;
    }

    return (
      (
        this.state === &apos;open&apos; &amp;&amp;
        (
          this._drawer.direction === &apos;top&apos; &amp;&amp; moveInfo.y &lt; 0 ||
          this._drawer.direction === &apos;right&apos; &amp;&amp; moveInfo.x &gt;= 0 ||
          this._drawer.direction === &apos;bottom&apos; &amp;&amp; moveInfo.y &gt;= 0 ||
          this._drawer.direction === &apos;left&apos; &amp;&amp; moveInfo.x &lt; 0
        )
      ) ||
      (
        this.state === &apos;close&apos; &amp;&amp;
        (
          this._drawer.direction === &apos;top&apos; &amp;&amp; moveInfo.y &gt;= 0 ||
          this._drawer.direction === &apos;right&apos; &amp;&amp; moveInfo.x &lt; 0 ||
          this._drawer.direction === &apos;bottom&apos; &amp;&amp; moveInfo.y &lt; 0 ||
          this._drawer.direction === &apos;left&apos; &amp;&amp; moveInfo.x &gt;= 0
        )
      )
    );
  }

  /**
   * Return the state of the drawer.
   *
   * @return {string} State of the drawer.
   */
  _getStateFromPosition() {
    const pos = this._position === null ?
      this._getDrawerPositionFromStyle() :
      this._position;

    return Math.abs(pos) &lt; this._sizePixel / 2 ?
      &apos;open&apos; :
      &apos;close&apos;;
  }

  /**
   * Return the position of the drawer.
   *
   * @param {Object} touchbasis Basic touch information.
   * @param {Object} touchlast Last touch information.
   * @return {number} Position of the drawer.
   */
  _getDrawerPositionFromTouches(touchbasis, touchlast) {
    const distance = this._getDistance(
      this._getTouchMoveInfo(touchbasis, touchlast)
    );
    const curpos = this._position === null ?
      this._getDrawerPositionFromStyle() :
      this._position;
    const minp = this._getMinPosition(this._drawer);
    let pos = Math.round(curpos + distance);

    if (pos &gt; 0) {
      pos = 0;
    } else if (pos &lt; minp) {
      pos = minp;
    }

    return pos;
  }

  /**
   * Return the position in the style.
   *
   * @return {number} Position in the style.
   */
  _getDrawerPositionFromStyle() {
    const value = this._drawer.element.style[this._drawer.direction];
    return this._normalizeNumber(value).value;
  }

  /**
   * Return the opacity of the overlay.
   *
   * @param {number} position Moving position.
   * @return {number} Position of the drawer.
   */
  _getOverlayOpacityFromPosition(position) {
    const minp = this._getMinPosition(this._drawer);
    const posRatio = 1 - (Math.abs(position) / Math.abs(minp));
    return ((this._overlay.opacity * posRatio) * 10000) / 10000;
  }

  /**
   * Return the opacity in the style.
   *
   * @return {number} Opacity in the style.
   */
  _getOverlayOpacityFromStyle() {
    return parseFloat(this._overlay.element.style.opacity);
  }

  /**
   * Return the swipe range.
   *
   * @param {string|number} value Target swipe area value.
   * @return {Object} Drag range.
   * @throws {Error} Is thrown if direction value is invalid.
   */
  _getRange(value) {
    const basis = this._convertPixelAbs(value);
    const width = window.innerWidth;
    const height = window.innerHeight;

    switch (this._drawer.direction) {
      case &apos;top&apos;:
        return {from: {x: 0, y: 0}, to: {x: width, y: basis}};
      case &apos;right&apos;:
        return {from: {x: basis, y: 0}, to: {x: width, y: height}};
      case &apos;bottom&apos;:
        return {from: {x: 0, y: basis}, to: {x: width, y: height}};
      case &apos;left&apos;:
        return {from: {x: 0, y: 0}, to: {x: basis, y: height}};
      default:
        throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
    }
  }

  /**
   * Return a value converted to the absolute value of the pixel.
   *
   * @param {string|number} value Target value.
   * @return {number} Converted to the absolute value of the pixel.
   * @throws {Error} Is thrown if direction value is invalid.
   */
  _convertPixelAbs(value) {
    const nValue = this._normalizePixel(value);

    switch (this._drawer.direction) {
      case &apos;top&apos;:
      case &apos;left&apos;:
        return nValue;
      case &apos;right&apos;:
        return window.innerWidth - nValue;
      case &apos;bottom&apos;:
        return window.innerHeight - nValue;
      default:
        throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
    }
  }

  /**
   * Return the normalized pixel value.
   *
   * @param {string|number} value Target value.
   * @return {number} Normalized pixel value.
   * @throws {Error} Is thrown if direction value is invalid.
   */
  _normalizePixel(value) {
    const nValue = this._normalizeNumber(value);

    if (nValue.unit === &apos;number&apos; || nValue.unit === &apos;pixel&apos;) {
      return nValue.value;
    } else if (nValue.unit === &apos;percent&apos;) {
      switch (this._drawer.direction) {
        case &apos;top&apos;:
        case &apos;bottom&apos;:
          return window.innerHeight * (nValue.value / 100);
        case &apos;right&apos;:
        case &apos;left&apos;:
          return window.innerWidth * (nValue.value / 100);
        default:
          throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
      }
    }
  }

  /**
   * Return the numeric normalized information.
   *
   * @param {string|number} value Target value.
   * @return {Object} Numeric normalized information.
   * @throws {Error} Is thrown if value is invalid.
   */
  _normalizeNumber(value) {
    if (typeof value === &apos;number&apos;) {
      return {value: value, unit: &apos;number&apos;};
    } else if (String(value).match(/^[.\-0-9]+$/)) {
      return {value: Number(value), unit: &apos;number&apos;};
    } else if (value.match(/^[.\-0-9]+px$/)) {
      return {value: Number(value.replace(/px$/ig, &apos;&apos;)), unit: &apos;pixel&apos;};
    } else if (value.match(/[.\-0-9]+%$/)) {
      return {value: Number(value.replace(/%$/ig, &apos;&apos;)), unit: &apos;percent&apos;};
    }

    throw new Error(`&apos;${value}&apos; does not support`);
  }

  /**
   * Return to the minimum position for the drawer.
   *
   * @return {number} Minimum position for the drawer.
   * @throws {Error} Is thrown if direction value is invalid.
   */
  _getMinPosition() {
    switch (this._drawer.direction) {
      case &apos;top&apos;:
      case &apos;bottom&apos;:
        return -1 * this._drawer.element.offsetHeight;
      case &apos;right&apos;:
      case &apos;left&apos;:
        return -1 * this._drawer.element.offsetWidth;
      default:
        throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
    }
  }

  /**
   * Return the distance of the drawer.
   *
   * @param {Object} moveInfo Movement information of the drawer.
   * @return {number} Distance of the drawer.
   * @throws {Error} Is thrown if direction value is invalid.
   */
  _getDistance(moveInfo) {
    switch (this._drawer.direction) {
      case &apos;top&apos;:
        return moveInfo.y;
      case &apos;right&apos;:
        return -1 * moveInfo.x;
      case &apos;bottom&apos;:
        return -1 * moveInfo.y;
      case &apos;left&apos;:
        return moveInfo.x;
      default:
        throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
    }
  }

  /**
   * Return the information of touch move.
   *
   * @param {Object} touchbasis Basic touch information.
   * @param {Object} touchlast Last touch information.
   * @return {Object} Movement distance of the x, y direction, movement direction.
   */
  _getTouchMoveInfo(touchbasis, touchlast) {
    const x = touchlast.clientX - touchbasis.clientX;
    const y = touchlast.clientY - touchbasis.clientY;
    const axis = Math.abs(x) &gt;= Math.abs(y) ? &apos;horizontal&apos; : &apos;vertical&apos;;
    return {x, y, axis};
  }

  /**
   * Return the information of touch move.
   *
   * @param {Promise} promise Promise instance.
   * @param {Object} callbacks Callback function with the key to &apos;done&apos;, &apos;fail&apos;, &apos;always&apos; (each optional).
   * @return {Promise} Promise instance.
   */
  _handleCallback(promise, callbacks) {
    if (!callbacks) {
      return promise;
    }

    for (let key of Object.keys(callbacks)) {
      const callback = callbacks[key];

      if (!callback) {
        continue;
      }

      const cb = isArray(callback) ? callback : [callback];
      const rcb = null;

      switch (key) {
        case &apos;done&apos;:
          rcb = (prom, value) =&gt; prom.then(value.bind(this));
          break;
        case &apos;fail&apos;:
          rcb = (prom, value) =&gt; prom.catch(value.bind(this));
          break;
        case &apos;always&apos;:
          rcb = (prom, value) =&gt; prom.then(value.bind(this), value.bind(this));
          break;
        default:
          break;
      }

      if (rcb) {
        cb.reduce(rcb, promise);
      }
    }

    return promise;
  }
}

module.exports = Highendrawer;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
