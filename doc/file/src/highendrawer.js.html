<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/highendrawer.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/ym-aozora/highendrawer" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/highendrawer.js~Highendrawer.html">Highendrawer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-generateid">generateid</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hasstyle">hasstyle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setstyle">setstyle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-unsetstyle">unsetstyle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isarray">isarray</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ucfirst">ucfirst</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DEFAULT_DRAWER_PROPERTY">DEFAULT_DRAWER_PROPERTY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DEFAULT_OVERLAY_PROPERTY">DEFAULT_OVERLAY_PROPERTY</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DEFAULT_PROCESS">DEFAULT_PROCESS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-DRAWER_STYLE">DRAWER_STYLE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-OVERLAY_STYLE">OVERLAY_STYLE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PREFIX">PREFIX</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TOUCH_EVENTS">TOUCH_EVENTS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TRANSITION_STYLE">TRANSITION_STYLE</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-support">support</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Drawer">Drawer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Overlay">Overlay</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/highendrawer.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

import {
  DEFAULT_DRAWER_PROPERTY,
  DEFAULT_OVERLAY_PROPERTY,
  DEFAULT_PROCESS,
  DRAWER_STYLE,
  OVERLAY_STYLE,
  TOUCH_EVENTS,
  TRANSITION_STYLE,
} from &apos;./const&apos;;

import {isarray} from &apos;./util&apos;;
import * as helper from &apos;./helper&apos;;
import {support} from &apos;./support&apos;;

/**
 * Class providing a drawer function.
 *
 * @public
 * @class
 * @example
 * var drawer = new DrawerMenu({
 *   element: document.getElementById(&apos;drawer&apos;)
 * });
 */
export default class Highendrawer {

  /**
   * Initialize object.
   *
   * @constructor
   * @param {Drawer} drawer Initial parameters of drawer.
   */
  constructor(drawer) {
    /**
     * Drawer status (&apos;open&apos; or &apos;close&apos;)
     *
     * @public
     * @type {string}
     */
    this.state = &apos;close&apos;;

    this._id = helper.generateid();
    this._drawer = Object.assign({}, DEFAULT_DRAWER_PROPERTY, drawer);
    this._overlay = this._drawer.overlay === false ?
      false :
      Object.assign({}, DEFAULT_OVERLAY_PROPERTY, this._drawer.overlay);
    this._timeoutid = null;
    this._intervalid = null;
    this._process = Object.assign({}, DEFAULT_PROCESS);
    this._enabled = false;
    this._handler = this._getdrawerhandler();

    if (this._drawer.enabledmaxwidth &gt; -1) {
      window.addEventListener(&apos;resize&apos;, () =&gt; {
        if (this._enabled
          &amp;&amp; window.innerWidth &gt; this._drawer.enabledmaxwidth) {
          this.destroy();
        } else if (!this._enabled
          &amp;&amp; window.innerWidth &lt;= this._drawer.enabledmaxwidth) {
          this.create();
        }
      });
    }

    if (window.history
      &amp;&amp; window.history.pushState
      &amp;&amp; this._drawer.ishistory
    ) {
      window.history.replaceState({
        id: this._id,
      }, null, null);
    }

    if (this._drawer.isinitcreate) {
      this.create();
    }
  }

  /**
   * Create the drawer set.
   *
   * @public
   */
  create() {
    try {
      this._createdrawer();
      this._createoverlay();
      this._enabled = true;

      if (this._drawer.oncreate) {
        this._drawer.oncreate.apply(this, [this._drawer]);
      }
    } catch (e) {
      if (this._drawer &amp;&amp; this._drawer.onerror &amp;&amp; typeof this._drawer.onerror === &apos;function&apos;) {
        this._drawer.onerror.apply(this, [e]);
      } else {
        throw e;
      }
    }
  }

  /**
   * Destroy the drawer set.
   *
   * @public
   */
  destroy() {
    try {
      this._destroydrawer();
      this._destroyoverlay();
      this._enabled = false;

      if (this._drawer.ondestroy) {
        this._drawer.ondestroy.apply(this, [this._drawer]);
      }
    } catch (e) {
      if (this._drawer &amp;&amp; this._drawer.onerror &amp;&amp; typeof this._drawer.onerror === &apos;function&apos;) {
        this._drawer.onerror.apply(this, [e]);
      } else {
        throw e;
      }
    }
  }

  /**
   * Open drawer.
   *
   * @public
   * @param {number} [duration] Drawer moving time.
   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.
   * @param {boolean} [ischangehistory=false] Make a change in history.
   * @return {Promise} Promise object for open.
   */
  open(duration = null, isfireevent = true, ischangehistory = true) {
    return this._changestate(
      0,
      duration,
      {
        onchangestate: isfireevent ? this._drawer.onchangestate : null,
        done: isfireevent ? this._drawer.onopen : null,
        fail: isfireevent ? this._drawer.onerror : null,
      },
      ischangehistory
    );
  }

  /**
   * Close drawer.
   *
   * @public
   * @param {number} [duration] Drawer moving time.
   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.
   * @param {boolean} [ischangehistory=false] Make a change in history.
   * @return {Promise} Promise object for close.
   */
  close(duration = null, isfireevent = true, ischangehistory = true) {
    return this._changestate(
      this._getminposition(),
      duration,
      {
        onchangestate: isfireevent ? this._drawer.onchangestate : null,
        done: isfireevent ? this._drawer.onclose : null,
        fail: isfireevent ? this._drawer.onerror : null,
      },
      ischangehistory
    );
  }

  /**
   * Toggle drawer.
   *
   * @public
   * @param {number} [duration] Drawer moving time.
   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.
   * @param {boolean} [ischangehistory=false] Make a change in history.
   * @return {Promise} Promise object for toggle.
   */
  toggle(duration = null, isfireevent = true, ischangehistory = true) {
    return new Promise((resolve, reject) =&gt; {
      try {
        this[this.state === &apos;open&apos; ? &apos;close&apos; : &apos;open&apos;](duration, isfireevent, ischangehistory)
          .then(resolve, reject);
      } catch (e) {
        reject(e);
      }
    });
  }

  /**
   * Create drawer.
   */
  _createdrawer() {
    helper.setstyle(
      this._drawer.element,
      Object.assign(
        {},
        DRAWER_STYLE,
        support.cssanim ? TRANSITION_STYLE : {}
      )
    );

    this._resetdrawer();

    Object.keys(this._handler).forEach((name) =&gt; {
      window.addEventListener(name, this._handler[name]);
    });
  }

  /**
   * Destroy drawer.
   */
  _destroydrawer() {
    Object.keys(this._handler).forEach((name) =&gt; {
      window.removeEventListener(name, this._handler[name]);
    });

    this._resetdrawer(true);

    helper.unsetstyle(
      this._drawer.element,
      Object.keys(
        Object.assign(
          {},
          DRAWER_STYLE,
          support.cssanim ? TRANSITION_STYLE : {}
        )
      )
    );
  }

  /**
   * Create overlay.
   */
  _createoverlay() {
    if (this._overlay === false) {
      return;
    }

    if (this._overlay.zindex === -1) {
      this._overlay.zindex = this._drawer.zindex - 1;
    }

    if (!this._overlay.element) {
      this._overlay.element = window.document.createElement(&apos;div&apos;);
      this._overlay.isautocreated = true;

      helper.setstyle(
        this._overlay.element,
        Object.assign(
          {},
          OVERLAY_STYLE,
          support.cssanim ? TRANSITION_STYLE : {}
        )
      );
    }

    if (!this._overlay.touchhandler) {
      this._overlay.touchhandler = (e) =&gt; {
        this.close();
      };
    }

    window.document.body.appendChild(this._overlay.element);
  }

  /**
   * Destroy overlay.
   */
  _destroyoverlay() {
    if (this._overlay === false) {
      return;
    }

    if (this._overlay.element) {
      this._overlay.element.removeEventListener(&apos;click&apos;, this._overlay.touchhandler);

      if (this._overlay.isautocreated) {
        this._overlay.element.parentNode.removeChild(this._overlay.element);
      }
    }
  }

  /**
   * Reset drawer.
   *
   * @param {boolean} [isunset] Unset style.
   */
  _resetdrawer(isunset = false) {
    try {
      this._setprops();

      let ims = this._getinitdrawerstyle();

      if (isunset) {
        helper.unsetstyle(this._drawer.element, Object.keys(ims));
      } else {
        helper.setstyle(this._drawer.element, ims);
      }
    } catch (e) {
      if (this._drawer.onerror &amp;&amp; typeof this._drawer.onerror === &apos;function&apos;) {
        this._drawer.onerror.apply(this, [e]);
      } else {
        throw e;
      }
    }
  }

  /**
   * Show drawer.
   */
  _showdrawer() {
    helper.setstyle(this._drawer.element, {
      zIndex: this._drawer.zindex,
    });
  }

  /**
   * Hide drawer.
   */
  _hidedrawer() {
    helper.setstyle(this._drawer.element, {
      zIndex: -1,
    });
  }

  /**
   * Show overlay.
   */
  _showoverlay() {
    helper.setstyle(this._overlay.element, {
      zIndex: this._overlay.zindex,
      display: &apos;block&apos;,
    });
  }

  /**
   * Hide overlay.
   */
  _hideoverlay() {
    helper.setstyle(this._overlay.element, {
      zIndex: -1,
      display: &apos;none&apos;,
    });
  }

  /**
   * Set properties.
   */
  _setprops() {
    // set sizepixel
    let sizepixel = this._normalizepixel(
      this._drawer.size
    );

    let maxsizepixel = this._normalizepixel(
      this._drawer.maxsize
    );

    if (sizepixel &gt; maxsizepixel) {
      sizepixel = maxsizepixel;
    }

    this._sizepixel = sizepixel;

    // set position
    this._position = typeof this._position === &apos;undefined&apos; ?
      null :
      this._position;
  }

  /**
   * Return initial style of drawer.
   *
   * @return {Object} Style for drawer.
   */
  _getinitdrawerstyle() {
    let style = null;

    switch (this._drawer.direction) {
      case &apos;top&apos;:
        style = {
          width: &apos;100%&apos;,
          height: `${this._sizepixel}px`,
          top: `-${this._sizepixel}px`,
          right: &apos;auto&apos;,
          bottom: &apos;auto&apos;,
          left: 0,
        };
        break;
      case &apos;right&apos;:
        style = {
          width: `${this._sizepixel}px`,
          height: &apos;100%&apos;,
          top: 0,
          right: `-${this._sizepixel}px`,
          bottom: &apos;auto&apos;,
          left: &apos;auto&apos;,
        };
        break;
      case &apos;bottom&apos;:
        style = {
          width: &apos;100%&apos;,
          height: `${this._sizepixel}px`,
          top: &apos;auto&apos;,
          right: &apos;auto&apos;,
          bottom: `-${this._sizepixel}px`,
          left: 0,
        };
        break;
      case &apos;left&apos;:
        style = {
          width: `${this._sizepixel}px`,
          height: &apos;100%&apos;,
          top: 0,
          right: &apos;auto&apos;,
          bottom: &apos;auto&apos;,
          left: `-${this._sizepixel}px`,
        };
        break;
      default:
        throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
    }

    return Object.assign(style, this._drawer.style || {});
  }

  /**
   * Return style for moving the drawer.
   *
   * @param {number} position Moving position.
   * @param {number} [duration] Drawer moving time.
   * @return {Object} Move style for drawer.
   */
  _getdrawerstyle(position, duration = null) {
    let minp = this._getminposition(this._drawer);
    let style = {};

    if (support.cssanim) {
      style.transitionDuration = `${duration === null ? this._drawer.duration : duration}ms`;

      switch (this._drawer.direction) {
        case &apos;top&apos;:
          style.transform = `${support.transrate}(0,${-(minp - position)}px,0)`;
          break;
        case &apos;right&apos;:
          style.transform = `${support.transrate}(${minp - position}px,0,0)`;
          break;
        case &apos;bottom&apos;:
          style.transform = `${support.transrate}(0,${minp - position}px,0)`;
          break;
        case &apos;left&apos;:
          style.transform = `${support.transrate}(${-(minp - position)}px,0,0)`;
          break;
        default:
          throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
      }
    } else {
      style[this._drawer.direction] = `${position}px`;
    }

    return style;
  }

  /**
   * Return style for moving the overlay.
   *
   * @param {float} opacity Overlay opacity.
   * @param {number} [duration] Drawer moving time.
   * @return {Object} Move style for overlay.
   */
  _getoverlaystyle(opacity, duration = null) {
    let style = {
      opacity,
    };

    if (support.cssanim) {
      style.transitionDuration = `${duration === null ? this._drawer.duration : duration}ms`;
    }

    return style;
  }

  /**
   * Make animation with CSS3.
   *
   * @param {number} duration Drawer moving time.
   */
  _cssanimate(duration) {
    helper.setstyle(
      this._overlay.element,
      this._getoverlaystyle(
        this._getoverlayopacityfromposition(this._position),
        duration
      )
    );

    helper.setstyle(
      this._drawer.element,
      this._getdrawerstyle(this._position, duration)
    );
  }

  /**
   * Make animation with Javascript.
   *
   * @param {number} duration Drawer moving time.
   */
  _jsanimate(duration) {
    let start = +new Date();
    let fromopy = this._getoverlayopacityfromstyle();
    let toopy = this._getoverlayopacityfromposition(this._position);
    let frompos = this._getdrawerpositionfromstyle();
    let topos = this._position;

    if (this._intervalid) {
      clearInterval(this._intervalid);
    }

    this._intervalid = setInterval(() =&gt; {
      let time = new Date() - start;
      let nowpos = null;
      let nowopy = null;

      if (time &gt; duration) {
        clearInterval(this._intervalid);
        this._intervalid = null;
        nowopy = toopy;
        nowpos = topos;
      } else {
        let prp = (time /= duration) * (time - 2);
        nowopy = fromopy - ((toopy - fromopy) * prp);
        nowpos = frompos - ((topos - frompos) * prp);
      }

      helper.setstyle(
        this._overlay.element,
        this._getoverlaystyle(nowopy, duration)
      );

      helper.setstyle(
        this._drawer.element,
        this._getdrawerstyle(nowpos, duration)
      );
    }, 10);
  }

  /**
   * Return state by touch movement.
   *
   * @param {Array} touches Touch object array.
   * @param {Object} time Time information on start and end of movement.
   * @return {string} State by touch movement.
   */
  _gettouchmovestate(touches, time) {
    if (time.end - time.start &lt;= 300) {
      let len = touches.length;

      if (len &gt;= 2) {
        let moveinfo = this._gettouchmoveinfo(
          touches[len - 2],
          touches[len - 1]
        );
        let ish = moveinfo.axis === &apos;horizontal&apos;;
        let isv = moveinfo.axis === &apos;vertical&apos;;
        let ist = this._drawer.direction === &apos;top&apos; &amp;&amp; moveinfo.y &gt;= 0;
        let isr = this._drawer.direction === &apos;right&apos; &amp;&amp; moveinfo.x &lt; 0;
        let isb = this._drawer.direction === &apos;bottom&apos; &amp;&amp; moveinfo.y &lt; 0;
        let isl = this._drawer.direction === &apos;left&apos; &amp;&amp; moveinfo.x &gt;= 0;

        return (ish &amp;&amp; (isr || isl)) || (isv &amp;&amp; (isb || ist)) ?
          &apos;open&apos; :
          &apos;close&apos;;
      }
    }

    return this._getstatefromposition();
  }

  /**
   * Return drawer event handler.
   *
   * @return {Object} Drawer event handler.
   */
  _getdrawerhandler() {
    let handler = {};

    handler.resize = () =&gt; {
      this._resetdrawer();
      this[this.state](0, false, false);

      if (this._drawer.onresize) {
        this._drawer.onresize.apply(
          this,
          [this._drawer]
        );
      }
    };

    if (this._drawer.isswipeable) {
      for (let event of TOUCH_EVENTS) {
        handler[event] = this._touchhandler.bind(this);
      }
    }

    if (window.history
      &amp;&amp; window.history.pushState
      &amp;&amp; this._drawer.ishistory
    ) {
      handler.popstate = (e) =&gt; {
        if (e.state &amp;&amp; e.state.id === this._id &amp;&amp; this.state === &apos;open&apos;) {
          this.close(null, true, false);
        }
      };
    }

    return handler;
  }

  /**
   * Touch event handler.
   *
   * @param {Event} ev Touch event object.
   * @return {boolean} Event bubbling.
   */
  _touchhandler(ev) {
    try {
      if (ev.touches.length &gt; 1) {
        return true;
      }

      let touch = ev.touches[0];

      if (touch) {
        this._process.touches.push(touch);
      }

      switch (ev.type) {
        case &apos;touchstart&apos;:
          this._ontouchstart(ev);
          break;
        case &apos;touchmove&apos;:
          this._ontouchmove(ev);
          break;
        case &apos;touchcancel&apos;:
        case &apos;touchend&apos;:
          this._ontouchfinish(ev);
          break;
        default:
          break;
      }
    } catch (e) {
      if (this._drawer.onerror &amp;&amp; typeof this._drawer.onerror === &apos;function&apos;) {
        this._drawer.onerror.apply(this, [e]);
      } else {
        throw e;
      }
    }

    return true;
  }

  /**
   * Touch start event handler.
   *
   * @param {Event} ev Touch event object.
   */
  _ontouchstart(ev) {
    this._process.time.start = new Date().getTime();
  }

  /**
   * Touch move event handler.
   *
   * @param {Event} ev Touch event object.
   */
  _ontouchmove(ev) {
    let len = this._process.touches.length;
    let isfiretouchstart = false;

    if (!this._process.istouchactive &amp;&amp; len &gt;= 2) {
      this._process.istouchactive = this._istouchactive(
        this._process.touches[0]
      );

      if (this._process.istouchactive) {
        this._showoverlay();
        this._showdrawer();

        if (this._drawer.ontouchstart) {
          isfiretouchstart = true;
        }
      }
    }

    if (this._process.istouchactive) {
      ev.stopPropagation();
      ev.preventDefault();

      this._position = this._getdrawerpositionfromtouches(
        this._process.touches[len - 2],
        this._process.touches[len - 1]
      );

      if (isfiretouchstart) {
        this._drawer.ontouchstart.apply(
          this,
          [this._drawer, this._position]
        );
      }

      helper.setstyle(
        this._overlay.element,
        this._getoverlaystyle(
          this._getoverlayopacityfromposition(this._position),
          0
        )
      );

      helper.setstyle(
        this._drawer.element,
        this._getdrawerstyle(this._position, 0)
      );

      if (this._drawer.ontouchmove) {
        this._drawer.ontouchmove.apply(
          this,
          [this._drawer, this._position]
        );
      }
    }
  }

  /**
   * Touch finish event handler.
   *
   * @param {Event} ev Touch event object.
   */
  _ontouchfinish(ev) {
    let len = this._process.touches.length;

    if (this._process.istouchactive &amp;&amp; len &gt;= 2) {
      this._process.time.end = new Date().getTime();

      let state = this._gettouchmovestate(
        this._process.touches,
        this._process.time
      );

      let changestate = this.state !== state;

      this[state](null, changestate, changestate);

      if (this._drawer.ontouchfinish) {
        this._drawer.ontouchfinish.apply(
          this,
          [
            this._drawer,
            this._getdrawerpositionfromtouches(
              this._process.touches[len - 2],
              this._process.touches[len - 1]
            ),
          ]
        );
      }
    }

    this._process.touches = [];
    this._process.istouchactive = false;
    this._process.time.start = 0;
    this._process.time.end = 0;
  }

  /**
   * Return whether or not a valid touch.
   *
   * @param {number} position Moving position.
   * @param {number} [duration=null] Drawer moving time.
   * @param {Object} [callbacks=null] Callback objects.
   * @param {boolean} [ischangehistory=false] Make a change in history.
   * @return {Promise} Promise object.
   */
  _changestate(
    position,
    duration = null,
    callbacks = null,
    ischangehistory = true
  ) {
    return this._handlecallback(new Promise((resolve, reject) =&gt; {
      try {
        this._position = position;

        let du = duration === null ? this._drawer.duration : duration;

        if (this._timeoutid !== null) {
          clearTimeout(this._timeoutid);
          this._timeoutid = null;
        }

        let state = this._getstatefromposition();

        if (state === &apos;open&apos;) {
          this._showoverlay();
          this._showdrawer();
        } else {
          this._overlay.element.removeEventListener(&apos;click&apos;, this._overlay.touchhandler);
        }

        if (ischangehistory
          &amp;&amp; this._drawer.ishistory
          &amp;&amp; window.history
          &amp;&amp; window.history.pushState
        ) {
          if (state === &apos;open&apos;) {
            window.history.pushState({
              id: this._id,
            }, null, null);
          } else {
            window.history.back();
          }
        }

        this[support.cssanim
          ? &apos;_cssanimate&apos;
          : &apos;_jsanimate&apos;](du);

        this._timeoutid = setTimeout(
          () =&gt; {
            if (state === &apos;open&apos;) {
              this._overlay.element.addEventListener(&apos;click&apos;, this._overlay.touchhandler);
            } else {
              this._hidedrawer();
              this._hideoverlay();
            }

            this._timeoutid = null;
          },
          du
        );

        this.state = state;

        if (typeof callbacks === &apos;object&apos; &amp;&amp; callbacks.onchangestate) {
          callbacks.onchangestate.apply(
            this,
            [this._drawer, state]
          );
        }

        resolve.apply(this, [this._drawer]);
      } catch (e) {
        reject(e);
      }
    }), {
      done: typeof callbacks === &apos;object&apos; &amp;&amp; callbacks.done ? callbacks.done : null,
      fail: typeof callbacks === &apos;object&apos; &amp;&amp; callbacks.fail ? callbacks.fail : null,
    });
  }

  /**
   * Return whether or not a valid touch.
   *
   * @param {Object} touch Start touch information.
   * @return {boolean} Result of valid touch.
   */
  _istouchactive(touch) {
    let rg = this._getrange(
      this.state === &apos;open&apos; ?
        &apos;100%&apos; :
        this._drawer.swipearea
    );

    return (rg.from.x &lt;= touch.clientX &amp;&amp;
      touch.clientX &lt;= rg.to.x &amp;&amp;
      rg.from.y &lt;= touch.clientY &amp;&amp;
      touch.clientY &lt;= rg.to.y);
  }

  /**
   * Return the state of the drawer.
   *
   * @return {string} State of the drawer.
   */
  _getstatefromposition() {
    let pos = this._position === null ?
      this._getdrawerpositionfromstyle() :
      this._position;

    return Math.abs(pos) &lt; this._sizepixel / 2 ?
      &apos;open&apos; :
      &apos;close&apos;;
  }

  /**
   * Return the position of the drawer.
   *
   * @param {Object} touchbasis Basic touch information.
   * @param {Object} touchlast Last touch information.
   * @return {number} Position of the drawer.
   */
  _getdrawerpositionfromtouches(touchbasis, touchlast) {
    let distance = this._getdistance(
      this._gettouchmoveinfo(touchbasis, touchlast)
    );

    let curpos = this._position === null ?
      this._getdrawerpositionfromstyle() :
      this._position;

    let pos = Math.round(curpos + distance);
    let minp = this._getminposition(this._drawer);

    if (pos &gt; 0) {
      pos = 0;
    } else if (pos &lt; minp) {
      pos = minp;
    }

    return pos;
  }

  /**
   * Return the position in the style.
   *
   * @return {number} Position in the style.
   */
  _getdrawerpositionfromstyle() {
    let value = this._drawer.element.style[this._drawer.direction];
    return this._normalizenumber(value).value;
  }


  /**
   * Return the opacity of the overlay.
   *
   * @param {number} position Moving position.
   * @return {number} Position of the drawer.
   */
  _getoverlayopacityfromposition(position) {
    let minp = this._getminposition(this._drawer);
    let posratio = 1 - (Math.abs(position) / Math.abs(minp));
    return ((this._overlay.opacity * posratio) * 10000) / 10000;
  }

  /**
   * Return the opacity in the style.
   *
   * @return {number} Opacity in the style.
   */
  _getoverlayopacityfromstyle() {
    return parseFloat(this._overlay.element.style.opacity);
  }

  /**
   * Return the swipe range.
   *
   * @param {string|number} value Target swipe area value.
   * @return {Object} Drag range.
   * @throws {Error} Is thrown if direction value is invalid.
   */
  _getrange(value) {
    let basis = this._convertpixelabs(value);
    let width = window.innerWidth;
    let height = window.innerHeight;

    switch (this._drawer.direction) {
      case &apos;top&apos;:
        return {from: {x: 0, y: 0}, to: {x: width, y: basis}};
      case &apos;right&apos;:
        return {from: {x: basis, y: 0}, to: {x: width, y: height}};
      case &apos;bottom&apos;:
        return {from: {x: 0, y: basis}, to: {x: width, y: height}};
      case &apos;left&apos;:
        return {from: {x: 0, y: 0}, to: {x: basis, y: height}};
      default:
        throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
    }
  }

  /**
   * Return a value converted to the absolute value of the pixel.
   *
   * @param {string|number} value Target value.
   * @return {number} Converted to the absolute value of the pixel.
   * @throws {Error} Is thrown if direction value is invalid.
   */
  _convertpixelabs(value) {
    let nvalue = this._normalizepixel(value);

    switch (this._drawer.direction) {
      case &apos;top&apos;:
      case &apos;left&apos;:
        return nvalue;
      case &apos;right&apos;:
        return window.innerWidth - nvalue;
      case &apos;bottom&apos;:
        return window.innerHeight - nvalue;
      default:
        throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
    }
  }

  /**
   * Return the normalized pixel value.
   *
   * @param {string|number} value Target value.
   * @return {number} Normalized pixel value.
   * @throws {Error} Is thrown if direction value is invalid.
   */
  _normalizepixel(value) {
    let normalized = this._normalizenumber(value);

    if (normalized.unit === &apos;number&apos; || normalized.unit === &apos;pixel&apos;) {
      return normalized.value;
    } else if (normalized.unit === &apos;percent&apos;) {
      switch (this._drawer.direction) {
        case &apos;top&apos;:
        case &apos;bottom&apos;:
          return window.innerHeight * (normalized.value / 100);
        case &apos;right&apos;:
        case &apos;left&apos;:
          return window.innerWidth * (normalized.value / 100);
        default:
          throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
      }
    }
  }

  /**
   * Return the numeric normalized information.
   *
   * @param {string|number} value Target value.
   * @return {Object} Numeric normalized information.
   * @throws {Error} Is thrown if value is invalid.
   */
  _normalizenumber(value) {
    if (typeof value === &apos;number&apos;) {
      return {value: value, unit: &apos;number&apos;};
    } else if (String(value).match(/^[.\-0-9]+$/)) {
      return {value: Number(value), unit: &apos;number&apos;};
    } else if (value.match(/^[.\-0-9]+px$/)) {
      return {value: Number(value.replace(/px$/ig, &apos;&apos;)), unit: &apos;pixel&apos;};
    } else if (value.match(/[.\-0-9]+%$/)) {
      return {value: Number(value.replace(/%$/ig, &apos;&apos;)), unit: &apos;percent&apos;};
    }

    throw new Error(`&apos;${value}&apos; does not support`);
  }

  /**
   * Return to the minimum position for the drawer.
   *
   * @return {number} Minimum position for the drawer.
   * @throws {Error} Is thrown if direction value is invalid.
   */
  _getminposition() {
    switch (this._drawer.direction) {
      case &apos;top&apos;:
      case &apos;bottom&apos;:
        return -1 * this._drawer.element.offsetHeight;
      case &apos;right&apos;:
      case &apos;left&apos;:
        return -1 * this._drawer.element.offsetWidth;
      default:
        throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
    }
  }

  /**
   * Return the distance of the drawer.
   *
   * @param {Object} moveinfo Movement information of the drawer.
   * @return {number} Distance of the drawer.
   * @throws {Error} Is thrown if direction value is invalid.
   */
  _getdistance(moveinfo) {
    switch (this._drawer.direction) {
      case &apos;top&apos;:
        return moveinfo.y;
      case &apos;right&apos;:
        return -1 * moveinfo.x;
      case &apos;bottom&apos;:
        return -1 * moveinfo.y;
      case &apos;left&apos;:
        return moveinfo.x;
      default:
        throw new Error(`&apos;${this._drawer.direction}&apos; does not support`);
    }
  }

  /**
   * Return the information of touch move.
   *
   * @param {Object} touchbasis Basic touch information.
   * @param {Object} touchlast Last touch information.
   * @return {Object} Movement distance of the x, y direction, movement direction.
   */
  _gettouchmoveinfo(touchbasis, touchlast) {
    let x = touchlast.clientX - touchbasis.clientX;
    let y = touchlast.clientY - touchbasis.clientY;
    let axis = Math.abs(x) &gt;= Math.abs(y) ? &apos;horizontal&apos; : &apos;vertical&apos;;

    return {x, y, axis};
  }

  /**
   * Return the information of touch move.
   *
   * @param {Promise} promise Promise instance.
   * @param {Object} callbacks Callback function with the key to &apos;done&apos;, &apos;fail&apos;, &apos;always&apos; (each optional).
   * @return {Promise} Promise instance.
   */
  _handlecallback(promise, callbacks) {
    if (!callbacks) {
      return promise;
    }

    for (let key of Object.keys(callbacks)) {
      let callback = callbacks[key];

      if (!callback) {
        continue;
      }

      let cb = isarray(callback) ? callback : [callback];
      let rcb = null;

      switch (key) {
        case &apos;done&apos;:
          rcb = (prom, value) =&gt; prom.then(value.bind(this));
          break;
        case &apos;fail&apos;:
          rcb = (prom, value) =&gt; prom.catch(value.bind(this));
          break;
        case &apos;always&apos;:
          rcb = (prom, value) =&gt; prom.then(value.bind(this), value.bind(this));
          break;
        default:
          break;
      }

      if (rcb) {
        cb.reduce(rcb, promise);
      }
    }

    return promise;
  }
}

module.exports = Highendrawer;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
