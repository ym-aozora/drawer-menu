{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///highendrawer.min.js","webpack:///webpack/bootstrap b27beb23554d37ece08f","webpack:///./src/highendrawer.js","webpack:///./src/const.js","webpack:///./src/helper.js","webpack:///./src/util.js","webpack:///./src/support.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","default","_classCallCheck","instance","Constructor","TypeError","defineProperty","value","_typeof","Symbol","iterator","constructor","_extends","assign","target","i","arguments","length","source","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","_const","_util","_helper","helper","_support","Highendrawer","drawer","_this","state","_id","generateid","_drawer","DEFAULT_DRAWER_PROPERTY","_overlay","overlay","DEFAULT_OVERLAY_PROPERTY","_timeoutid","_intervalid","_process","DEFAULT_PROCESS","_enabled","_handler","_getdrawerhandler","enabledmaxwidth","window","addEventListener","innerWidth","destroy","create","isinitcreate","_createdrawer","_createoverlay","oncreate","apply","e","onerror","_destroydrawer","_destroyoverlay","ondestroy","duration","undefined","isfireevent","ischangehistory","_changestate","onchangestate","done","onopen","fail","_getminposition","onclose","_this2","Promise","resolve","reject","then","_this3","setstyle","element","DRAWER_STYLE","support","cssanim","TRANSITION_STYLE","_resetdrawer","keys","forEach","name","_this4","removeEventListener","unsetstyle","_this5","zindex","document","createElement","isautocreated","OVERLAY_STYLE","touchhandler","close","body","appendChild","parentNode","removeChild","isunset","_setprops","ims","_getinitdrawerstyle","zIndex","display","sizepixel","_normalizepixel","size","maxsizepixel","maxsize","_sizepixel","_position","style","direction","width","height","top","right","bottom","left","Error","position","minp","transitionDuration","transform","transrate","opacity","_getoverlaystyle","_getoverlayopacityfromposition","_getdrawerstyle","_this6","start","Date","fromopy","_getoverlayopacityfromstyle","toopy","frompos","_getdrawerpositionfromstyle","topos","clearInterval","setInterval","time","nowpos","nowopy","prp","touches","end","len","moveinfo","_gettouchmoveinfo","ish","axis","isv","ist","y","isr","x","isb","isl","_getstatefromposition","_this7","handler","resize","onresize","isswipeable","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","TOUCH_EVENTS","next","event","_touchhandler","bind","err","return","history","pushState","ishistory","popstate","ev","touch","push","type","_ontouchstart","_ontouchmove","_ontouchfinish","getTime","isfiretouchstart","istouchactive","_istouchactive","_showoverlay","_showdrawer","ontouchstart","stopPropagation","preventDefault","_getdrawerpositionfromtouches","ontouchmove","_gettouchmovestate","changestate","ontouchfinish","_this8","callbacks","_handlecallback","du","clearTimeout","back","setTimeout","_hidedrawer","_hideoverlay","rg","_getrange","swipearea","from","clientX","to","clientY","pos","Math","abs","touchbasis","touchlast","distance","_getdistance","curpos","round","_normalizenumber","posratio","parseFloat","basis","_convertpixelabs","innerHeight","nvalue","normalized","unit","String","match","Number","replace","offsetHeight","offsetWidth","promise","_this9","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","callback","cb","isarray","rcb","prom","catch","reduce","PREFIX","freeze","overflowX","overflowY","webkitOverflowScrolling","backgroundColor","transitionProperty","transitionTimingFunction","autocreate","currentid","hasstyle","styles","ss","dom","vsn","validstylename","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","pfx","namewithprefix","ucfirst","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","str","charAt","toUpperCase","substr","toString","sup","transform3d","transition"],"mappings":"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","file":"highendrawer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Highendrawer\"] = factory();\n\telse\n\t\troot[\"Highendrawer\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n * highendrawer - Highendrawer provides javascript and css drawers to your website and applications.\n * @version v0.0.1\n * @link https://github.com/ym-aozora/highendrawer#readme\n * @license MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Highendrawer\"] = factory();\n\telse\n\t\troot[\"Highendrawer\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _const = __webpack_require__(1);\n\t\n\tvar _util = __webpack_require__(3);\n\t\n\tvar _helper = __webpack_require__(2);\n\t\n\tvar helper = _interopRequireWildcard(_helper);\n\t\n\tvar _support = __webpack_require__(4);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Class providing a drawer function.\n\t *\n\t * @public\n\t * @class\n\t * @example\n\t * var drawer = new DrawerMenu({\n\t *   element: document.getElementById('drawer')\n\t * });\n\t */\n\tvar Highendrawer = function () {\n\t\n\t  /**\n\t   * Initialize object.\n\t   *\n\t   * @constructor\n\t   * @param {Drawer} drawer Initial parameters of drawer.\n\t   */\n\t  function Highendrawer(drawer) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Highendrawer);\n\t\n\t    /**\n\t     * Drawer status ('open' or 'close')\n\t     *\n\t     * @public\n\t     * @type {string}\n\t     */\n\t    this.state = 'close';\n\t\n\t    this._id = helper.generateid();\n\t    this._drawer = _extends({}, _const.DEFAULT_DRAWER_PROPERTY, drawer);\n\t    this._overlay = this._drawer.overlay === false ? false : _extends({}, _const.DEFAULT_OVERLAY_PROPERTY, this._drawer.overlay);\n\t    this._timeoutid = null;\n\t    this._intervalid = null;\n\t    this._process = _extends({}, _const.DEFAULT_PROCESS);\n\t    this._enabled = false;\n\t    this._handler = this._getdrawerhandler();\n\t\n\t    if (this._drawer.enabledmaxwidth > -1) {\n\t      window.addEventListener('resize', function () {\n\t        if (_this._enabled && window.innerWidth > _this._drawer.enabledmaxwidth) {\n\t          _this.destroy();\n\t        } else if (!_this._enabled && window.innerWidth <= _this._drawer.enabledmaxwidth) {\n\t          _this.create();\n\t        }\n\t      });\n\t    }\n\t\n\t    if (this._drawer.isinitcreate) {\n\t      this.create();\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Create the drawer set.\n\t   *\n\t   * @public\n\t   */\n\t\n\t\n\t  _createClass(Highendrawer, [{\n\t    key: 'create',\n\t    value: function create() {\n\t      try {\n\t        this._createdrawer();\n\t        this._createoverlay();\n\t        this._enabled = true;\n\t\n\t        if (this._drawer.oncreate) {\n\t          this._drawer.oncreate.apply(this, [this._drawer]);\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Destroy the drawer set.\n\t     *\n\t     * @public\n\t     */\n\t\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy() {\n\t      try {\n\t        this._destroydrawer();\n\t        this._destroyoverlay();\n\t        this._enabled = false;\n\t\n\t        if (this._drawer.ondestroy) {\n\t          this._drawer.ondestroy.apply(this, [this._drawer]);\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Open drawer.\n\t     *\n\t     * @public\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n\t     * @param {boolean} [ischangehistory=false] Make a change in history.\n\t     * @return {Promise} Promise object for open.\n\t     */\n\t\n\t  }, {\n\t    key: 'open',\n\t    value: function open() {\n\t      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t      var isfireevent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var ischangehistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t      return this._changestate(0, duration, {\n\t        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n\t        done: isfireevent ? this._drawer.onopen : null,\n\t        fail: isfireevent ? this._drawer.onerror : null\n\t      }, ischangehistory);\n\t    }\n\t\n\t    /**\n\t     * Close drawer.\n\t     *\n\t     * @public\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n\t     * @param {boolean} [ischangehistory=false] Make a change in history.\n\t     * @return {Promise} Promise object for close.\n\t     */\n\t\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t      var isfireevent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var ischangehistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t      return this._changestate(this._getminposition(), duration, {\n\t        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n\t        done: isfireevent ? this._drawer.onclose : null,\n\t        fail: isfireevent ? this._drawer.onerror : null\n\t      }, ischangehistory);\n\t    }\n\t\n\t    /**\n\t     * Toggle drawer.\n\t     *\n\t     * @public\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n\t     * @param {boolean} [ischangehistory=false] Make a change in history.\n\t     * @return {Promise} Promise object for toggle.\n\t     */\n\t\n\t  }, {\n\t    key: 'toggle',\n\t    value: function toggle() {\n\t      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\n\t      var _this2 = this;\n\t\n\t      var isfireevent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var ischangehistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          _this2[_this2.state === 'open' ? 'close' : 'open'](duration, isfireevent, ischangehistory).then(resolve, reject);\n\t        } catch (e) {\n\t          reject(e);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Create drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_createdrawer',\n\t    value: function _createdrawer() {\n\t      var _this3 = this;\n\t\n\t      helper.setstyle(this._drawer.element, _extends({}, _const.DRAWER_STYLE, _support.support.cssanim ? _const.TRANSITION_STYLE : {}));\n\t\n\t      this._resetdrawer();\n\t\n\t      Object.keys(this._handler).forEach(function (name) {\n\t        window.addEventListener(name, _this3._handler[name]);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Destroy drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_destroydrawer',\n\t    value: function _destroydrawer() {\n\t      var _this4 = this;\n\t\n\t      Object.keys(this._handler).forEach(function (name) {\n\t        window.removeEventListener(name, _this4._handler[name]);\n\t      });\n\t\n\t      this._resetdrawer(true);\n\t\n\t      helper.unsetstyle(this._drawer.element, Object.keys(_extends({}, _const.DRAWER_STYLE, _support.support.cssanim ? _const.TRANSITION_STYLE : {})));\n\t    }\n\t\n\t    /**\n\t     * Create overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_createoverlay',\n\t    value: function _createoverlay() {\n\t      var _this5 = this;\n\t\n\t      if (this._overlay === false) {\n\t        return;\n\t      }\n\t\n\t      if (this._overlay.zindex === -1) {\n\t        this._overlay.zindex = this._drawer.zindex - 1;\n\t      }\n\t\n\t      if (!this._overlay.element) {\n\t        this._overlay.element = window.document.createElement('div');\n\t        this._overlay.isautocreated = true;\n\t\n\t        helper.setstyle(this._overlay.element, _extends({}, _const.OVERLAY_STYLE, _support.support.cssanim ? _const.TRANSITION_STYLE : {}));\n\t      }\n\t\n\t      if (!this._overlay.touchhandler) {\n\t        this._overlay.touchhandler = function (e) {\n\t          _this5.close();\n\t        };\n\t      }\n\t\n\t      this._overlay.element.addEventListener('click', this._overlay.touchhandler);\n\t      window.document.body.appendChild(this._overlay.element);\n\t    }\n\t\n\t    /**\n\t     * Destroy overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_destroyoverlay',\n\t    value: function _destroyoverlay() {\n\t      if (this._overlay === false) {\n\t        return;\n\t      }\n\t\n\t      if (this._overlay.element) {\n\t        if (this._overlay.touchhandler) {\n\t          this._overlay.element.removeEventListener('click', this._overlay.touchhandler);\n\t        }\n\t\n\t        if (this._overlay.isautocreated) {\n\t          this._overlay.element.parentNode.removeChild(this._overlay.element);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Reset drawer.\n\t     *\n\t     * @param {boolean} [isunset] Unset style.\n\t     */\n\t\n\t  }, {\n\t    key: '_resetdrawer',\n\t    value: function _resetdrawer() {\n\t      var isunset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t      try {\n\t        this._setprops();\n\t\n\t        var ims = this._getinitdrawerstyle();\n\t\n\t        if (isunset) {\n\t          helper.unsetstyle(this._drawer.element, Object.keys(ims));\n\t        } else {\n\t          helper.setstyle(this._drawer.element, ims);\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Show drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_showdrawer',\n\t    value: function _showdrawer() {\n\t      helper.setstyle(this._drawer.element, {\n\t        zIndex: this._drawer.zindex\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Hide drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_hidedrawer',\n\t    value: function _hidedrawer() {\n\t      helper.setstyle(this._drawer.element, {\n\t        zIndex: -1\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Show overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_showoverlay',\n\t    value: function _showoverlay() {\n\t      helper.setstyle(this._overlay.element, {\n\t        zIndex: this._overlay.zindex,\n\t        display: 'block'\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Hide overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_hideoverlay',\n\t    value: function _hideoverlay() {\n\t      helper.setstyle(this._overlay.element, {\n\t        zIndex: -1,\n\t        display: 'none'\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Set properties.\n\t     */\n\t\n\t  }, {\n\t    key: '_setprops',\n\t    value: function _setprops() {\n\t      // set sizepixel\n\t      var sizepixel = this._normalizepixel(this._drawer.size);\n\t\n\t      var maxsizepixel = this._normalizepixel(this._drawer.maxsize);\n\t\n\t      if (sizepixel > maxsizepixel) {\n\t        sizepixel = maxsizepixel;\n\t      }\n\t\n\t      this._sizepixel = sizepixel;\n\t\n\t      // set position\n\t      this._position = typeof this._position === 'undefined' ? null : this._position;\n\t    }\n\t\n\t    /**\n\t     * Return initial style of drawer.\n\t     *\n\t     * @return {Object} Style for drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getinitdrawerstyle',\n\t    value: function _getinitdrawerstyle() {\n\t      var style = null;\n\t\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t          style = {\n\t            width: '100%',\n\t            height: this._sizepixel + 'px',\n\t            top: '-' + this._sizepixel + 'px',\n\t            right: 'auto',\n\t            bottom: 'auto',\n\t            left: 0\n\t          };\n\t          break;\n\t        case 'right':\n\t          style = {\n\t            width: this._sizepixel + 'px',\n\t            height: '100%',\n\t            top: 0,\n\t            right: '-' + this._sizepixel + 'px',\n\t            bottom: 'auto',\n\t            left: 'auto'\n\t          };\n\t          break;\n\t        case 'bottom':\n\t          style = {\n\t            width: '100%',\n\t            height: this._sizepixel + 'px',\n\t            top: 'auto',\n\t            right: 'auto',\n\t            bottom: '-' + this._sizepixel + 'px',\n\t            left: 0\n\t          };\n\t          break;\n\t        case 'left':\n\t          style = {\n\t            width: this._sizepixel + 'px',\n\t            height: '100%',\n\t            top: 0,\n\t            right: 'auto',\n\t            bottom: 'auto',\n\t            left: '-' + this._sizepixel + 'px'\n\t          };\n\t          break;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t\n\t      return _extends(style, this._drawer.style || {});\n\t    }\n\t\n\t    /**\n\t     * Return style for moving the drawer.\n\t     *\n\t     * @param {number} position Moving position.\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @return {Object} Move style for drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerstyle',\n\t    value: function _getdrawerstyle(position) {\n\t      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var minp = this._getminposition(this._drawer);\n\t      var style = {};\n\t\n\t      if (_support.support.cssanim) {\n\t        style.transitionDuration = (duration === null ? this._drawer.duration : duration) + 'ms';\n\t\n\t        switch (this._drawer.direction) {\n\t          case 'top':\n\t            style.transform = _support.support.transrate + '(0,' + -(minp - position) + 'px,0)';\n\t            break;\n\t          case 'right':\n\t            style.transform = _support.support.transrate + '(' + (minp - position) + 'px,0,0)';\n\t            break;\n\t          case 'bottom':\n\t            style.transform = _support.support.transrate + '(0,' + (minp - position) + 'px,0)';\n\t            break;\n\t          case 'left':\n\t            style.transform = _support.support.transrate + '(' + -(minp - position) + 'px,0,0)';\n\t            break;\n\t          default:\n\t            throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t        }\n\t      } else {\n\t        style[this._drawer.direction] = position + 'px';\n\t      }\n\t\n\t      return style;\n\t    }\n\t\n\t    /**\n\t     * Return style for moving the overlay.\n\t     *\n\t     * @param {float} opacity Overlay opacity.\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @return {Object} Move style for overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_getoverlaystyle',\n\t    value: function _getoverlaystyle(opacity) {\n\t      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var style = {\n\t        opacity: opacity\n\t      };\n\t\n\t      if (_support.support.cssanim) {\n\t        style.transitionDuration = (duration === null ? this._drawer.duration : duration) + 'ms';\n\t      }\n\t\n\t      return style;\n\t    }\n\t\n\t    /**\n\t     * Make animation with CSS3.\n\t     *\n\t     * @param {number} duration Drawer moving time.\n\t     */\n\t\n\t  }, {\n\t    key: '_cssanimate',\n\t    value: function _cssanimate(duration) {\n\t      helper.setstyle(this._overlay.element, this._getoverlaystyle(this._getoverlayopacityfromposition(this._position), duration));\n\t\n\t      helper.setstyle(this._drawer.element, this._getdrawerstyle(this._position, duration));\n\t    }\n\t\n\t    /**\n\t     * Make animation with Javascript.\n\t     *\n\t     * @param {number} duration Drawer moving time.\n\t     */\n\t\n\t  }, {\n\t    key: '_jsanimate',\n\t    value: function _jsanimate(duration) {\n\t      var _this6 = this;\n\t\n\t      var start = +new Date();\n\t      var fromopy = this._getoverlayopacityfromstyle();\n\t      var toopy = this._getoverlayopacityfromposition(this._position);\n\t      var frompos = this._getdrawerpositionfromstyle();\n\t      var topos = this._position;\n\t\n\t      if (this._intervalid) {\n\t        clearInterval(this._intervalid);\n\t      }\n\t\n\t      this._intervalid = setInterval(function () {\n\t        var time = new Date() - start;\n\t        var nowpos = null;\n\t        var nowopy = null;\n\t\n\t        if (time > duration) {\n\t          clearInterval(_this6._intervalid);\n\t          _this6._intervalid = null;\n\t          nowopy = toopy;\n\t          nowpos = topos;\n\t        } else {\n\t          var prp = (time /= duration) * (time - 2);\n\t          nowopy = fromopy - (toopy - fromopy) * prp;\n\t          nowpos = frompos - (topos - frompos) * prp;\n\t        }\n\t\n\t        helper.setstyle(_this6._overlay.element, _this6._getoverlaystyle(nowopy, duration));\n\t\n\t        helper.setstyle(_this6._drawer.element, _this6._getdrawerstyle(nowpos, duration));\n\t      }, 10);\n\t    }\n\t\n\t    /**\n\t     * Return state by touch movement.\n\t     *\n\t     * @param {Array} touches Touch object array.\n\t     * @param {Object} time Time information on start and end of movement.\n\t     * @return {string} State by touch movement.\n\t     */\n\t\n\t  }, {\n\t    key: '_gettouchmovestate',\n\t    value: function _gettouchmovestate(touches, time) {\n\t      if (time.end - time.start <= 300) {\n\t        var len = touches.length;\n\t\n\t        if (len >= 2) {\n\t          var moveinfo = this._gettouchmoveinfo(touches[len - 2], touches[len - 1]);\n\t          var ish = moveinfo.axis === 'horizontal';\n\t          var isv = moveinfo.axis === 'vertical';\n\t          var ist = this._drawer.direction === 'top' && moveinfo.y >= 0;\n\t          var isr = this._drawer.direction === 'right' && moveinfo.x < 0;\n\t          var isb = this._drawer.direction === 'bottom' && moveinfo.y < 0;\n\t          var isl = this._drawer.direction === 'left' && moveinfo.x >= 0;\n\t\n\t          return ish && (isr || isl) || isv && (isb || ist) ? 'open' : 'close';\n\t        }\n\t      }\n\t\n\t      return this._getstatefromposition();\n\t    }\n\t\n\t    /**\n\t     * Return drawer event handler.\n\t     *\n\t     * @return {Object} Drawer event handler.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerhandler',\n\t    value: function _getdrawerhandler() {\n\t      var _this7 = this;\n\t\n\t      var handler = {};\n\t\n\t      handler.resize = function () {\n\t        _this7._resetdrawer();\n\t        _this7[_this7.state](0, false, false);\n\t\n\t        if (_this7._drawer.onresize) {\n\t          _this7._drawer.onresize.apply(_this7, [_this7._drawer]);\n\t        }\n\t      };\n\t\n\t      if (this._drawer.isswipeable) {\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t          for (var _iterator = _const.TOUCH_EVENTS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var event = _step.value;\n\t\n\t            handler[event] = this._touchhandler.bind(this);\n\t          }\n\t        } catch (err) {\n\t          _didIteratorError = true;\n\t          _iteratorError = err;\n\t        } finally {\n\t          try {\n\t            if (!_iteratorNormalCompletion && _iterator.return) {\n\t              _iterator.return();\n\t            }\n\t          } finally {\n\t            if (_didIteratorError) {\n\t              throw _iteratorError;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      if (window.history && window.history.pushState && this._drawer.ishistory) {\n\t        handler.popstate = function (e) {\n\t          if (e.state && e.state.id === _this7._id && _this7.state === 'open') {\n\t            _this7.close(null, true, false);\n\t          }\n\t        };\n\t      }\n\t\n\t      return handler;\n\t    }\n\t\n\t    /**\n\t     * Touch event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     * @return {boolean} Event bubbling.\n\t     */\n\t\n\t  }, {\n\t    key: '_touchhandler',\n\t    value: function _touchhandler(ev) {\n\t      try {\n\t        if (ev.touches.length > 1) {\n\t          return true;\n\t        }\n\t\n\t        var touch = ev.touches[0];\n\t\n\t        if (touch) {\n\t          this._process.touches.push(touch);\n\t        }\n\t\n\t        switch (ev.type) {\n\t          case 'touchstart':\n\t            this._ontouchstart(ev);\n\t            break;\n\t          case 'touchmove':\n\t            this._ontouchmove(ev);\n\t            break;\n\t          case 'touchcancel':\n\t          case 'touchend':\n\t            this._ontouchfinish(ev);\n\t            break;\n\t          default:\n\t            break;\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * Touch start event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     */\n\t\n\t  }, {\n\t    key: '_ontouchstart',\n\t    value: function _ontouchstart(ev) {\n\t      this._process.time.start = new Date().getTime();\n\t    }\n\t\n\t    /**\n\t     * Touch move event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     */\n\t\n\t  }, {\n\t    key: '_ontouchmove',\n\t    value: function _ontouchmove(ev) {\n\t      var len = this._process.touches.length;\n\t      var isfiretouchstart = false;\n\t\n\t      if (!this._process.istouchactive && len >= 2) {\n\t        this._process.istouchactive = this._istouchactive(this._process.touches[0]);\n\t\n\t        if (this._process.istouchactive) {\n\t          this._showoverlay();\n\t          this._showdrawer();\n\t\n\t          if (this._drawer.ontouchstart) {\n\t            isfiretouchstart = true;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (this._process.istouchactive) {\n\t        ev.stopPropagation();\n\t        ev.preventDefault();\n\t\n\t        this._position = this._getdrawerpositionfromtouches(this._process.touches[len - 2], this._process.touches[len - 1]);\n\t\n\t        if (isfiretouchstart) {\n\t          this._drawer.ontouchstart.apply(this, [this._drawer, this._position]);\n\t        }\n\t\n\t        helper.setstyle(this._overlay.element, this._getoverlaystyle(this._getoverlayopacityfromposition(this._position), 0));\n\t\n\t        helper.setstyle(this._drawer.element, this._getdrawerstyle(this._position, 0));\n\t\n\t        if (this._drawer.ontouchmove) {\n\t          this._drawer.ontouchmove.apply(this, [this._drawer, this._position]);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Touch finish event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     */\n\t\n\t  }, {\n\t    key: '_ontouchfinish',\n\t    value: function _ontouchfinish(ev) {\n\t      var len = this._process.touches.length;\n\t\n\t      if (this._process.istouchactive && len >= 2) {\n\t        this._process.time.end = new Date().getTime();\n\t\n\t        var state = this._gettouchmovestate(this._process.touches, this._process.time);\n\t\n\t        var changestate = this.state !== state;\n\t\n\t        this[state](null, changestate, changestate);\n\t\n\t        if (this._drawer.ontouchfinish) {\n\t          this._drawer.ontouchfinish.apply(this, [this._drawer, this._getdrawerpositionfromtouches(this._process.touches[len - 2], this._process.touches[len - 1])]);\n\t        }\n\t      }\n\t\n\t      this._process.touches = [];\n\t      this._process.istouchactive = false;\n\t      this._process.time.start = 0;\n\t      this._process.time.end = 0;\n\t    }\n\t\n\t    /**\n\t     * Return whether or not a valid touch.\n\t     *\n\t     * @param {number} position Moving position.\n\t     * @param {number} [duration=null] Drawer moving time.\n\t     * @param {Object} [callbacks=null] Callback objects.\n\t     * @param {boolean} [ischangehistory=false] Make a change in history.\n\t     * @return {Promise} Promise object.\n\t     */\n\t\n\t  }, {\n\t    key: '_changestate',\n\t    value: function _changestate(position) {\n\t      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var _this8 = this;\n\t\n\t      var callbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t      var ischangehistory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\t\n\t      return this._handlecallback(new Promise(function (resolve, reject) {\n\t        try {\n\t          (function () {\n\t            _this8._position = position;\n\t\n\t            var du = duration === null ? _this8._drawer.duration : duration;\n\t\n\t            if (_this8._timeoutid !== null) {\n\t              clearTimeout(_this8._timeoutid);\n\t              _this8._timeoutid = null;\n\t            }\n\t\n\t            var state = _this8._getstatefromposition();\n\t\n\t            if (state === 'open') {\n\t              _this8._showoverlay();\n\t              _this8._showdrawer();\n\t            }\n\t\n\t            if (ischangehistory && _this8._drawer.ishistory && window.history && window.history.pushState) {\n\t              if (state === 'open') {\n\t                window.history.pushState({\n\t                  id: _this8._id\n\t                }, null, null);\n\t              } else {\n\t                window.history.back();\n\t              }\n\t            }\n\t\n\t            _this8[_support.support.cssanim ? '_cssanimate' : '_jsanimate'](du);\n\t\n\t            _this8._timeoutid = setTimeout(function () {\n\t              if (state === 'close') {\n\t                _this8._hidedrawer();\n\t                _this8._hideoverlay();\n\t              }\n\t\n\t              _this8._timeoutid = null;\n\t            }, du);\n\t\n\t            _this8.state = state;\n\t\n\t            if ((typeof callbacks === 'undefined' ? 'undefined' : _typeof(callbacks)) === 'object' && callbacks.onchangestate) {\n\t              callbacks.onchangestate.apply(_this8, [_this8._drawer, state]);\n\t            }\n\t\n\t            resolve.apply(_this8, [_this8._drawer]);\n\t          })();\n\t        } catch (e) {\n\t          reject(e);\n\t        }\n\t      }), {\n\t        done: (typeof callbacks === 'undefined' ? 'undefined' : _typeof(callbacks)) === 'object' && callbacks.done ? callbacks.done : null,\n\t        fail: (typeof callbacks === 'undefined' ? 'undefined' : _typeof(callbacks)) === 'object' && callbacks.fail ? callbacks.fail : null\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Return whether or not a valid touch.\n\t     *\n\t     * @param {Object} touch Start touch information.\n\t     * @return {boolean} Result of valid touch.\n\t     */\n\t\n\t  }, {\n\t    key: '_istouchactive',\n\t    value: function _istouchactive(touch) {\n\t      var rg = this._getrange(this.state === 'open' ? '100%' : this._drawer.swipearea);\n\t\n\t      return rg.from.x <= touch.clientX && touch.clientX <= rg.to.x && rg.from.y <= touch.clientY && touch.clientY <= rg.to.y;\n\t    }\n\t\n\t    /**\n\t     * Return the state of the drawer.\n\t     *\n\t     * @return {string} State of the drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getstatefromposition',\n\t    value: function _getstatefromposition() {\n\t      var pos = this._position === null ? this._getdrawerpositionfromstyle() : this._position;\n\t\n\t      return Math.abs(pos) < this._sizepixel / 2 ? 'open' : 'close';\n\t    }\n\t\n\t    /**\n\t     * Return the position of the drawer.\n\t     *\n\t     * @param {Object} touchbasis Basic touch information.\n\t     * @param {Object} touchlast Last touch information.\n\t     * @return {number} Position of the drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerpositionfromtouches',\n\t    value: function _getdrawerpositionfromtouches(touchbasis, touchlast) {\n\t      var distance = this._getdistance(this._gettouchmoveinfo(touchbasis, touchlast));\n\t\n\t      var curpos = this._position === null ? this._getdrawerpositionfromstyle() : this._position;\n\t\n\t      var pos = Math.round(curpos + distance);\n\t      var minp = this._getminposition(this._drawer);\n\t\n\t      if (pos > 0) {\n\t        pos = 0;\n\t      } else if (pos < minp) {\n\t        pos = minp;\n\t      }\n\t\n\t      return pos;\n\t    }\n\t\n\t    /**\n\t     * Return the position in the style.\n\t     *\n\t     * @return {number} Position in the style.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerpositionfromstyle',\n\t    value: function _getdrawerpositionfromstyle() {\n\t      var value = this._drawer.element.style[this._drawer.direction];\n\t      return this._normalizenumber(value).value;\n\t    }\n\t\n\t    /**\n\t     * Return the opacity of the overlay.\n\t     *\n\t     * @param {number} position Moving position.\n\t     * @return {number} Position of the drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getoverlayopacityfromposition',\n\t    value: function _getoverlayopacityfromposition(position) {\n\t      var minp = this._getminposition(this._drawer);\n\t      var posratio = 1 - Math.abs(position) / Math.abs(minp);\n\t      return this._overlay.opacity * posratio * 10000 / 10000;\n\t    }\n\t\n\t    /**\n\t     * Return the opacity in the style.\n\t     *\n\t     * @return {number} Opacity in the style.\n\t     */\n\t\n\t  }, {\n\t    key: '_getoverlayopacityfromstyle',\n\t    value: function _getoverlayopacityfromstyle() {\n\t      return parseFloat(this._overlay.element.style.opacity);\n\t    }\n\t\n\t    /**\n\t     * Return the swipe range.\n\t     *\n\t     * @param {string|number} value Target swipe area value.\n\t     * @return {Object} Drag range.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_getrange',\n\t    value: function _getrange(value) {\n\t      var basis = this._convertpixelabs(value);\n\t      var width = window.innerWidth;\n\t      var height = window.innerHeight;\n\t\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t          return { from: { x: 0, y: 0 }, to: { x: width, y: basis } };\n\t        case 'right':\n\t          return { from: { x: basis, y: 0 }, to: { x: width, y: height } };\n\t        case 'bottom':\n\t          return { from: { x: 0, y: basis }, to: { x: width, y: height } };\n\t        case 'left':\n\t          return { from: { x: 0, y: 0 }, to: { x: basis, y: height } };\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return a value converted to the absolute value of the pixel.\n\t     *\n\t     * @param {string|number} value Target value.\n\t     * @return {number} Converted to the absolute value of the pixel.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_convertpixelabs',\n\t    value: function _convertpixelabs(value) {\n\t      var nvalue = this._normalizepixel(value);\n\t\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t        case 'left':\n\t          return nvalue;\n\t        case 'right':\n\t          return window.innerWidth - nvalue;\n\t        case 'bottom':\n\t          return window.innerHeight - nvalue;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the normalized pixel value.\n\t     *\n\t     * @param {string|number} value Target value.\n\t     * @return {number} Normalized pixel value.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_normalizepixel',\n\t    value: function _normalizepixel(value) {\n\t      var normalized = this._normalizenumber(value);\n\t\n\t      if (normalized.unit === 'number' || normalized.unit === 'pixel') {\n\t        return normalized.value;\n\t      } else if (normalized.unit === 'percent') {\n\t        switch (this._drawer.direction) {\n\t          case 'top':\n\t          case 'bottom':\n\t            return window.innerHeight * (normalized.value / 100);\n\t          case 'right':\n\t          case 'left':\n\t            return window.innerWidth * (normalized.value / 100);\n\t          default:\n\t            throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the numeric normalized information.\n\t     *\n\t     * @param {string|number} value Target value.\n\t     * @return {Object} Numeric normalized information.\n\t     * @throws {Error} Is thrown if value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_normalizenumber',\n\t    value: function _normalizenumber(value) {\n\t      if (typeof value === 'number') {\n\t        return { value: value, unit: 'number' };\n\t      } else if (String(value).match(/^[.\\-0-9]+$/)) {\n\t        return { value: Number(value), unit: 'number' };\n\t      } else if (value.match(/^[.\\-0-9]+px$/)) {\n\t        return { value: Number(value.replace(/px$/ig, '')), unit: 'pixel' };\n\t      } else if (value.match(/[.\\-0-9]+%$/)) {\n\t        return { value: Number(value.replace(/%$/ig, '')), unit: 'percent' };\n\t      }\n\t\n\t      throw new Error('\\'' + value + '\\' does not support');\n\t    }\n\t\n\t    /**\n\t     * Return to the minimum position for the drawer.\n\t     *\n\t     * @return {number} Minimum position for the drawer.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_getminposition',\n\t    value: function _getminposition() {\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t        case 'bottom':\n\t          return -1 * this._drawer.element.offsetHeight;\n\t        case 'right':\n\t        case 'left':\n\t          return -1 * this._drawer.element.offsetWidth;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the distance of the drawer.\n\t     *\n\t     * @param {Object} moveinfo Movement information of the drawer.\n\t     * @return {number} Distance of the drawer.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdistance',\n\t    value: function _getdistance(moveinfo) {\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t          return moveinfo.y;\n\t        case 'right':\n\t          return -1 * moveinfo.x;\n\t        case 'bottom':\n\t          return -1 * moveinfo.y;\n\t        case 'left':\n\t          return moveinfo.x;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the information of touch move.\n\t     *\n\t     * @param {Object} touchbasis Basic touch information.\n\t     * @param {Object} touchlast Last touch information.\n\t     * @return {Object} Movement distance of the x, y direction, movement direction.\n\t     */\n\t\n\t  }, {\n\t    key: '_gettouchmoveinfo',\n\t    value: function _gettouchmoveinfo(touchbasis, touchlast) {\n\t      var x = touchlast.clientX - touchbasis.clientX;\n\t      var y = touchlast.clientY - touchbasis.clientY;\n\t      var axis = Math.abs(x) >= Math.abs(y) ? 'horizontal' : 'vertical';\n\t\n\t      return { x: x, y: y, axis: axis };\n\t    }\n\t\n\t    /**\n\t     * Return the information of touch move.\n\t     *\n\t     * @param {Promise} promise Promise instance.\n\t     * @param {Object} callbacks Callback function with the key to 'done', 'fail', 'always' (each optional).\n\t     * @return {Promise} Promise instance.\n\t     */\n\t\n\t  }, {\n\t    key: '_handlecallback',\n\t    value: function _handlecallback(promise, callbacks) {\n\t      var _this9 = this;\n\t\n\t      if (!callbacks) {\n\t        return promise;\n\t      }\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = Object.keys(callbacks)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var key = _step2.value;\n\t\n\t          var callback = callbacks[key];\n\t\n\t          if (!callback) {\n\t            continue;\n\t          }\n\t\n\t          var cb = (0, _util.isarray)(callback) ? callback : [callback];\n\t          var rcb = null;\n\t\n\t          switch (key) {\n\t            case 'done':\n\t              rcb = function rcb(prom, value) {\n\t                return prom.then(value.bind(_this9));\n\t              };\n\t              break;\n\t            case 'fail':\n\t              rcb = function rcb(prom, value) {\n\t                return prom.catch(value.bind(_this9));\n\t              };\n\t              break;\n\t            case 'always':\n\t              rcb = function rcb(prom, value) {\n\t                return prom.then(value.bind(_this9), value.bind(_this9));\n\t              };\n\t              break;\n\t            default:\n\t              break;\n\t          }\n\t\n\t          if (rcb) {\n\t            cb.reduce(rcb, promise);\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      return promise;\n\t    }\n\t  }]);\n\t\n\t  return Highendrawer;\n\t}();\n\t\n\texports.default = Highendrawer;\n\t\n\t\n\tmodule.exports = Highendrawer;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Vendor prefix list.\n\t *\n\t * @type {string[]}\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar PREFIX = exports.PREFIX = ['webkit', 'moz', 'o', 'ms'];\n\t\n\t/**\n\t * Drawer's default css style.\n\t *\n\t * @type {Object}\n\t */\n\tvar DRAWER_STYLE = exports.DRAWER_STYLE = Object.freeze({\n\t  display: 'block',\n\t  position: 'fixed',\n\t  overflowX: 'hidden',\n\t  overflowY: 'auto',\n\t  zIndex: -1,\n\t  webkitOverflowScrolling: 'touch'\n\t});\n\t\n\t/**\n\t * Overlay's default css style.\n\t *\n\t * @type {Object}\n\t */\n\tvar OVERLAY_STYLE = exports.OVERLAY_STYLE = Object.freeze({\n\t  display: 'none',\n\t  backgroundColor: '#000',\n\t  position: 'fixed',\n\t  top: 0,\n\t  right: 0,\n\t  bottom: 0,\n\t  left: 0,\n\t  zIndex: -1,\n\t  opacity: 0\n\t});\n\t\n\t/**\n\t * Css transition style.\n\t *\n\t * @type {Object}\n\t */\n\tvar TRANSITION_STYLE = exports.TRANSITION_STYLE = Object.freeze({\n\t  transform: '',\n\t  transitionProperty: 'transform,opacity',\n\t  transitionTimingFunction: 'cubic-bezier(0,0,0.25,1)',\n\t  transitionDuration: '0ms'\n\t});\n\t\n\t/**\n\t * Default drawer property.\n\t *\n\t * @type {Drawer}\n\t */\n\tvar DEFAULT_DRAWER_PROPERTY = exports.DEFAULT_DRAWER_PROPERTY = Object.freeze({\n\t  element: null,\n\t  direction: 'right',\n\t  size: '80%',\n\t  maxsize: 256,\n\t  isswipeable: true,\n\t  swipearea: '8%',\n\t  duration: 300,\n\t  zindex: 9999,\n\t  style: {},\n\t  isinitcreate: true,\n\t  enabledmaxwidth: -1,\n\t  ishistory: true,\n\t  overlay: null,\n\t  oncreate: null,\n\t  ondestroy: null,\n\t  onopen: null,\n\t  onclose: null,\n\t  onchangestate: null,\n\t  onresize: null,\n\t  ontouchstart: null,\n\t  ontouchmove: null,\n\t  ontouchfinish: null,\n\t  onerror: null\n\t});\n\t\n\t/**\n\t * Default overlay property.\n\t *\n\t * @type {Overlay}\n\t */\n\tvar DEFAULT_OVERLAY_PROPERTY = exports.DEFAULT_OVERLAY_PROPERTY = Object.freeze({\n\t  element: null,\n\t  opacity: 0.2,\n\t  zindex: -1,\n\t  autocreate: false\n\t});\n\t\n\t/**\n\t * Default processing state object.\n\t *\n\t * @type {Object}\n\t */\n\tvar DEFAULT_PROCESS = exports.DEFAULT_PROCESS = Object.freeze({\n\t  touches: [],\n\t  istouchactive: false,\n\t  time: {\n\t    start: 0,\n\t    end: 0\n\t  }\n\t});\n\t\n\t/**\n\t * Touch event list.\n\t *\n\t * @type {string[]}\n\t */\n\tvar TOUCH_EVENTS = exports.TOUCH_EVENTS = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.generateid = generateid;\n\texports.hasstyle = hasstyle;\n\texports.setstyle = setstyle;\n\texports.unsetstyle = unsetstyle;\n\t\n\tvar _const = __webpack_require__(1);\n\t\n\tvar _util = __webpack_require__(3);\n\t\n\tvar dom = window.document.createElement('div');\n\t\n\tvar currentid = 0;\n\tvar validstylename = {};\n\t\n\t/**\n\t * Generate ID.\n\t *\n\t * @return {number} ID.\n\t */\n\tfunction generateid() {\n\t  return ++currentid;\n\t}\n\t\n\t/**\n\t * Verify that the style is present.\n\t *\n\t * @param {string[]|string} styles Css styles.\n\t * @return {boolean} Result of verification.\n\t */\n\tfunction hasstyle(styles) {\n\t  var ss = styles;\n\t\n\t  if (!(0, _util.isarray)(styles)) {\n\t    ss = [styles];\n\t  }\n\t\n\t  var _iteratorNormalCompletion = true;\n\t  var _didIteratorError = false;\n\t  var _iteratorError = undefined;\n\t\n\t  try {\n\t    for (var _iterator = ss[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t      var style = _step.value;\n\t\n\t      if (typeof dom.style[style] !== 'undefined') {\n\t        return true;\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError = true;\n\t    _iteratorError = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion && _iterator.return) {\n\t        _iterator.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError) {\n\t        throw _iteratorError;\n\t      }\n\t    }\n\t  }\n\t\n\t  return false;\n\t}\n\t\n\t/**\n\t * Set the CSS style to element.\n\t *\n\t * @param {Object} element Target element object.\n\t * @param {Object} style Css style.\n\t */\n\tfunction setstyle(element, style) {\n\t  var _iteratorNormalCompletion2 = true;\n\t  var _didIteratorError2 = false;\n\t  var _iteratorError2 = undefined;\n\t\n\t  try {\n\t    for (var _iterator2 = Object.keys(style)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t      var name = _step2.value;\n\t\n\t      var vsn = validstylename[name];\n\t\n\t      if (vsn) {\n\t        element.style[vsn] = style[name];\n\t      } else if (typeof element.style[name] === 'undefined') {\n\t        for (var i = 0; i < 2; i++) {\n\t          var _iteratorNormalCompletion3 = true;\n\t          var _didIteratorError3 = false;\n\t          var _iteratorError3 = undefined;\n\t\n\t          try {\n\t            for (var _iterator3 = _const.PREFIX[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t              var pfx = _step3.value;\n\t\n\t              var namewithprefix = (i === 0 ? pfx : (0, _util.ucfirst)(pfx)) + (0, _util.ucfirst)(name);\n\t\n\t              if (typeof element.style[namewithprefix] !== 'undefined') {\n\t                validstylename[name] = namewithprefix;\n\t                element.style[namewithprefix] = style[name];\n\t                break;\n\t              }\n\t            }\n\t          } catch (err) {\n\t            _didIteratorError3 = true;\n\t            _iteratorError3 = err;\n\t          } finally {\n\t            try {\n\t              if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                _iterator3.return();\n\t              }\n\t            } finally {\n\t              if (_didIteratorError3) {\n\t                throw _iteratorError3;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        validstylename[name] = name;\n\t        element.style[name] = style[name];\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError2 = true;\n\t    _iteratorError2 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t        _iterator2.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError2) {\n\t        throw _iteratorError2;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Unset the CSS style to element.\n\t *\n\t * @param {Object} element Target element object.\n\t * @param {string[]|string} styles Css styles.\n\t */\n\tfunction unsetstyle(element, styles) {\n\t  var style = {};\n\t\n\t  var _iteratorNormalCompletion4 = true;\n\t  var _didIteratorError4 = false;\n\t  var _iteratorError4 = undefined;\n\t\n\t  try {\n\t    for (var _iterator4 = ((0, _util.isarray)(styles) ? styles : [styles])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t      var name = _step4.value;\n\t\n\t      style[name] = '';\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError4 = true;\n\t    _iteratorError4 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t        _iterator4.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError4) {\n\t        throw _iteratorError4;\n\t      }\n\t    }\n\t  }\n\t\n\t  setstyle(element, style);\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Convert the first letter to uppercase.\n\t *\n\t * @param {string} str Target character string.\n\t * @return {string} Converted string.\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.ucfirst = ucfirst;\n\texports.isarray = isarray;\n\tfunction ucfirst(str) {\n\t  return str.charAt(0).toUpperCase() + str.substr(1);\n\t}\n\t\n\t/**\n\t * Whether or not the object is an array.\n\t *\n\t * @param {any} obj Target object.\n\t * @return {boolean} Returns true if object is an Array.\n\t */\n\tfunction isarray(obj) {\n\t  return Object.prototype.toString.call(obj) === '[object Array]';\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.support = undefined;\n\t\n\tvar _helper = __webpack_require__(2);\n\t\n\t/**\n\t * Browser support information.\n\t *\n\t * @type {Object}\n\t */\n\tvar sup = {};\n\t\n\tsup.transform3d = (0, _helper.hasstyle)(['perspectiveProperty', 'webkitPerspective', 'mozPerspective', 'oPerspective', 'msPerspective']);\n\t\n\tsup.transform = (0, _helper.hasstyle)(['transformProperty', 'webkitTransform', 'mozTransform', 'oTransform', 'msTransform']);\n\t\n\tsup.transition = (0, _helper.hasstyle)(['transitionProperty', 'webkitTransitionProperty', 'mozTransitionProperty', 'oTransitionProperty', 'msTransitionProperty']);\n\t\n\tsup.cssanim = (sup.transform3d || sup.transform) && sup.transition;\n\t\n\tsup.transrate = sup.transform3d ? 'translate3d' : 'translate';\n\t\n\t/**\n\t * Browser support information.\n\t *\n\t * @type {Object}\n\t */\n\tvar support = exports.support = Object.freeze(sup);\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// highendrawer.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b27beb23554d37ece08f","'use strict';\n\nimport {\n  DEFAULT_DRAWER_PROPERTY,\n  DEFAULT_OVERLAY_PROPERTY,\n  DEFAULT_PROCESS,\n  DRAWER_STYLE,\n  OVERLAY_STYLE,\n  TOUCH_EVENTS,\n  TRANSITION_STYLE,\n} from './const';\n\nimport {isarray} from './util';\nimport * as helper from './helper';\nimport {support} from './support';\n\n/**\n * Class providing a drawer function.\n *\n * @public\n * @class\n * @example\n * var drawer = new DrawerMenu({\n *   element: document.getElementById('drawer')\n * });\n */\nexport default class Highendrawer {\n\n  /**\n   * Initialize object.\n   *\n   * @constructor\n   * @param {Drawer} drawer Initial parameters of drawer.\n   */\n  constructor(drawer) {\n    /**\n     * Drawer status ('open' or 'close')\n     *\n     * @public\n     * @type {string}\n     */\n    this.state = 'close';\n\n    this._id = helper.generateid();\n    this._drawer = Object.assign({}, DEFAULT_DRAWER_PROPERTY, drawer);\n    this._overlay = this._drawer.overlay === false ?\n      false :\n      Object.assign({}, DEFAULT_OVERLAY_PROPERTY, this._drawer.overlay);\n    this._timeoutid = null;\n    this._intervalid = null;\n    this._process = Object.assign({}, DEFAULT_PROCESS);\n    this._enabled = false;\n    this._handler = this._getdrawerhandler();\n\n    if (this._drawer.enabledmaxwidth > -1) {\n      window.addEventListener('resize', () => {\n        if (this._enabled\n          && window.innerWidth > this._drawer.enabledmaxwidth) {\n          this.destroy();\n        } else if (!this._enabled\n          && window.innerWidth <= this._drawer.enabledmaxwidth) {\n          this.create();\n        }\n      });\n    }\n\n    if (this._drawer.isinitcreate) {\n      this.create();\n    }\n  }\n\n  /**\n   * Create the drawer set.\n   *\n   * @public\n   */\n  create() {\n    try {\n      this._createdrawer();\n      this._createoverlay();\n      this._enabled = true;\n\n      if (this._drawer.oncreate) {\n        this._drawer.oncreate.apply(this, [this._drawer]);\n      }\n    } catch (e) {\n      if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Destroy the drawer set.\n   *\n   * @public\n   */\n  destroy() {\n    try {\n      this._destroydrawer();\n      this._destroyoverlay();\n      this._enabled = false;\n\n      if (this._drawer.ondestroy) {\n        this._drawer.ondestroy.apply(this, [this._drawer]);\n      }\n    } catch (e) {\n      if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Open drawer.\n   *\n   * @public\n   * @param {number} [duration] Drawer moving time.\n   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n   * @param {boolean} [ischangehistory=false] Make a change in history.\n   * @return {Promise} Promise object for open.\n   */\n  open(duration = null, isfireevent = true, ischangehistory = true) {\n    return this._changestate(\n      0,\n      duration,\n      {\n        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n        done: isfireevent ? this._drawer.onopen : null,\n        fail: isfireevent ? this._drawer.onerror : null,\n      },\n      ischangehistory\n    );\n  }\n\n  /**\n   * Close drawer.\n   *\n   * @public\n   * @param {number} [duration] Drawer moving time.\n   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n   * @param {boolean} [ischangehistory=false] Make a change in history.\n   * @return {Promise} Promise object for close.\n   */\n  close(duration = null, isfireevent = true, ischangehistory = true) {\n    return this._changestate(\n      this._getminposition(),\n      duration,\n      {\n        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n        done: isfireevent ? this._drawer.onclose : null,\n        fail: isfireevent ? this._drawer.onerror : null,\n      },\n      ischangehistory\n    );\n  }\n\n  /**\n   * Toggle drawer.\n   *\n   * @public\n   * @param {number} [duration] Drawer moving time.\n   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n   * @param {boolean} [ischangehistory=false] Make a change in history.\n   * @return {Promise} Promise object for toggle.\n   */\n  toggle(duration = null, isfireevent = true, ischangehistory = true) {\n    return new Promise((resolve, reject) => {\n      try {\n        this[this.state === 'open' ? 'close' : 'open'](duration, isfireevent, ischangehistory)\n          .then(resolve, reject);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  /**\n   * Create drawer.\n   */\n  _createdrawer() {\n    helper.setstyle(\n      this._drawer.element,\n      Object.assign(\n        {},\n        DRAWER_STYLE,\n        support.cssanim ? TRANSITION_STYLE : {}\n      )\n    );\n\n    this._resetdrawer();\n\n    Object.keys(this._handler).forEach((name) => {\n      window.addEventListener(name, this._handler[name]);\n    });\n  }\n\n  /**\n   * Destroy drawer.\n   */\n  _destroydrawer() {\n    Object.keys(this._handler).forEach((name) => {\n      window.removeEventListener(name, this._handler[name]);\n    });\n\n    this._resetdrawer(true);\n\n    helper.unsetstyle(\n      this._drawer.element,\n      Object.keys(\n        Object.assign(\n          {},\n          DRAWER_STYLE,\n          support.cssanim ? TRANSITION_STYLE : {}\n        )\n      )\n    );\n  }\n\n  /**\n   * Create overlay.\n   */\n  _createoverlay() {\n    if (this._overlay === false) {\n      return;\n    }\n\n    if (this._overlay.zindex === -1) {\n      this._overlay.zindex = this._drawer.zindex - 1;\n    }\n\n    if (!this._overlay.element) {\n      this._overlay.element = window.document.createElement('div');\n      this._overlay.isautocreated = true;\n\n      helper.setstyle(\n        this._overlay.element,\n        Object.assign(\n          {},\n          OVERLAY_STYLE,\n          support.cssanim ? TRANSITION_STYLE : {}\n        )\n      );\n    }\n\n    if (!this._overlay.touchhandler) {\n      this._overlay.touchhandler = (e) => {\n        this.close();\n      };\n    }\n\n    this._overlay.element.addEventListener('click', this._overlay.touchhandler);\n    window.document.body.appendChild(this._overlay.element);\n  }\n\n  /**\n   * Destroy overlay.\n   */\n  _destroyoverlay() {\n    if (this._overlay === false) {\n      return;\n    }\n\n    if (this._overlay.element) {\n      if (this._overlay.touchhandler) {\n        this._overlay.element.removeEventListener('click', this._overlay.touchhandler);\n      }\n\n      if (this._overlay.isautocreated) {\n        this._overlay.element.parentNode.removeChild(this._overlay.element);\n      }\n    }\n  }\n\n  /**\n   * Reset drawer.\n   *\n   * @param {boolean} [isunset] Unset style.\n   */\n  _resetdrawer(isunset = false) {\n    try {\n      this._setprops();\n\n      let ims = this._getinitdrawerstyle();\n\n      if (isunset) {\n        helper.unsetstyle(this._drawer.element, Object.keys(ims));\n      } else {\n        helper.setstyle(this._drawer.element, ims);\n      }\n    } catch (e) {\n      if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Show drawer.\n   */\n  _showdrawer() {\n    helper.setstyle(this._drawer.element, {\n      zIndex: this._drawer.zindex,\n    });\n  }\n\n  /**\n   * Hide drawer.\n   */\n  _hidedrawer() {\n    helper.setstyle(this._drawer.element, {\n      zIndex: -1,\n    });\n  }\n\n  /**\n   * Show overlay.\n   */\n  _showoverlay() {\n    helper.setstyle(this._overlay.element, {\n      zIndex: this._overlay.zindex,\n      display: 'block',\n    });\n  }\n\n  /**\n   * Hide overlay.\n   */\n  _hideoverlay() {\n    helper.setstyle(this._overlay.element, {\n      zIndex: -1,\n      display: 'none',\n    });\n  }\n\n  /**\n   * Set properties.\n   */\n  _setprops() {\n    // set sizepixel\n    let sizepixel = this._normalizepixel(\n      this._drawer.size\n    );\n\n    let maxsizepixel = this._normalizepixel(\n      this._drawer.maxsize\n    );\n\n    if (sizepixel > maxsizepixel) {\n      sizepixel = maxsizepixel;\n    }\n\n    this._sizepixel = sizepixel;\n\n    // set position\n    this._position = typeof this._position === 'undefined' ?\n      null :\n      this._position;\n  }\n\n  /**\n   * Return initial style of drawer.\n   *\n   * @return {Object} Style for drawer.\n   */\n  _getinitdrawerstyle() {\n    let style = null;\n\n    switch (this._drawer.direction) {\n      case 'top':\n        style = {\n          width: '100%',\n          height: `${this._sizepixel}px`,\n          top: `-${this._sizepixel}px`,\n          right: 'auto',\n          bottom: 'auto',\n          left: 0,\n        };\n        break;\n      case 'right':\n        style = {\n          width: `${this._sizepixel}px`,\n          height: '100%',\n          top: 0,\n          right: `-${this._sizepixel}px`,\n          bottom: 'auto',\n          left: 'auto',\n        };\n        break;\n      case 'bottom':\n        style = {\n          width: '100%',\n          height: `${this._sizepixel}px`,\n          top: 'auto',\n          right: 'auto',\n          bottom: `-${this._sizepixel}px`,\n          left: 0,\n        };\n        break;\n      case 'left':\n        style = {\n          width: `${this._sizepixel}px`,\n          height: '100%',\n          top: 0,\n          right: 'auto',\n          bottom: 'auto',\n          left: `-${this._sizepixel}px`,\n        };\n        break;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n\n    return Object.assign(style, this._drawer.style || {});\n  }\n\n  /**\n   * Return style for moving the drawer.\n   *\n   * @param {number} position Moving position.\n   * @param {number} [duration] Drawer moving time.\n   * @return {Object} Move style for drawer.\n   */\n  _getdrawerstyle(position, duration = null) {\n    let minp = this._getminposition(this._drawer);\n    let style = {};\n\n    if (support.cssanim) {\n      style.transitionDuration = `${duration === null ? this._drawer.duration : duration}ms`;\n\n      switch (this._drawer.direction) {\n        case 'top':\n          style.transform = `${support.transrate}(0,${-(minp - position)}px,0)`;\n          break;\n        case 'right':\n          style.transform = `${support.transrate}(${minp - position}px,0,0)`;\n          break;\n        case 'bottom':\n          style.transform = `${support.transrate}(0,${minp - position}px,0)`;\n          break;\n        case 'left':\n          style.transform = `${support.transrate}(${-(minp - position)}px,0,0)`;\n          break;\n        default:\n          throw new Error(`'${this._drawer.direction}' does not support`);\n      }\n    } else {\n      style[this._drawer.direction] = `${position}px`;\n    }\n\n    return style;\n  }\n\n  /**\n   * Return style for moving the overlay.\n   *\n   * @param {float} opacity Overlay opacity.\n   * @param {number} [duration] Drawer moving time.\n   * @return {Object} Move style for overlay.\n   */\n  _getoverlaystyle(opacity, duration = null) {\n    let style = {\n      opacity,\n    };\n\n    if (support.cssanim) {\n      style.transitionDuration = `${duration === null ? this._drawer.duration : duration}ms`;\n    }\n\n    return style;\n  }\n\n  /**\n   * Make animation with CSS3.\n   *\n   * @param {number} duration Drawer moving time.\n   */\n  _cssanimate(duration) {\n    helper.setstyle(\n      this._overlay.element,\n      this._getoverlaystyle(\n        this._getoverlayopacityfromposition(this._position),\n        duration\n      )\n    );\n\n    helper.setstyle(\n      this._drawer.element,\n      this._getdrawerstyle(this._position, duration)\n    );\n  }\n\n  /**\n   * Make animation with Javascript.\n   *\n   * @param {number} duration Drawer moving time.\n   */\n  _jsanimate(duration) {\n    let start = +new Date();\n    let fromopy = this._getoverlayopacityfromstyle();\n    let toopy = this._getoverlayopacityfromposition(this._position);\n    let frompos = this._getdrawerpositionfromstyle();\n    let topos = this._position;\n\n    if (this._intervalid) {\n      clearInterval(this._intervalid);\n    }\n\n    this._intervalid = setInterval(() => {\n      let time = new Date() - start;\n      let nowpos = null;\n      let nowopy = null;\n\n      if (time > duration) {\n        clearInterval(this._intervalid);\n        this._intervalid = null;\n        nowopy = toopy;\n        nowpos = topos;\n      } else {\n        let prp = (time /= duration) * (time - 2);\n        nowopy = fromopy - ((toopy - fromopy) * prp);\n        nowpos = frompos - ((topos - frompos) * prp);\n      }\n\n      helper.setstyle(\n        this._overlay.element,\n        this._getoverlaystyle(nowopy, duration)\n      );\n\n      helper.setstyle(\n        this._drawer.element,\n        this._getdrawerstyle(nowpos, duration)\n      );\n    }, 10);\n  }\n\n  /**\n   * Return state by touch movement.\n   *\n   * @param {Array} touches Touch object array.\n   * @param {Object} time Time information on start and end of movement.\n   * @return {string} State by touch movement.\n   */\n  _gettouchmovestate(touches, time) {\n    if (time.end - time.start <= 300) {\n      let len = touches.length;\n\n      if (len >= 2) {\n        let moveinfo = this._gettouchmoveinfo(\n          touches[len - 2],\n          touches[len - 1]\n        );\n        let ish = moveinfo.axis === 'horizontal';\n        let isv = moveinfo.axis === 'vertical';\n        let ist = this._drawer.direction === 'top' && moveinfo.y >= 0;\n        let isr = this._drawer.direction === 'right' && moveinfo.x < 0;\n        let isb = this._drawer.direction === 'bottom' && moveinfo.y < 0;\n        let isl = this._drawer.direction === 'left' && moveinfo.x >= 0;\n\n        return (ish && (isr || isl)) || (isv && (isb || ist)) ?\n          'open' :\n          'close';\n      }\n    }\n\n    return this._getstatefromposition();\n  }\n\n  /**\n   * Return drawer event handler.\n   *\n   * @return {Object} Drawer event handler.\n   */\n  _getdrawerhandler() {\n    let handler = {};\n\n    handler.resize = () => {\n      this._resetdrawer();\n      this[this.state](0, false, false);\n\n      if (this._drawer.onresize) {\n        this._drawer.onresize.apply(\n          this,\n          [this._drawer]\n        );\n      }\n    };\n\n    if (this._drawer.isswipeable) {\n      for (let event of TOUCH_EVENTS) {\n        handler[event] = this._touchhandler.bind(this);\n      }\n    }\n\n    if (window.history\n      && window.history.pushState\n      && this._drawer.ishistory\n    ) {\n      handler.popstate = (e) => {\n        if (e.state && e.state.id === this._id && this.state === 'open') {\n          this.close(null, true, false);\n        }\n      };\n    }\n\n    return handler;\n  }\n\n  /**\n   * Touch event handler.\n   *\n   * @param {Event} ev Touch event object.\n   * @return {boolean} Event bubbling.\n   */\n  _touchhandler(ev) {\n    try {\n      if (ev.touches.length > 1) {\n        return true;\n      }\n\n      let touch = ev.touches[0];\n\n      if (touch) {\n        this._process.touches.push(touch);\n      }\n\n      switch (ev.type) {\n        case 'touchstart':\n          this._ontouchstart(ev);\n          break;\n        case 'touchmove':\n          this._ontouchmove(ev);\n          break;\n        case 'touchcancel':\n        case 'touchend':\n          this._ontouchfinish(ev);\n          break;\n        default:\n          break;\n      }\n    } catch (e) {\n      if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Touch start event handler.\n   *\n   * @param {Event} ev Touch event object.\n   */\n  _ontouchstart(ev) {\n    this._process.time.start = new Date().getTime();\n  }\n\n  /**\n   * Touch move event handler.\n   *\n   * @param {Event} ev Touch event object.\n   */\n  _ontouchmove(ev) {\n    let len = this._process.touches.length;\n    let isfiretouchstart = false;\n\n    if (!this._process.istouchactive && len >= 2) {\n      this._process.istouchactive = this._istouchactive(\n        this._process.touches[0]\n      );\n\n      if (this._process.istouchactive) {\n        this._showoverlay();\n        this._showdrawer();\n\n        if (this._drawer.ontouchstart) {\n          isfiretouchstart = true;\n        }\n      }\n    }\n\n    if (this._process.istouchactive) {\n      ev.stopPropagation();\n      ev.preventDefault();\n\n      this._position = this._getdrawerpositionfromtouches(\n        this._process.touches[len - 2],\n        this._process.touches[len - 1]\n      );\n\n      if (isfiretouchstart) {\n        this._drawer.ontouchstart.apply(\n          this,\n          [this._drawer, this._position]\n        );\n      }\n\n      helper.setstyle(\n        this._overlay.element,\n        this._getoverlaystyle(\n          this._getoverlayopacityfromposition(this._position),\n          0\n        )\n      );\n\n      helper.setstyle(\n        this._drawer.element,\n        this._getdrawerstyle(this._position, 0)\n      );\n\n      if (this._drawer.ontouchmove) {\n        this._drawer.ontouchmove.apply(\n          this,\n          [this._drawer, this._position]\n        );\n      }\n    }\n  }\n\n  /**\n   * Touch finish event handler.\n   *\n   * @param {Event} ev Touch event object.\n   */\n  _ontouchfinish(ev) {\n    let len = this._process.touches.length;\n\n    if (this._process.istouchactive && len >= 2) {\n      this._process.time.end = new Date().getTime();\n\n      let state = this._gettouchmovestate(\n        this._process.touches,\n        this._process.time\n      );\n\n      let changestate = this.state !== state;\n\n      this[state](null, changestate, changestate);\n\n      if (this._drawer.ontouchfinish) {\n        this._drawer.ontouchfinish.apply(\n          this,\n          [\n            this._drawer,\n            this._getdrawerpositionfromtouches(\n              this._process.touches[len - 2],\n              this._process.touches[len - 1]\n            ),\n          ]\n        );\n      }\n    }\n\n    this._process.touches = [];\n    this._process.istouchactive = false;\n    this._process.time.start = 0;\n    this._process.time.end = 0;\n  }\n\n  /**\n   * Return whether or not a valid touch.\n   *\n   * @param {number} position Moving position.\n   * @param {number} [duration=null] Drawer moving time.\n   * @param {Object} [callbacks=null] Callback objects.\n   * @param {boolean} [ischangehistory=false] Make a change in history.\n   * @return {Promise} Promise object.\n   */\n  _changestate(\n    position,\n    duration = null,\n    callbacks = null,\n    ischangehistory = true\n  ) {\n    return this._handlecallback(new Promise((resolve, reject) => {\n      try {\n        this._position = position;\n\n        let du = duration === null ? this._drawer.duration : duration;\n\n        if (this._timeoutid !== null) {\n          clearTimeout(this._timeoutid);\n          this._timeoutid = null;\n        }\n\n        let state = this._getstatefromposition();\n\n        if (state === 'open') {\n          this._showoverlay();\n          this._showdrawer();\n        }\n\n        if (ischangehistory\n          && this._drawer.ishistory\n          && window.history\n          && window.history.pushState\n        ) {\n          if (state === 'open') {\n            window.history.pushState({\n              id: this._id,\n            }, null, null);\n          } else {\n            window.history.back();\n          }\n        }\n\n        this[support.cssanim\n          ? '_cssanimate'\n          : '_jsanimate'](du);\n\n        this._timeoutid = setTimeout(\n          () => {\n            if (state === 'close') {\n              this._hidedrawer();\n              this._hideoverlay();\n            }\n\n            this._timeoutid = null;\n          },\n          du\n        );\n\n        this.state = state;\n\n        if (typeof callbacks === 'object' && callbacks.onchangestate) {\n          callbacks.onchangestate.apply(\n            this,\n            [this._drawer, state]\n          );\n        }\n\n        resolve.apply(this, [this._drawer]);\n      } catch (e) {\n        reject(e);\n      }\n    }), {\n      done: typeof callbacks === 'object' && callbacks.done ? callbacks.done : null,\n      fail: typeof callbacks === 'object' && callbacks.fail ? callbacks.fail : null,\n    });\n  }\n\n  /**\n   * Return whether or not a valid touch.\n   *\n   * @param {Object} touch Start touch information.\n   * @return {boolean} Result of valid touch.\n   */\n  _istouchactive(touch) {\n    let rg = this._getrange(\n      this.state === 'open' ?\n        '100%' :\n        this._drawer.swipearea\n    );\n\n    return (rg.from.x <= touch.clientX &&\n      touch.clientX <= rg.to.x &&\n      rg.from.y <= touch.clientY &&\n      touch.clientY <= rg.to.y);\n  }\n\n  /**\n   * Return the state of the drawer.\n   *\n   * @return {string} State of the drawer.\n   */\n  _getstatefromposition() {\n    let pos = this._position === null ?\n      this._getdrawerpositionfromstyle() :\n      this._position;\n\n    return Math.abs(pos) < this._sizepixel / 2 ?\n      'open' :\n      'close';\n  }\n\n  /**\n   * Return the position of the drawer.\n   *\n   * @param {Object} touchbasis Basic touch information.\n   * @param {Object} touchlast Last touch information.\n   * @return {number} Position of the drawer.\n   */\n  _getdrawerpositionfromtouches(touchbasis, touchlast) {\n    let distance = this._getdistance(\n      this._gettouchmoveinfo(touchbasis, touchlast)\n    );\n\n    let curpos = this._position === null ?\n      this._getdrawerpositionfromstyle() :\n      this._position;\n\n    let pos = Math.round(curpos + distance);\n    let minp = this._getminposition(this._drawer);\n\n    if (pos > 0) {\n      pos = 0;\n    } else if (pos < minp) {\n      pos = minp;\n    }\n\n    return pos;\n  }\n\n  /**\n   * Return the position in the style.\n   *\n   * @return {number} Position in the style.\n   */\n  _getdrawerpositionfromstyle() {\n    let value = this._drawer.element.style[this._drawer.direction];\n    return this._normalizenumber(value).value;\n  }\n\n\n  /**\n   * Return the opacity of the overlay.\n   *\n   * @param {number} position Moving position.\n   * @return {number} Position of the drawer.\n   */\n  _getoverlayopacityfromposition(position) {\n    let minp = this._getminposition(this._drawer);\n    let posratio = 1 - (Math.abs(position) / Math.abs(minp));\n    return ((this._overlay.opacity * posratio) * 10000) / 10000;\n  }\n\n  /**\n   * Return the opacity in the style.\n   *\n   * @return {number} Opacity in the style.\n   */\n  _getoverlayopacityfromstyle() {\n    return parseFloat(this._overlay.element.style.opacity);\n  }\n\n  /**\n   * Return the swipe range.\n   *\n   * @param {string|number} value Target swipe area value.\n   * @return {Object} Drag range.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _getrange(value) {\n    let basis = this._convertpixelabs(value);\n    let width = window.innerWidth;\n    let height = window.innerHeight;\n\n    switch (this._drawer.direction) {\n      case 'top':\n        return {from: {x: 0, y: 0}, to: {x: width, y: basis}};\n      case 'right':\n        return {from: {x: basis, y: 0}, to: {x: width, y: height}};\n      case 'bottom':\n        return {from: {x: 0, y: basis}, to: {x: width, y: height}};\n      case 'left':\n        return {from: {x: 0, y: 0}, to: {x: basis, y: height}};\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return a value converted to the absolute value of the pixel.\n   *\n   * @param {string|number} value Target value.\n   * @return {number} Converted to the absolute value of the pixel.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _convertpixelabs(value) {\n    let nvalue = this._normalizepixel(value);\n\n    switch (this._drawer.direction) {\n      case 'top':\n      case 'left':\n        return nvalue;\n      case 'right':\n        return window.innerWidth - nvalue;\n      case 'bottom':\n        return window.innerHeight - nvalue;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return the normalized pixel value.\n   *\n   * @param {string|number} value Target value.\n   * @return {number} Normalized pixel value.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _normalizepixel(value) {\n    let normalized = this._normalizenumber(value);\n\n    if (normalized.unit === 'number' || normalized.unit === 'pixel') {\n      return normalized.value;\n    } else if (normalized.unit === 'percent') {\n      switch (this._drawer.direction) {\n        case 'top':\n        case 'bottom':\n          return window.innerHeight * (normalized.value / 100);\n        case 'right':\n        case 'left':\n          return window.innerWidth * (normalized.value / 100);\n        default:\n          throw new Error(`'${this._drawer.direction}' does not support`);\n      }\n    }\n  }\n\n  /**\n   * Return the numeric normalized information.\n   *\n   * @param {string|number} value Target value.\n   * @return {Object} Numeric normalized information.\n   * @throws {Error} Is thrown if value is invalid.\n   */\n  _normalizenumber(value) {\n    if (typeof value === 'number') {\n      return {value: value, unit: 'number'};\n    } else if (String(value).match(/^[.\\-0-9]+$/)) {\n      return {value: Number(value), unit: 'number'};\n    } else if (value.match(/^[.\\-0-9]+px$/)) {\n      return {value: Number(value.replace(/px$/ig, '')), unit: 'pixel'};\n    } else if (value.match(/[.\\-0-9]+%$/)) {\n      return {value: Number(value.replace(/%$/ig, '')), unit: 'percent'};\n    }\n\n    throw new Error(`'${value}' does not support`);\n  }\n\n  /**\n   * Return to the minimum position for the drawer.\n   *\n   * @return {number} Minimum position for the drawer.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _getminposition() {\n    switch (this._drawer.direction) {\n      case 'top':\n      case 'bottom':\n        return -1 * this._drawer.element.offsetHeight;\n      case 'right':\n      case 'left':\n        return -1 * this._drawer.element.offsetWidth;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return the distance of the drawer.\n   *\n   * @param {Object} moveinfo Movement information of the drawer.\n   * @return {number} Distance of the drawer.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _getdistance(moveinfo) {\n    switch (this._drawer.direction) {\n      case 'top':\n        return moveinfo.y;\n      case 'right':\n        return -1 * moveinfo.x;\n      case 'bottom':\n        return -1 * moveinfo.y;\n      case 'left':\n        return moveinfo.x;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return the information of touch move.\n   *\n   * @param {Object} touchbasis Basic touch information.\n   * @param {Object} touchlast Last touch information.\n   * @return {Object} Movement distance of the x, y direction, movement direction.\n   */\n  _gettouchmoveinfo(touchbasis, touchlast) {\n    let x = touchlast.clientX - touchbasis.clientX;\n    let y = touchlast.clientY - touchbasis.clientY;\n    let axis = Math.abs(x) >= Math.abs(y) ? 'horizontal' : 'vertical';\n\n    return {x, y, axis};\n  }\n\n  /**\n   * Return the information of touch move.\n   *\n   * @param {Promise} promise Promise instance.\n   * @param {Object} callbacks Callback function with the key to 'done', 'fail', 'always' (each optional).\n   * @return {Promise} Promise instance.\n   */\n  _handlecallback(promise, callbacks) {\n    if (!callbacks) {\n      return promise;\n    }\n\n    for (let key of Object.keys(callbacks)) {\n      let callback = callbacks[key];\n\n      if (!callback) {\n        continue;\n      }\n\n      let cb = isarray(callback) ? callback : [callback];\n      let rcb = null;\n\n      switch (key) {\n        case 'done':\n          rcb = (prom, value) => prom.then(value.bind(this));\n          break;\n        case 'fail':\n          rcb = (prom, value) => prom.catch(value.bind(this));\n          break;\n        case 'always':\n          rcb = (prom, value) => prom.then(value.bind(this), value.bind(this));\n          break;\n        default:\n          break;\n      }\n\n      if (rcb) {\n        cb.reduce(rcb, promise);\n      }\n    }\n\n    return promise;\n  }\n}\n\nmodule.exports = Highendrawer;\n\n\n\n// WEBPACK FOOTER //\n// ./src/highendrawer.js","'use strict';\n\n/**\n * Vendor prefix list.\n *\n * @type {string[]}\n */\nexport const PREFIX = ['webkit', 'moz', 'o', 'ms'];\n\n/**\n * Drawer's default css style.\n *\n * @type {Object}\n */\nexport const DRAWER_STYLE = Object.freeze({\n  display: 'block',\n  position: 'fixed',\n  overflowX: 'hidden',\n  overflowY: 'auto',\n  zIndex: -1,\n  webkitOverflowScrolling: 'touch',\n});\n\n/**\n * Overlay's default css style.\n *\n * @type {Object}\n */\nexport const OVERLAY_STYLE = Object.freeze({\n  display: 'none',\n  backgroundColor: '#000',\n  position: 'fixed',\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n  zIndex: -1,\n  opacity: 0,\n});\n\n/**\n * Css transition style.\n *\n * @type {Object}\n */\nexport const TRANSITION_STYLE = Object.freeze({\n  transform: '',\n  transitionProperty: 'transform,opacity',\n  transitionTimingFunction: 'cubic-bezier(0,0,0.25,1)',\n  transitionDuration: '0ms',\n});\n\n/**\n * Default drawer property.\n *\n * @type {Drawer}\n */\nexport const DEFAULT_DRAWER_PROPERTY = Object.freeze({\n  element: null,\n  direction: 'right',\n  size: '80%',\n  maxsize: 256,\n  isswipeable: true,\n  swipearea: '8%',\n  duration: 300,\n  zindex: 9999,\n  style: {},\n  isinitcreate: true,\n  enabledmaxwidth: -1,\n  ishistory: true,\n  overlay: null,\n  oncreate: null,\n  ondestroy: null,\n  onopen: null,\n  onclose: null,\n  onchangestate: null,\n  onresize: null,\n  ontouchstart: null,\n  ontouchmove: null,\n  ontouchfinish: null,\n  onerror: null,\n});\n\n/**\n * Default overlay property.\n *\n * @type {Overlay}\n */\nexport const DEFAULT_OVERLAY_PROPERTY = Object.freeze({\n  element: null,\n  opacity: 0.2,\n  zindex: -1,\n  autocreate: false,\n});\n\n/**\n * Default processing state object.\n *\n * @type {Object}\n */\nexport const DEFAULT_PROCESS = Object.freeze({\n  touches: [],\n  istouchactive: false,\n  time: {\n    start: 0,\n    end: 0,\n  },\n});\n\n/**\n * Touch event list.\n *\n * @type {string[]}\n */\nexport const TOUCH_EVENTS = [\n  'touchstart',\n  'touchmove',\n  'touchend',\n  'touchcancel',\n];\n\n\n\n// WEBPACK FOOTER //\n// ./src/const.js","'use strict';\n\nimport {PREFIX} from './const';\nimport {isarray, ucfirst} from './util';\n\nconst dom = window.document.createElement('div');\n\nlet currentid = 0;\nlet validstylename = {};\n\n/**\n * Generate ID.\n *\n * @return {number} ID.\n */\nexport function generateid() {\n  return ++currentid;\n}\n\n/**\n * Verify that the style is present.\n *\n * @param {string[]|string} styles Css styles.\n * @return {boolean} Result of verification.\n */\nexport function hasstyle(styles) {\n  let ss = styles;\n\n  if (!isarray(styles)) {\n    ss = [styles];\n  }\n\n  for (let style of ss) {\n    if (typeof dom.style[style] !== 'undefined') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Set the CSS style to element.\n *\n * @param {Object} element Target element object.\n * @param {Object} style Css style.\n */\nexport function setstyle(element, style) {\n  for (let name of Object.keys(style)) {\n    let vsn = validstylename[name];\n\n    if (vsn) {\n      element.style[vsn] = style[name];\n    } else if (typeof element.style[name] === 'undefined') {\n      for (let i = 0; i < 2; i++) {\n        for (let pfx of PREFIX) {\n          let namewithprefix = (i === 0 ? pfx : ucfirst(pfx)) +\n            ucfirst(name);\n\n          if (typeof element.style[namewithprefix] !== 'undefined') {\n            validstylename[name] = namewithprefix;\n            element.style[namewithprefix] = style[name];\n            break;\n          }\n        }\n      }\n    } else {\n      validstylename[name] = name;\n      element.style[name] = style[name];\n    }\n  }\n}\n\n/**\n * Unset the CSS style to element.\n *\n * @param {Object} element Target element object.\n * @param {string[]|string} styles Css styles.\n */\nexport function unsetstyle(element, styles) {\n  let style = {};\n\n  for (let name of isarray(styles) ? styles : [styles]) {\n    style[name] = '';\n  }\n\n  setstyle(element, style);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/helper.js","'use strict';\n\n/**\n * Convert the first letter to uppercase.\n *\n * @param {string} str Target character string.\n * @return {string} Converted string.\n */\nexport function ucfirst(str) {\n  return str.charAt(0).toUpperCase() + str.substr(1);\n}\n\n/**\n * Whether or not the object is an array.\n *\n * @param {any} obj Target object.\n * @return {boolean} Returns true if object is an Array.\n */\nexport function isarray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js","'use strict';\n\nimport {hasstyle} from './helper';\n\n/**\n * Browser support information.\n *\n * @type {Object}\n */\nlet sup = {};\n\nsup.transform3d = hasstyle([\n  'perspectiveProperty',\n  'webkitPerspective',\n  'mozPerspective',\n  'oPerspective',\n  'msPerspective',\n]);\n\nsup.transform = hasstyle([\n  'transformProperty',\n  'webkitTransform',\n  'mozTransform',\n  'oTransform',\n  'msTransform',\n]);\n\nsup.transition = hasstyle([\n  'transitionProperty',\n  'webkitTransitionProperty',\n  'mozTransitionProperty',\n  'oTransitionProperty',\n  'msTransitionProperty',\n]);\n\nsup.cssanim = (sup.transform3d || sup.transform) &&\n  sup.transition;\n\nsup.transrate = sup.transform3d ?\n  'translate3d' :\n  'translate';\n\n/**\n * Browser support information.\n *\n * @type {Object}\n */\nexport const support = Object.freeze(sup);\n\n\n\n// WEBPACK FOOTER //\n// ./src/support.js"],"sourceRoot":""}