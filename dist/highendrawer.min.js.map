{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///highendrawer.min.js","webpack:///webpack/bootstrap 200a9a27b01789ce1be1","webpack:///./src/highendrawer.js","webpack:///./src/const.js","webpack:///./src/helper.js","webpack:///./src/util.js","webpack:///./src/support.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","default","_classCallCheck","instance","Constructor","TypeError","defineProperty","value","_typeof","Symbol","iterator","constructor","_extends","assign","target","i","arguments","length","source","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","_const","_util","_helper","helper","_support","Highendrawer","drawer","_this","state","_id","generateid","_drawer","DEFAULT_DRAWER_PROPERTY","_overlay","overlay","DEFAULT_OVERLAY_PROPERTY","_timeoutid","_intervalid","_process","DEFAULT_PROCESS","_enabled","_handler","_getdrawerhandler","enabledmaxwidth","window","addEventListener","innerWidth","destroy","create","history","pushState","ishistory","replaceState","isinitcreate","_createdrawer","_createoverlay","oncreate","apply","e","onerror","_destroydrawer","_destroyoverlay","ondestroy","duration","undefined","isfireevent","ischangehistory","_changestate","onchangestate","done","onopen","fail","_getminposition","onclose","_this2","Promise","resolve","reject","then","_this3","setstyle","element","DRAWER_STYLE","support","cssanim","TRANSITION_STYLE","_resetdrawer","keys","forEach","name","_this4","removeEventListener","unsetstyle","_this5","zindex","document","createElement","isautocreated","OVERLAY_STYLE","touchhandler","close","body","appendChild","parentNode","removeChild","isunset","_setprops","ims","_getinitdrawerstyle","zIndex","display","sizepixel","_normalizepixel","size","maxsizepixel","maxsize","_sizepixel","_position","style","direction","width","height","top","right","bottom","left","Error","position","minp","transitionDuration","transform","transrate","opacity","_getoverlaystyle","_getoverlayopacityfromposition","_getdrawerstyle","_this6","start","Date","fromopy","_getoverlayopacityfromstyle","toopy","frompos","_getdrawerpositionfromstyle","topos","clearInterval","setInterval","time","nowpos","nowopy","prp","touches","end","len","moveinfo","_gettouchmoveinfo","ish","axis","isv","ist","y","isr","x","isb","isl","_getstatefromposition","_this7","handler","resize","onresize","isswipeable","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","TOUCH_EVENTS","next","event","_touchhandler","bind","err","return","popstate","ev","touch","push","type","_ontouchstart","_ontouchmove","_ontouchfinish","getTime","isfiretouchstart","istouchactive","_istouchactive","_showoverlay","_showdrawer","ontouchstart","stopPropagation","preventDefault","_getdrawerpositionfromtouches","ontouchmove","_gettouchmovestate","changestate","ontouchfinish","_this8","callbacks","_handlecallback","du","clearTimeout","back","setTimeout","_hidedrawer","_hideoverlay","rg","_getrange","swipearea","from","clientX","to","clientY","pos","Math","abs","touchbasis","touchlast","distance","_getdistance","curpos","round","_normalizenumber","posratio","parseFloat","basis","_convertpixelabs","innerHeight","nvalue","normalized","unit","String","match","Number","replace","offsetHeight","offsetWidth","promise","_this9","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","callback","cb","isarray","rcb","prom","catch","reduce","PREFIX","freeze","overflowX","overflowY","webkitOverflowScrolling","backgroundColor","transitionProperty","transitionTimingFunction","autocreate","currentid","hasstyle","styles","ss","dom","vsn","validstylename","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","pfx","namewithprefix","ucfirst","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","str","charAt","toUpperCase","substr","toString","sup","transform3d","transition"],"mappings":"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","file":"highendrawer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Highendrawer\"] = factory();\n\telse\n\t\troot[\"Highendrawer\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n * highendrawer - Highendrawer provides javascript and css drawers to your website and applications.\n * @version v0.0.5\n * @link https://github.com/ym-aozora/highendrawer#readme\n * @license MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Highendrawer\"] = factory();\n\telse\n\t\troot[\"Highendrawer\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _const = __webpack_require__(1);\n\t\n\tvar _util = __webpack_require__(3);\n\t\n\tvar _helper = __webpack_require__(2);\n\t\n\tvar helper = _interopRequireWildcard(_helper);\n\t\n\tvar _support = __webpack_require__(4);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Class providing a drawer function.\n\t *\n\t * @public\n\t * @class\n\t * @example\n\t * var drawer = new DrawerMenu({\n\t *   element: document.getElementById('drawer')\n\t * });\n\t */\n\tvar Highendrawer = function () {\n\t\n\t  /**\n\t   * Initialize object.\n\t   *\n\t   * @constructor\n\t   * @param {Drawer} drawer Initial parameters of drawer.\n\t   */\n\t  function Highendrawer(drawer) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Highendrawer);\n\t\n\t    /**\n\t     * Drawer status ('open' or 'close')\n\t     *\n\t     * @public\n\t     * @type {string}\n\t     */\n\t    this.state = 'close';\n\t\n\t    this._id = helper.generateid();\n\t    this._drawer = _extends({}, _const.DEFAULT_DRAWER_PROPERTY, drawer);\n\t    this._overlay = this._drawer.overlay === false ? false : _extends({}, _const.DEFAULT_OVERLAY_PROPERTY, this._drawer.overlay);\n\t    this._timeoutid = null;\n\t    this._intervalid = null;\n\t    this._process = _extends({}, _const.DEFAULT_PROCESS);\n\t    this._enabled = false;\n\t    this._handler = this._getdrawerhandler();\n\t\n\t    if (this._drawer.enabledmaxwidth > -1) {\n\t      window.addEventListener('resize', function () {\n\t        if (_this._enabled && window.innerWidth > _this._drawer.enabledmaxwidth) {\n\t          _this.destroy();\n\t        } else if (!_this._enabled && window.innerWidth <= _this._drawer.enabledmaxwidth) {\n\t          _this.create();\n\t        }\n\t      });\n\t    }\n\t\n\t    if (window.history && window.history.pushState && this._drawer.ishistory) {\n\t      window.history.replaceState({\n\t        id: this._id\n\t      }, null, null);\n\t    }\n\t\n\t    if (this._drawer.isinitcreate) {\n\t      this.create();\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Create the drawer set.\n\t   *\n\t   * @public\n\t   */\n\t\n\t\n\t  _createClass(Highendrawer, [{\n\t    key: 'create',\n\t    value: function create() {\n\t      try {\n\t        this._createdrawer();\n\t        this._createoverlay();\n\t        this._enabled = true;\n\t\n\t        if (this._drawer.oncreate) {\n\t          this._drawer.oncreate.apply(this, [this._drawer]);\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Destroy the drawer set.\n\t     *\n\t     * @public\n\t     */\n\t\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy() {\n\t      try {\n\t        this._destroydrawer();\n\t        this._destroyoverlay();\n\t        this._enabled = false;\n\t\n\t        if (this._drawer.ondestroy) {\n\t          this._drawer.ondestroy.apply(this, [this._drawer]);\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Open drawer.\n\t     *\n\t     * @public\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n\t     * @param {boolean} [ischangehistory=false] Make a change in history.\n\t     * @return {Promise} Promise object for open.\n\t     */\n\t\n\t  }, {\n\t    key: 'open',\n\t    value: function open() {\n\t      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t      var isfireevent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var ischangehistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t      return this._changestate(0, duration, {\n\t        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n\t        done: isfireevent ? this._drawer.onopen : null,\n\t        fail: isfireevent ? this._drawer.onerror : null\n\t      }, ischangehistory);\n\t    }\n\t\n\t    /**\n\t     * Close drawer.\n\t     *\n\t     * @public\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n\t     * @param {boolean} [ischangehistory=false] Make a change in history.\n\t     * @return {Promise} Promise object for close.\n\t     */\n\t\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t      var isfireevent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var ischangehistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t      return this._changestate(this._getminposition(), duration, {\n\t        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n\t        done: isfireevent ? this._drawer.onclose : null,\n\t        fail: isfireevent ? this._drawer.onerror : null\n\t      }, ischangehistory);\n\t    }\n\t\n\t    /**\n\t     * Toggle drawer.\n\t     *\n\t     * @public\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n\t     * @param {boolean} [ischangehistory=false] Make a change in history.\n\t     * @return {Promise} Promise object for toggle.\n\t     */\n\t\n\t  }, {\n\t    key: 'toggle',\n\t    value: function toggle() {\n\t      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\n\t      var _this2 = this;\n\t\n\t      var isfireevent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var ischangehistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          _this2[_this2.state === 'open' ? 'close' : 'open'](duration, isfireevent, ischangehistory).then(resolve, reject);\n\t        } catch (e) {\n\t          reject(e);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Create drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_createdrawer',\n\t    value: function _createdrawer() {\n\t      var _this3 = this;\n\t\n\t      helper.setstyle(this._drawer.element, _extends({}, _const.DRAWER_STYLE, _support.support.cssanim ? _const.TRANSITION_STYLE : {}));\n\t\n\t      this._resetdrawer();\n\t\n\t      Object.keys(this._handler).forEach(function (name) {\n\t        window.addEventListener(name, _this3._handler[name]);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Destroy drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_destroydrawer',\n\t    value: function _destroydrawer() {\n\t      var _this4 = this;\n\t\n\t      Object.keys(this._handler).forEach(function (name) {\n\t        window.removeEventListener(name, _this4._handler[name]);\n\t      });\n\t\n\t      this._resetdrawer(true);\n\t\n\t      helper.unsetstyle(this._drawer.element, Object.keys(_extends({}, _const.DRAWER_STYLE, _support.support.cssanim ? _const.TRANSITION_STYLE : {})));\n\t    }\n\t\n\t    /**\n\t     * Create overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_createoverlay',\n\t    value: function _createoverlay() {\n\t      var _this5 = this;\n\t\n\t      if (this._overlay === false) {\n\t        return;\n\t      }\n\t\n\t      if (this._overlay.zindex === -1) {\n\t        this._overlay.zindex = this._drawer.zindex - 1;\n\t      }\n\t\n\t      if (!this._overlay.element) {\n\t        this._overlay.element = window.document.createElement('div');\n\t        this._overlay.isautocreated = true;\n\t\n\t        helper.setstyle(this._overlay.element, _extends({}, _const.OVERLAY_STYLE, _support.support.cssanim ? _const.TRANSITION_STYLE : {}));\n\t      }\n\t\n\t      if (!this._overlay.touchhandler) {\n\t        this._overlay.touchhandler = function (e) {\n\t          _this5.close();\n\t        };\n\t      }\n\t\n\t      window.document.body.appendChild(this._overlay.element);\n\t    }\n\t\n\t    /**\n\t     * Destroy overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_destroyoverlay',\n\t    value: function _destroyoverlay() {\n\t      if (this._overlay === false) {\n\t        return;\n\t      }\n\t\n\t      if (this._overlay.element) {\n\t        this._overlay.element.removeEventListener('click', this._overlay.touchhandler);\n\t\n\t        if (this._overlay.isautocreated) {\n\t          this._overlay.element.parentNode.removeChild(this._overlay.element);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Reset drawer.\n\t     *\n\t     * @param {boolean} [isunset] Unset style.\n\t     */\n\t\n\t  }, {\n\t    key: '_resetdrawer',\n\t    value: function _resetdrawer() {\n\t      var isunset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t      try {\n\t        this._setprops();\n\t\n\t        var ims = this._getinitdrawerstyle();\n\t\n\t        if (isunset) {\n\t          helper.unsetstyle(this._drawer.element, Object.keys(ims));\n\t        } else {\n\t          helper.setstyle(this._drawer.element, ims);\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Show drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_showdrawer',\n\t    value: function _showdrawer() {\n\t      helper.setstyle(this._drawer.element, {\n\t        zIndex: this._drawer.zindex\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Hide drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_hidedrawer',\n\t    value: function _hidedrawer() {\n\t      helper.setstyle(this._drawer.element, {\n\t        zIndex: -1\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Show overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_showoverlay',\n\t    value: function _showoverlay() {\n\t      helper.setstyle(this._overlay.element, {\n\t        zIndex: this._overlay.zindex,\n\t        display: 'block'\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Hide overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_hideoverlay',\n\t    value: function _hideoverlay() {\n\t      helper.setstyle(this._overlay.element, {\n\t        zIndex: -1,\n\t        display: 'none'\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Set properties.\n\t     */\n\t\n\t  }, {\n\t    key: '_setprops',\n\t    value: function _setprops() {\n\t      // set sizepixel\n\t      var sizepixel = this._normalizepixel(this._drawer.size);\n\t\n\t      var maxsizepixel = this._normalizepixel(this._drawer.maxsize);\n\t\n\t      if (sizepixel > maxsizepixel) {\n\t        sizepixel = maxsizepixel;\n\t      }\n\t\n\t      this._sizepixel = sizepixel;\n\t\n\t      // set position\n\t      this._position = typeof this._position === 'undefined' ? null : this._position;\n\t    }\n\t\n\t    /**\n\t     * Return initial style of drawer.\n\t     *\n\t     * @return {Object} Style for drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getinitdrawerstyle',\n\t    value: function _getinitdrawerstyle() {\n\t      var style = null;\n\t\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t          style = {\n\t            width: '100%',\n\t            height: this._sizepixel + 'px',\n\t            top: '-' + this._sizepixel + 'px',\n\t            right: 'auto',\n\t            bottom: 'auto',\n\t            left: 0\n\t          };\n\t          break;\n\t        case 'right':\n\t          style = {\n\t            width: this._sizepixel + 'px',\n\t            height: '100%',\n\t            top: 0,\n\t            right: '-' + this._sizepixel + 'px',\n\t            bottom: 'auto',\n\t            left: 'auto'\n\t          };\n\t          break;\n\t        case 'bottom':\n\t          style = {\n\t            width: '100%',\n\t            height: this._sizepixel + 'px',\n\t            top: 'auto',\n\t            right: 'auto',\n\t            bottom: '-' + this._sizepixel + 'px',\n\t            left: 0\n\t          };\n\t          break;\n\t        case 'left':\n\t          style = {\n\t            width: this._sizepixel + 'px',\n\t            height: '100%',\n\t            top: 0,\n\t            right: 'auto',\n\t            bottom: 'auto',\n\t            left: '-' + this._sizepixel + 'px'\n\t          };\n\t          break;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t\n\t      return _extends(style, this._drawer.style || {});\n\t    }\n\t\n\t    /**\n\t     * Return style for moving the drawer.\n\t     *\n\t     * @param {number} position Moving position.\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @return {Object} Move style for drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerstyle',\n\t    value: function _getdrawerstyle(position) {\n\t      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var minp = this._getminposition(this._drawer);\n\t      var style = {};\n\t\n\t      if (_support.support.cssanim) {\n\t        style.transitionDuration = (duration === null ? this._drawer.duration : duration) + 'ms';\n\t\n\t        switch (this._drawer.direction) {\n\t          case 'top':\n\t            style.transform = _support.support.transrate + '(0,' + -(minp - position) + 'px,0)';\n\t            break;\n\t          case 'right':\n\t            style.transform = _support.support.transrate + '(' + (minp - position) + 'px,0,0)';\n\t            break;\n\t          case 'bottom':\n\t            style.transform = _support.support.transrate + '(0,' + (minp - position) + 'px,0)';\n\t            break;\n\t          case 'left':\n\t            style.transform = _support.support.transrate + '(' + -(minp - position) + 'px,0,0)';\n\t            break;\n\t          default:\n\t            throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t        }\n\t      } else {\n\t        style[this._drawer.direction] = position + 'px';\n\t      }\n\t\n\t      return style;\n\t    }\n\t\n\t    /**\n\t     * Return style for moving the overlay.\n\t     *\n\t     * @param {float} opacity Overlay opacity.\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @return {Object} Move style for overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_getoverlaystyle',\n\t    value: function _getoverlaystyle(opacity) {\n\t      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var style = {\n\t        opacity: opacity\n\t      };\n\t\n\t      if (_support.support.cssanim) {\n\t        style.transitionDuration = (duration === null ? this._drawer.duration : duration) + 'ms';\n\t      }\n\t\n\t      return style;\n\t    }\n\t\n\t    /**\n\t     * Make animation with CSS3.\n\t     *\n\t     * @param {number} duration Drawer moving time.\n\t     */\n\t\n\t  }, {\n\t    key: '_cssanimate',\n\t    value: function _cssanimate(duration) {\n\t      helper.setstyle(this._overlay.element, this._getoverlaystyle(this._getoverlayopacityfromposition(this._position), duration));\n\t\n\t      helper.setstyle(this._drawer.element, this._getdrawerstyle(this._position, duration));\n\t    }\n\t\n\t    /**\n\t     * Make animation with Javascript.\n\t     *\n\t     * @param {number} duration Drawer moving time.\n\t     */\n\t\n\t  }, {\n\t    key: '_jsanimate',\n\t    value: function _jsanimate(duration) {\n\t      var _this6 = this;\n\t\n\t      var start = +new Date();\n\t      var fromopy = this._getoverlayopacityfromstyle();\n\t      var toopy = this._getoverlayopacityfromposition(this._position);\n\t      var frompos = this._getdrawerpositionfromstyle();\n\t      var topos = this._position;\n\t\n\t      if (this._intervalid) {\n\t        clearInterval(this._intervalid);\n\t      }\n\t\n\t      this._intervalid = setInterval(function () {\n\t        var time = new Date() - start;\n\t        var nowpos = null;\n\t        var nowopy = null;\n\t\n\t        if (time > duration) {\n\t          clearInterval(_this6._intervalid);\n\t          _this6._intervalid = null;\n\t          nowopy = toopy;\n\t          nowpos = topos;\n\t        } else {\n\t          var prp = (time /= duration) * (time - 2);\n\t          nowopy = fromopy - (toopy - fromopy) * prp;\n\t          nowpos = frompos - (topos - frompos) * prp;\n\t        }\n\t\n\t        helper.setstyle(_this6._overlay.element, _this6._getoverlaystyle(nowopy, duration));\n\t\n\t        helper.setstyle(_this6._drawer.element, _this6._getdrawerstyle(nowpos, duration));\n\t      }, 10);\n\t    }\n\t\n\t    /**\n\t     * Return state by touch movement.\n\t     *\n\t     * @param {Array} touches Touch object array.\n\t     * @param {Object} time Time information on start and end of movement.\n\t     * @return {string} State by touch movement.\n\t     */\n\t\n\t  }, {\n\t    key: '_gettouchmovestate',\n\t    value: function _gettouchmovestate(touches, time) {\n\t      if (time.end - time.start <= 300) {\n\t        var len = touches.length;\n\t\n\t        if (len >= 2) {\n\t          var moveinfo = this._gettouchmoveinfo(touches[len - 2], touches[len - 1]);\n\t          var ish = moveinfo.axis === 'horizontal';\n\t          var isv = moveinfo.axis === 'vertical';\n\t          var ist = this._drawer.direction === 'top' && moveinfo.y >= 0;\n\t          var isr = this._drawer.direction === 'right' && moveinfo.x < 0;\n\t          var isb = this._drawer.direction === 'bottom' && moveinfo.y < 0;\n\t          var isl = this._drawer.direction === 'left' && moveinfo.x >= 0;\n\t\n\t          return ish && (isr || isl) || isv && (isb || ist) ? 'open' : 'close';\n\t        }\n\t      }\n\t\n\t      return this._getstatefromposition();\n\t    }\n\t\n\t    /**\n\t     * Return drawer event handler.\n\t     *\n\t     * @return {Object} Drawer event handler.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerhandler',\n\t    value: function _getdrawerhandler() {\n\t      var _this7 = this;\n\t\n\t      var handler = {};\n\t\n\t      handler.resize = function () {\n\t        _this7._resetdrawer();\n\t        _this7[_this7.state](0, false, false);\n\t\n\t        if (_this7._drawer.onresize) {\n\t          _this7._drawer.onresize.apply(_this7, [_this7._drawer]);\n\t        }\n\t      };\n\t\n\t      if (this._drawer.isswipeable) {\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t          for (var _iterator = _const.TOUCH_EVENTS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var event = _step.value;\n\t\n\t            handler[event] = this._touchhandler.bind(this);\n\t          }\n\t        } catch (err) {\n\t          _didIteratorError = true;\n\t          _iteratorError = err;\n\t        } finally {\n\t          try {\n\t            if (!_iteratorNormalCompletion && _iterator.return) {\n\t              _iterator.return();\n\t            }\n\t          } finally {\n\t            if (_didIteratorError) {\n\t              throw _iteratorError;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      if (window.history && window.history.pushState && this._drawer.ishistory) {\n\t        handler.popstate = function (e) {\n\t          if (e.state && e.state.id === _this7._id && _this7.state === 'open') {\n\t            _this7.close(null, true, false);\n\t          }\n\t        };\n\t      }\n\t\n\t      return handler;\n\t    }\n\t\n\t    /**\n\t     * Touch event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     * @return {boolean} Event bubbling.\n\t     */\n\t\n\t  }, {\n\t    key: '_touchhandler',\n\t    value: function _touchhandler(ev) {\n\t      try {\n\t        if (ev.touches.length > 1) {\n\t          return true;\n\t        }\n\t\n\t        var touch = ev.touches[0];\n\t\n\t        if (touch) {\n\t          this._process.touches.push(touch);\n\t        }\n\t\n\t        switch (ev.type) {\n\t          case 'touchstart':\n\t            this._ontouchstart(ev);\n\t            break;\n\t          case 'touchmove':\n\t            this._ontouchmove(ev);\n\t            break;\n\t          case 'touchcancel':\n\t          case 'touchend':\n\t            this._ontouchfinish(ev);\n\t            break;\n\t          default:\n\t            break;\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * Touch start event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     */\n\t\n\t  }, {\n\t    key: '_ontouchstart',\n\t    value: function _ontouchstart(ev) {\n\t      this._process.time.start = new Date().getTime();\n\t    }\n\t\n\t    /**\n\t     * Touch move event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     */\n\t\n\t  }, {\n\t    key: '_ontouchmove',\n\t    value: function _ontouchmove(ev) {\n\t      var len = this._process.touches.length;\n\t      var isfiretouchstart = false;\n\t\n\t      if (!this._process.istouchactive && len >= 2) {\n\t        this._process.istouchactive = this._istouchactive(this._process.touches[0]);\n\t\n\t        if (this._process.istouchactive) {\n\t          this._showoverlay();\n\t          this._showdrawer();\n\t\n\t          if (this._drawer.ontouchstart) {\n\t            isfiretouchstart = true;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (this._process.istouchactive) {\n\t        ev.stopPropagation();\n\t        ev.preventDefault();\n\t\n\t        this._position = this._getdrawerpositionfromtouches(this._process.touches[len - 2], this._process.touches[len - 1]);\n\t\n\t        if (isfiretouchstart) {\n\t          this._drawer.ontouchstart.apply(this, [this._drawer, this._position]);\n\t        }\n\t\n\t        helper.setstyle(this._overlay.element, this._getoverlaystyle(this._getoverlayopacityfromposition(this._position), 0));\n\t\n\t        helper.setstyle(this._drawer.element, this._getdrawerstyle(this._position, 0));\n\t\n\t        if (this._drawer.ontouchmove) {\n\t          this._drawer.ontouchmove.apply(this, [this._drawer, this._position]);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Touch finish event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     */\n\t\n\t  }, {\n\t    key: '_ontouchfinish',\n\t    value: function _ontouchfinish(ev) {\n\t      var len = this._process.touches.length;\n\t\n\t      if (this._process.istouchactive && len >= 2) {\n\t        this._process.time.end = new Date().getTime();\n\t\n\t        var state = this._gettouchmovestate(this._process.touches, this._process.time);\n\t\n\t        var changestate = this.state !== state;\n\t\n\t        this[state](null, changestate, changestate);\n\t\n\t        if (this._drawer.ontouchfinish) {\n\t          this._drawer.ontouchfinish.apply(this, [this._drawer, this._getdrawerpositionfromtouches(this._process.touches[len - 2], this._process.touches[len - 1])]);\n\t        }\n\t      }\n\t\n\t      this._process.touches = [];\n\t      this._process.istouchactive = false;\n\t      this._process.time.start = 0;\n\t      this._process.time.end = 0;\n\t    }\n\t\n\t    /**\n\t     * Return whether or not a valid touch.\n\t     *\n\t     * @param {number} position Moving position.\n\t     * @param {number} [duration=null] Drawer moving time.\n\t     * @param {Object} [callbacks=null] Callback objects.\n\t     * @param {boolean} [ischangehistory=false] Make a change in history.\n\t     * @return {Promise} Promise object.\n\t     */\n\t\n\t  }, {\n\t    key: '_changestate',\n\t    value: function _changestate(position) {\n\t      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var _this8 = this;\n\t\n\t      var callbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t      var ischangehistory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\t\n\t      return this._handlecallback(new Promise(function (resolve, reject) {\n\t        try {\n\t          (function () {\n\t            _this8._position = position;\n\t\n\t            var du = duration === null ? _this8._drawer.duration : duration;\n\t\n\t            if (_this8._timeoutid !== null) {\n\t              clearTimeout(_this8._timeoutid);\n\t              _this8._timeoutid = null;\n\t            }\n\t\n\t            var state = _this8._getstatefromposition();\n\t\n\t            if (state === 'open') {\n\t              _this8._showoverlay();\n\t              _this8._showdrawer();\n\t            } else {\n\t              _this8._overlay.element.removeEventListener('click', _this8._overlay.touchhandler);\n\t            }\n\t\n\t            if (ischangehistory && _this8._drawer.ishistory && window.history && window.history.pushState) {\n\t              if (state === 'open') {\n\t                window.history.pushState({\n\t                  id: _this8._id\n\t                }, null, null);\n\t              } else {\n\t                window.history.back();\n\t              }\n\t            }\n\t\n\t            _this8[_support.support.cssanim ? '_cssanimate' : '_jsanimate'](du);\n\t\n\t            _this8._timeoutid = setTimeout(function () {\n\t              if (state === 'open') {\n\t                _this8._overlay.element.addEventListener('click', _this8._overlay.touchhandler);\n\t              } else {\n\t                _this8._hidedrawer();\n\t                _this8._hideoverlay();\n\t              }\n\t\n\t              _this8._timeoutid = null;\n\t            }, du);\n\t\n\t            _this8.state = state;\n\t\n\t            if ((typeof callbacks === 'undefined' ? 'undefined' : _typeof(callbacks)) === 'object' && callbacks.onchangestate) {\n\t              callbacks.onchangestate.apply(_this8, [_this8._drawer, state]);\n\t            }\n\t\n\t            resolve.apply(_this8, [_this8._drawer]);\n\t          })();\n\t        } catch (e) {\n\t          reject(e);\n\t        }\n\t      }), {\n\t        done: (typeof callbacks === 'undefined' ? 'undefined' : _typeof(callbacks)) === 'object' && callbacks.done ? callbacks.done : null,\n\t        fail: (typeof callbacks === 'undefined' ? 'undefined' : _typeof(callbacks)) === 'object' && callbacks.fail ? callbacks.fail : null\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Return whether or not a valid touch.\n\t     *\n\t     * @param {Object} touch Start touch information.\n\t     * @return {boolean} Result of valid touch.\n\t     */\n\t\n\t  }, {\n\t    key: '_istouchactive',\n\t    value: function _istouchactive(touch) {\n\t      var rg = this._getrange(this.state === 'open' ? '100%' : this._drawer.swipearea);\n\t\n\t      return rg.from.x <= touch.clientX && touch.clientX <= rg.to.x && rg.from.y <= touch.clientY && touch.clientY <= rg.to.y;\n\t    }\n\t\n\t    /**\n\t     * Return the state of the drawer.\n\t     *\n\t     * @return {string} State of the drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getstatefromposition',\n\t    value: function _getstatefromposition() {\n\t      var pos = this._position === null ? this._getdrawerpositionfromstyle() : this._position;\n\t\n\t      return Math.abs(pos) < this._sizepixel / 2 ? 'open' : 'close';\n\t    }\n\t\n\t    /**\n\t     * Return the position of the drawer.\n\t     *\n\t     * @param {Object} touchbasis Basic touch information.\n\t     * @param {Object} touchlast Last touch information.\n\t     * @return {number} Position of the drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerpositionfromtouches',\n\t    value: function _getdrawerpositionfromtouches(touchbasis, touchlast) {\n\t      var distance = this._getdistance(this._gettouchmoveinfo(touchbasis, touchlast));\n\t\n\t      var curpos = this._position === null ? this._getdrawerpositionfromstyle() : this._position;\n\t\n\t      var pos = Math.round(curpos + distance);\n\t      var minp = this._getminposition(this._drawer);\n\t\n\t      if (pos > 0) {\n\t        pos = 0;\n\t      } else if (pos < minp) {\n\t        pos = minp;\n\t      }\n\t\n\t      return pos;\n\t    }\n\t\n\t    /**\n\t     * Return the position in the style.\n\t     *\n\t     * @return {number} Position in the style.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerpositionfromstyle',\n\t    value: function _getdrawerpositionfromstyle() {\n\t      var value = this._drawer.element.style[this._drawer.direction];\n\t      return this._normalizenumber(value).value;\n\t    }\n\t\n\t    /**\n\t     * Return the opacity of the overlay.\n\t     *\n\t     * @param {number} position Moving position.\n\t     * @return {number} Position of the drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getoverlayopacityfromposition',\n\t    value: function _getoverlayopacityfromposition(position) {\n\t      var minp = this._getminposition(this._drawer);\n\t      var posratio = 1 - Math.abs(position) / Math.abs(minp);\n\t      return this._overlay.opacity * posratio * 10000 / 10000;\n\t    }\n\t\n\t    /**\n\t     * Return the opacity in the style.\n\t     *\n\t     * @return {number} Opacity in the style.\n\t     */\n\t\n\t  }, {\n\t    key: '_getoverlayopacityfromstyle',\n\t    value: function _getoverlayopacityfromstyle() {\n\t      return parseFloat(this._overlay.element.style.opacity);\n\t    }\n\t\n\t    /**\n\t     * Return the swipe range.\n\t     *\n\t     * @param {string|number} value Target swipe area value.\n\t     * @return {Object} Drag range.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_getrange',\n\t    value: function _getrange(value) {\n\t      var basis = this._convertpixelabs(value);\n\t      var width = window.innerWidth;\n\t      var height = window.innerHeight;\n\t\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t          return { from: { x: 0, y: 0 }, to: { x: width, y: basis } };\n\t        case 'right':\n\t          return { from: { x: basis, y: 0 }, to: { x: width, y: height } };\n\t        case 'bottom':\n\t          return { from: { x: 0, y: basis }, to: { x: width, y: height } };\n\t        case 'left':\n\t          return { from: { x: 0, y: 0 }, to: { x: basis, y: height } };\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return a value converted to the absolute value of the pixel.\n\t     *\n\t     * @param {string|number} value Target value.\n\t     * @return {number} Converted to the absolute value of the pixel.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_convertpixelabs',\n\t    value: function _convertpixelabs(value) {\n\t      var nvalue = this._normalizepixel(value);\n\t\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t        case 'left':\n\t          return nvalue;\n\t        case 'right':\n\t          return window.innerWidth - nvalue;\n\t        case 'bottom':\n\t          return window.innerHeight - nvalue;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the normalized pixel value.\n\t     *\n\t     * @param {string|number} value Target value.\n\t     * @return {number} Normalized pixel value.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_normalizepixel',\n\t    value: function _normalizepixel(value) {\n\t      var normalized = this._normalizenumber(value);\n\t\n\t      if (normalized.unit === 'number' || normalized.unit === 'pixel') {\n\t        return normalized.value;\n\t      } else if (normalized.unit === 'percent') {\n\t        switch (this._drawer.direction) {\n\t          case 'top':\n\t          case 'bottom':\n\t            return window.innerHeight * (normalized.value / 100);\n\t          case 'right':\n\t          case 'left':\n\t            return window.innerWidth * (normalized.value / 100);\n\t          default:\n\t            throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the numeric normalized information.\n\t     *\n\t     * @param {string|number} value Target value.\n\t     * @return {Object} Numeric normalized information.\n\t     * @throws {Error} Is thrown if value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_normalizenumber',\n\t    value: function _normalizenumber(value) {\n\t      if (typeof value === 'number') {\n\t        return { value: value, unit: 'number' };\n\t      } else if (String(value).match(/^[.\\-0-9]+$/)) {\n\t        return { value: Number(value), unit: 'number' };\n\t      } else if (value.match(/^[.\\-0-9]+px$/)) {\n\t        return { value: Number(value.replace(/px$/ig, '')), unit: 'pixel' };\n\t      } else if (value.match(/[.\\-0-9]+%$/)) {\n\t        return { value: Number(value.replace(/%$/ig, '')), unit: 'percent' };\n\t      }\n\t\n\t      throw new Error('\\'' + value + '\\' does not support');\n\t    }\n\t\n\t    /**\n\t     * Return to the minimum position for the drawer.\n\t     *\n\t     * @return {number} Minimum position for the drawer.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_getminposition',\n\t    value: function _getminposition() {\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t        case 'bottom':\n\t          return -1 * this._drawer.element.offsetHeight;\n\t        case 'right':\n\t        case 'left':\n\t          return -1 * this._drawer.element.offsetWidth;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the distance of the drawer.\n\t     *\n\t     * @param {Object} moveinfo Movement information of the drawer.\n\t     * @return {number} Distance of the drawer.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdistance',\n\t    value: function _getdistance(moveinfo) {\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t          return moveinfo.y;\n\t        case 'right':\n\t          return -1 * moveinfo.x;\n\t        case 'bottom':\n\t          return -1 * moveinfo.y;\n\t        case 'left':\n\t          return moveinfo.x;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the information of touch move.\n\t     *\n\t     * @param {Object} touchbasis Basic touch information.\n\t     * @param {Object} touchlast Last touch information.\n\t     * @return {Object} Movement distance of the x, y direction, movement direction.\n\t     */\n\t\n\t  }, {\n\t    key: '_gettouchmoveinfo',\n\t    value: function _gettouchmoveinfo(touchbasis, touchlast) {\n\t      var x = touchlast.clientX - touchbasis.clientX;\n\t      var y = touchlast.clientY - touchbasis.clientY;\n\t      var axis = Math.abs(x) >= Math.abs(y) ? 'horizontal' : 'vertical';\n\t\n\t      return { x: x, y: y, axis: axis };\n\t    }\n\t\n\t    /**\n\t     * Return the information of touch move.\n\t     *\n\t     * @param {Promise} promise Promise instance.\n\t     * @param {Object} callbacks Callback function with the key to 'done', 'fail', 'always' (each optional).\n\t     * @return {Promise} Promise instance.\n\t     */\n\t\n\t  }, {\n\t    key: '_handlecallback',\n\t    value: function _handlecallback(promise, callbacks) {\n\t      var _this9 = this;\n\t\n\t      if (!callbacks) {\n\t        return promise;\n\t      }\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = Object.keys(callbacks)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var key = _step2.value;\n\t\n\t          var callback = callbacks[key];\n\t\n\t          if (!callback) {\n\t            continue;\n\t          }\n\t\n\t          var cb = (0, _util.isarray)(callback) ? callback : [callback];\n\t          var rcb = null;\n\t\n\t          switch (key) {\n\t            case 'done':\n\t              rcb = function rcb(prom, value) {\n\t                return prom.then(value.bind(_this9));\n\t              };\n\t              break;\n\t            case 'fail':\n\t              rcb = function rcb(prom, value) {\n\t                return prom.catch(value.bind(_this9));\n\t              };\n\t              break;\n\t            case 'always':\n\t              rcb = function rcb(prom, value) {\n\t                return prom.then(value.bind(_this9), value.bind(_this9));\n\t              };\n\t              break;\n\t            default:\n\t              break;\n\t          }\n\t\n\t          if (rcb) {\n\t            cb.reduce(rcb, promise);\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      return promise;\n\t    }\n\t  }]);\n\t\n\t  return Highendrawer;\n\t}();\n\t\n\texports.default = Highendrawer;\n\t\n\t\n\tmodule.exports = Highendrawer;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Vendor prefix list.\n\t *\n\t * @type {string[]}\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar PREFIX = exports.PREFIX = ['webkit', 'moz', 'o', 'ms'];\n\t\n\t/**\n\t * Drawer's default css style.\n\t *\n\t * @type {Object}\n\t */\n\tvar DRAWER_STYLE = exports.DRAWER_STYLE = Object.freeze({\n\t  display: 'block',\n\t  position: 'fixed',\n\t  overflowX: 'hidden',\n\t  overflowY: 'auto',\n\t  zIndex: -1,\n\t  webkitOverflowScrolling: 'touch'\n\t});\n\t\n\t/**\n\t * Overlay's default css style.\n\t *\n\t * @type {Object}\n\t */\n\tvar OVERLAY_STYLE = exports.OVERLAY_STYLE = Object.freeze({\n\t  display: 'none',\n\t  backgroundColor: '#000',\n\t  position: 'fixed',\n\t  top: 0,\n\t  right: 0,\n\t  bottom: 0,\n\t  left: 0,\n\t  zIndex: -1,\n\t  opacity: 0\n\t});\n\t\n\t/**\n\t * Css transition style.\n\t *\n\t * @type {Object}\n\t */\n\tvar TRANSITION_STYLE = exports.TRANSITION_STYLE = Object.freeze({\n\t  transform: '',\n\t  transitionProperty: 'transform,opacity',\n\t  transitionTimingFunction: 'cubic-bezier(0,0,0.25,1)',\n\t  transitionDuration: '0ms'\n\t});\n\t\n\t/**\n\t * Default drawer property.\n\t *\n\t * @type {Drawer}\n\t */\n\tvar DEFAULT_DRAWER_PROPERTY = exports.DEFAULT_DRAWER_PROPERTY = Object.freeze({\n\t  element: null,\n\t  direction: 'right',\n\t  size: '80%',\n\t  maxsize: 256,\n\t  isswipeable: true,\n\t  swipearea: '8%',\n\t  duration: 300,\n\t  zindex: 9999,\n\t  style: {},\n\t  isinitcreate: true,\n\t  enabledmaxwidth: -1,\n\t  ishistory: true,\n\t  overlay: null,\n\t  oncreate: null,\n\t  ondestroy: null,\n\t  onopen: null,\n\t  onclose: null,\n\t  onchangestate: null,\n\t  onresize: null,\n\t  ontouchstart: null,\n\t  ontouchmove: null,\n\t  ontouchfinish: null,\n\t  onerror: null\n\t});\n\t\n\t/**\n\t * Default overlay property.\n\t *\n\t * @type {Overlay}\n\t */\n\tvar DEFAULT_OVERLAY_PROPERTY = exports.DEFAULT_OVERLAY_PROPERTY = Object.freeze({\n\t  element: null,\n\t  opacity: 0.2,\n\t  zindex: -1,\n\t  autocreate: false\n\t});\n\t\n\t/**\n\t * Default processing state object.\n\t *\n\t * @type {Object}\n\t */\n\tvar DEFAULT_PROCESS = exports.DEFAULT_PROCESS = Object.freeze({\n\t  touches: [],\n\t  istouchactive: false,\n\t  time: {\n\t    start: 0,\n\t    end: 0\n\t  }\n\t});\n\t\n\t/**\n\t * Touch event list.\n\t *\n\t * @type {string[]}\n\t */\n\tvar TOUCH_EVENTS = exports.TOUCH_EVENTS = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.generateid = generateid;\n\texports.hasstyle = hasstyle;\n\texports.setstyle = setstyle;\n\texports.unsetstyle = unsetstyle;\n\t\n\tvar _const = __webpack_require__(1);\n\t\n\tvar _util = __webpack_require__(3);\n\t\n\tvar dom = window.document.createElement('div');\n\t\n\tvar currentid = 0;\n\tvar validstylename = {};\n\t\n\t/**\n\t * Generate ID.\n\t *\n\t * @return {number} ID.\n\t */\n\tfunction generateid() {\n\t  return ++currentid;\n\t}\n\t\n\t/**\n\t * Verify that the style is present.\n\t *\n\t * @param {string[]|string} styles Css styles.\n\t * @return {boolean} Result of verification.\n\t */\n\tfunction hasstyle(styles) {\n\t  var ss = styles;\n\t\n\t  if (!(0, _util.isarray)(styles)) {\n\t    ss = [styles];\n\t  }\n\t\n\t  var _iteratorNormalCompletion = true;\n\t  var _didIteratorError = false;\n\t  var _iteratorError = undefined;\n\t\n\t  try {\n\t    for (var _iterator = ss[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t      var style = _step.value;\n\t\n\t      if (typeof dom.style[style] !== 'undefined') {\n\t        return true;\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError = true;\n\t    _iteratorError = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion && _iterator.return) {\n\t        _iterator.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError) {\n\t        throw _iteratorError;\n\t      }\n\t    }\n\t  }\n\t\n\t  return false;\n\t}\n\t\n\t/**\n\t * Set the CSS style to element.\n\t *\n\t * @param {Object} element Target element object.\n\t * @param {Object} style Css style.\n\t */\n\tfunction setstyle(element, style) {\n\t  var _iteratorNormalCompletion2 = true;\n\t  var _didIteratorError2 = false;\n\t  var _iteratorError2 = undefined;\n\t\n\t  try {\n\t    for (var _iterator2 = Object.keys(style)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t      var name = _step2.value;\n\t\n\t      var vsn = validstylename[name];\n\t\n\t      if (vsn) {\n\t        element.style[vsn] = style[name];\n\t      } else if (typeof element.style[name] === 'undefined') {\n\t        for (var i = 0; i < 2; i++) {\n\t          var _iteratorNormalCompletion3 = true;\n\t          var _didIteratorError3 = false;\n\t          var _iteratorError3 = undefined;\n\t\n\t          try {\n\t            for (var _iterator3 = _const.PREFIX[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t              var pfx = _step3.value;\n\t\n\t              var namewithprefix = (i === 0 ? pfx : (0, _util.ucfirst)(pfx)) + (0, _util.ucfirst)(name);\n\t\n\t              if (typeof element.style[namewithprefix] !== 'undefined') {\n\t                validstylename[name] = namewithprefix;\n\t                element.style[namewithprefix] = style[name];\n\t                break;\n\t              }\n\t            }\n\t          } catch (err) {\n\t            _didIteratorError3 = true;\n\t            _iteratorError3 = err;\n\t          } finally {\n\t            try {\n\t              if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                _iterator3.return();\n\t              }\n\t            } finally {\n\t              if (_didIteratorError3) {\n\t                throw _iteratorError3;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        validstylename[name] = name;\n\t        element.style[name] = style[name];\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError2 = true;\n\t    _iteratorError2 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t        _iterator2.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError2) {\n\t        throw _iteratorError2;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Unset the CSS style to element.\n\t *\n\t * @param {Object} element Target element object.\n\t * @param {string[]|string} styles Css styles.\n\t */\n\tfunction unsetstyle(element, styles) {\n\t  var style = {};\n\t\n\t  var _iteratorNormalCompletion4 = true;\n\t  var _didIteratorError4 = false;\n\t  var _iteratorError4 = undefined;\n\t\n\t  try {\n\t    for (var _iterator4 = ((0, _util.isarray)(styles) ? styles : [styles])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t      var name = _step4.value;\n\t\n\t      style[name] = '';\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError4 = true;\n\t    _iteratorError4 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t        _iterator4.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError4) {\n\t        throw _iteratorError4;\n\t      }\n\t    }\n\t  }\n\t\n\t  setstyle(element, style);\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Convert the first letter to uppercase.\n\t *\n\t * @param {string} str Target character string.\n\t * @return {string} Converted string.\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.ucfirst = ucfirst;\n\texports.isarray = isarray;\n\tfunction ucfirst(str) {\n\t  return str.charAt(0).toUpperCase() + str.substr(1);\n\t}\n\t\n\t/**\n\t * Whether or not the object is an array.\n\t *\n\t * @param {any} obj Target object.\n\t * @return {boolean} Returns true if object is an Array.\n\t */\n\tfunction isarray(obj) {\n\t  return Object.prototype.toString.call(obj) === '[object Array]';\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.support = undefined;\n\t\n\tvar _helper = __webpack_require__(2);\n\t\n\t/**\n\t * Browser support information.\n\t *\n\t * @type {Object}\n\t */\n\tvar sup = {};\n\t\n\tsup.transform3d = (0, _helper.hasstyle)(['perspectiveProperty', 'webkitPerspective', 'mozPerspective', 'oPerspective', 'msPerspective']);\n\t\n\tsup.transform = (0, _helper.hasstyle)(['transformProperty', 'webkitTransform', 'mozTransform', 'oTransform', 'msTransform']);\n\t\n\tsup.transition = (0, _helper.hasstyle)(['transitionProperty', 'webkitTransitionProperty', 'mozTransitionProperty', 'oTransitionProperty', 'msTransitionProperty']);\n\t\n\tsup.cssanim = (sup.transform3d || sup.transform) && sup.transition;\n\t\n\tsup.transrate = sup.transform3d ? 'translate3d' : 'translate';\n\t\n\t/**\n\t * Browser support information.\n\t *\n\t * @type {Object}\n\t */\n\tvar support = exports.support = Object.freeze(sup);\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// highendrawer.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 200a9a27b01789ce1be1","'use strict';\n\nimport {\n  DEFAULT_DRAWER_PROPERTY,\n  DEFAULT_OVERLAY_PROPERTY,\n  DEFAULT_PROCESS,\n  DRAWER_STYLE,\n  OVERLAY_STYLE,\n  TOUCH_EVENTS,\n  TRANSITION_STYLE,\n} from './const';\n\nimport {isarray} from './util';\nimport * as helper from './helper';\nimport {support} from './support';\n\n/**\n * Class providing a drawer function.\n *\n * @public\n * @class\n * @example\n * var drawer = new DrawerMenu({\n *   element: document.getElementById('drawer')\n * });\n */\nexport default class Highendrawer {\n\n  /**\n   * Initialize object.\n   *\n   * @constructor\n   * @param {Drawer} drawer Initial parameters of drawer.\n   */\n  constructor(drawer) {\n    /**\n     * Drawer status ('open' or 'close')\n     *\n     * @public\n     * @type {string}\n     */\n    this.state = 'close';\n\n    this._id = helper.generateid();\n    this._drawer = Object.assign({}, DEFAULT_DRAWER_PROPERTY, drawer);\n    this._overlay = this._drawer.overlay === false ?\n      false :\n      Object.assign({}, DEFAULT_OVERLAY_PROPERTY, this._drawer.overlay);\n    this._timeoutid = null;\n    this._intervalid = null;\n    this._process = Object.assign({}, DEFAULT_PROCESS);\n    this._enabled = false;\n    this._handler = this._getdrawerhandler();\n\n    if (this._drawer.enabledmaxwidth > -1) {\n      window.addEventListener('resize', () => {\n        if (this._enabled\n          && window.innerWidth > this._drawer.enabledmaxwidth) {\n          this.destroy();\n        } else if (!this._enabled\n          && window.innerWidth <= this._drawer.enabledmaxwidth) {\n          this.create();\n        }\n      });\n    }\n\n    if (window.history\n      && window.history.pushState\n      && this._drawer.ishistory\n    ) {\n      window.history.replaceState({\n        id: this._id,\n      }, null, null);\n    }\n\n    if (this._drawer.isinitcreate) {\n      this.create();\n    }\n  }\n\n  /**\n   * Create the drawer set.\n   *\n   * @public\n   */\n  create() {\n    try {\n      this._createdrawer();\n      this._createoverlay();\n      this._enabled = true;\n\n      if (this._drawer.oncreate) {\n        this._drawer.oncreate.apply(this, [this._drawer]);\n      }\n    } catch (e) {\n      if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Destroy the drawer set.\n   *\n   * @public\n   */\n  destroy() {\n    try {\n      this._destroydrawer();\n      this._destroyoverlay();\n      this._enabled = false;\n\n      if (this._drawer.ondestroy) {\n        this._drawer.ondestroy.apply(this, [this._drawer]);\n      }\n    } catch (e) {\n      if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Open drawer.\n   *\n   * @public\n   * @param {number} [duration] Drawer moving time.\n   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n   * @param {boolean} [ischangehistory=false] Make a change in history.\n   * @return {Promise} Promise object for open.\n   */\n  open(duration = null, isfireevent = true, ischangehistory = true) {\n    return this._changestate(\n      0,\n      duration,\n      {\n        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n        done: isfireevent ? this._drawer.onopen : null,\n        fail: isfireevent ? this._drawer.onerror : null,\n      },\n      ischangehistory\n    );\n  }\n\n  /**\n   * Close drawer.\n   *\n   * @public\n   * @param {number} [duration] Drawer moving time.\n   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n   * @param {boolean} [ischangehistory=false] Make a change in history.\n   * @return {Promise} Promise object for close.\n   */\n  close(duration = null, isfireevent = true, ischangehistory = true) {\n    return this._changestate(\n      this._getminposition(),\n      duration,\n      {\n        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n        done: isfireevent ? this._drawer.onclose : null,\n        fail: isfireevent ? this._drawer.onerror : null,\n      },\n      ischangehistory\n    );\n  }\n\n  /**\n   * Toggle drawer.\n   *\n   * @public\n   * @param {number} [duration] Drawer moving time.\n   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n   * @param {boolean} [ischangehistory=false] Make a change in history.\n   * @return {Promise} Promise object for toggle.\n   */\n  toggle(duration = null, isfireevent = true, ischangehistory = true) {\n    return new Promise((resolve, reject) => {\n      try {\n        this[this.state === 'open' ? 'close' : 'open'](duration, isfireevent, ischangehistory)\n          .then(resolve, reject);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  /**\n   * Create drawer.\n   */\n  _createdrawer() {\n    helper.setstyle(\n      this._drawer.element,\n      Object.assign(\n        {},\n        DRAWER_STYLE,\n        support.cssanim ? TRANSITION_STYLE : {}\n      )\n    );\n\n    this._resetdrawer();\n\n    Object.keys(this._handler).forEach((name) => {\n      window.addEventListener(name, this._handler[name]);\n    });\n  }\n\n  /**\n   * Destroy drawer.\n   */\n  _destroydrawer() {\n    Object.keys(this._handler).forEach((name) => {\n      window.removeEventListener(name, this._handler[name]);\n    });\n\n    this._resetdrawer(true);\n\n    helper.unsetstyle(\n      this._drawer.element,\n      Object.keys(\n        Object.assign(\n          {},\n          DRAWER_STYLE,\n          support.cssanim ? TRANSITION_STYLE : {}\n        )\n      )\n    );\n  }\n\n  /**\n   * Create overlay.\n   */\n  _createoverlay() {\n    if (this._overlay === false) {\n      return;\n    }\n\n    if (this._overlay.zindex === -1) {\n      this._overlay.zindex = this._drawer.zindex - 1;\n    }\n\n    if (!this._overlay.element) {\n      this._overlay.element = window.document.createElement('div');\n      this._overlay.isautocreated = true;\n\n      helper.setstyle(\n        this._overlay.element,\n        Object.assign(\n          {},\n          OVERLAY_STYLE,\n          support.cssanim ? TRANSITION_STYLE : {}\n        )\n      );\n    }\n\n    if (!this._overlay.touchhandler) {\n      this._overlay.touchhandler = (e) => {\n        this.close();\n      };\n    }\n\n    window.document.body.appendChild(this._overlay.element);\n  }\n\n  /**\n   * Destroy overlay.\n   */\n  _destroyoverlay() {\n    if (this._overlay === false) {\n      return;\n    }\n\n    if (this._overlay.element) {\n      this._overlay.element.removeEventListener('click', this._overlay.touchhandler);\n\n      if (this._overlay.isautocreated) {\n        this._overlay.element.parentNode.removeChild(this._overlay.element);\n      }\n    }\n  }\n\n  /**\n   * Reset drawer.\n   *\n   * @param {boolean} [isunset] Unset style.\n   */\n  _resetdrawer(isunset = false) {\n    try {\n      this._setprops();\n\n      let ims = this._getinitdrawerstyle();\n\n      if (isunset) {\n        helper.unsetstyle(this._drawer.element, Object.keys(ims));\n      } else {\n        helper.setstyle(this._drawer.element, ims);\n      }\n    } catch (e) {\n      if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Show drawer.\n   */\n  _showdrawer() {\n    helper.setstyle(this._drawer.element, {\n      zIndex: this._drawer.zindex,\n    });\n  }\n\n  /**\n   * Hide drawer.\n   */\n  _hidedrawer() {\n    helper.setstyle(this._drawer.element, {\n      zIndex: -1,\n    });\n  }\n\n  /**\n   * Show overlay.\n   */\n  _showoverlay() {\n    helper.setstyle(this._overlay.element, {\n      zIndex: this._overlay.zindex,\n      display: 'block',\n    });\n  }\n\n  /**\n   * Hide overlay.\n   */\n  _hideoverlay() {\n    helper.setstyle(this._overlay.element, {\n      zIndex: -1,\n      display: 'none',\n    });\n  }\n\n  /**\n   * Set properties.\n   */\n  _setprops() {\n    // set sizepixel\n    let sizepixel = this._normalizepixel(\n      this._drawer.size\n    );\n\n    let maxsizepixel = this._normalizepixel(\n      this._drawer.maxsize\n    );\n\n    if (sizepixel > maxsizepixel) {\n      sizepixel = maxsizepixel;\n    }\n\n    this._sizepixel = sizepixel;\n\n    // set position\n    this._position = typeof this._position === 'undefined' ?\n      null :\n      this._position;\n  }\n\n  /**\n   * Return initial style of drawer.\n   *\n   * @return {Object} Style for drawer.\n   */\n  _getinitdrawerstyle() {\n    let style = null;\n\n    switch (this._drawer.direction) {\n      case 'top':\n        style = {\n          width: '100%',\n          height: `${this._sizepixel}px`,\n          top: `-${this._sizepixel}px`,\n          right: 'auto',\n          bottom: 'auto',\n          left: 0,\n        };\n        break;\n      case 'right':\n        style = {\n          width: `${this._sizepixel}px`,\n          height: '100%',\n          top: 0,\n          right: `-${this._sizepixel}px`,\n          bottom: 'auto',\n          left: 'auto',\n        };\n        break;\n      case 'bottom':\n        style = {\n          width: '100%',\n          height: `${this._sizepixel}px`,\n          top: 'auto',\n          right: 'auto',\n          bottom: `-${this._sizepixel}px`,\n          left: 0,\n        };\n        break;\n      case 'left':\n        style = {\n          width: `${this._sizepixel}px`,\n          height: '100%',\n          top: 0,\n          right: 'auto',\n          bottom: 'auto',\n          left: `-${this._sizepixel}px`,\n        };\n        break;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n\n    return Object.assign(style, this._drawer.style || {});\n  }\n\n  /**\n   * Return style for moving the drawer.\n   *\n   * @param {number} position Moving position.\n   * @param {number} [duration] Drawer moving time.\n   * @return {Object} Move style for drawer.\n   */\n  _getdrawerstyle(position, duration = null) {\n    let minp = this._getminposition(this._drawer);\n    let style = {};\n\n    if (support.cssanim) {\n      style.transitionDuration = `${duration === null ? this._drawer.duration : duration}ms`;\n\n      switch (this._drawer.direction) {\n        case 'top':\n          style.transform = `${support.transrate}(0,${-(minp - position)}px,0)`;\n          break;\n        case 'right':\n          style.transform = `${support.transrate}(${minp - position}px,0,0)`;\n          break;\n        case 'bottom':\n          style.transform = `${support.transrate}(0,${minp - position}px,0)`;\n          break;\n        case 'left':\n          style.transform = `${support.transrate}(${-(minp - position)}px,0,0)`;\n          break;\n        default:\n          throw new Error(`'${this._drawer.direction}' does not support`);\n      }\n    } else {\n      style[this._drawer.direction] = `${position}px`;\n    }\n\n    return style;\n  }\n\n  /**\n   * Return style for moving the overlay.\n   *\n   * @param {float} opacity Overlay opacity.\n   * @param {number} [duration] Drawer moving time.\n   * @return {Object} Move style for overlay.\n   */\n  _getoverlaystyle(opacity, duration = null) {\n    let style = {\n      opacity,\n    };\n\n    if (support.cssanim) {\n      style.transitionDuration = `${duration === null ? this._drawer.duration : duration}ms`;\n    }\n\n    return style;\n  }\n\n  /**\n   * Make animation with CSS3.\n   *\n   * @param {number} duration Drawer moving time.\n   */\n  _cssanimate(duration) {\n    helper.setstyle(\n      this._overlay.element,\n      this._getoverlaystyle(\n        this._getoverlayopacityfromposition(this._position),\n        duration\n      )\n    );\n\n    helper.setstyle(\n      this._drawer.element,\n      this._getdrawerstyle(this._position, duration)\n    );\n  }\n\n  /**\n   * Make animation with Javascript.\n   *\n   * @param {number} duration Drawer moving time.\n   */\n  _jsanimate(duration) {\n    let start = +new Date();\n    let fromopy = this._getoverlayopacityfromstyle();\n    let toopy = this._getoverlayopacityfromposition(this._position);\n    let frompos = this._getdrawerpositionfromstyle();\n    let topos = this._position;\n\n    if (this._intervalid) {\n      clearInterval(this._intervalid);\n    }\n\n    this._intervalid = setInterval(() => {\n      let time = new Date() - start;\n      let nowpos = null;\n      let nowopy = null;\n\n      if (time > duration) {\n        clearInterval(this._intervalid);\n        this._intervalid = null;\n        nowopy = toopy;\n        nowpos = topos;\n      } else {\n        let prp = (time /= duration) * (time - 2);\n        nowopy = fromopy - ((toopy - fromopy) * prp);\n        nowpos = frompos - ((topos - frompos) * prp);\n      }\n\n      helper.setstyle(\n        this._overlay.element,\n        this._getoverlaystyle(nowopy, duration)\n      );\n\n      helper.setstyle(\n        this._drawer.element,\n        this._getdrawerstyle(nowpos, duration)\n      );\n    }, 10);\n  }\n\n  /**\n   * Return state by touch movement.\n   *\n   * @param {Array} touches Touch object array.\n   * @param {Object} time Time information on start and end of movement.\n   * @return {string} State by touch movement.\n   */\n  _gettouchmovestate(touches, time) {\n    if (time.end - time.start <= 300) {\n      let len = touches.length;\n\n      if (len >= 2) {\n        let moveinfo = this._gettouchmoveinfo(\n          touches[len - 2],\n          touches[len - 1]\n        );\n        let ish = moveinfo.axis === 'horizontal';\n        let isv = moveinfo.axis === 'vertical';\n        let ist = this._drawer.direction === 'top' && moveinfo.y >= 0;\n        let isr = this._drawer.direction === 'right' && moveinfo.x < 0;\n        let isb = this._drawer.direction === 'bottom' && moveinfo.y < 0;\n        let isl = this._drawer.direction === 'left' && moveinfo.x >= 0;\n\n        return (ish && (isr || isl)) || (isv && (isb || ist)) ?\n          'open' :\n          'close';\n      }\n    }\n\n    return this._getstatefromposition();\n  }\n\n  /**\n   * Return drawer event handler.\n   *\n   * @return {Object} Drawer event handler.\n   */\n  _getdrawerhandler() {\n    let handler = {};\n\n    handler.resize = () => {\n      this._resetdrawer();\n      this[this.state](0, false, false);\n\n      if (this._drawer.onresize) {\n        this._drawer.onresize.apply(\n          this,\n          [this._drawer]\n        );\n      }\n    };\n\n    if (this._drawer.isswipeable) {\n      for (let event of TOUCH_EVENTS) {\n        handler[event] = this._touchhandler.bind(this);\n      }\n    }\n\n    if (window.history\n      && window.history.pushState\n      && this._drawer.ishistory\n    ) {\n      handler.popstate = (e) => {\n        if (e.state && e.state.id === this._id && this.state === 'open') {\n          this.close(null, true, false);\n        }\n      };\n    }\n\n    return handler;\n  }\n\n  /**\n   * Touch event handler.\n   *\n   * @param {Event} ev Touch event object.\n   * @return {boolean} Event bubbling.\n   */\n  _touchhandler(ev) {\n    try {\n      if (ev.touches.length > 1) {\n        return true;\n      }\n\n      let touch = ev.touches[0];\n\n      if (touch) {\n        this._process.touches.push(touch);\n      }\n\n      switch (ev.type) {\n        case 'touchstart':\n          this._ontouchstart(ev);\n          break;\n        case 'touchmove':\n          this._ontouchmove(ev);\n          break;\n        case 'touchcancel':\n        case 'touchend':\n          this._ontouchfinish(ev);\n          break;\n        default:\n          break;\n      }\n    } catch (e) {\n      if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Touch start event handler.\n   *\n   * @param {Event} ev Touch event object.\n   */\n  _ontouchstart(ev) {\n    this._process.time.start = new Date().getTime();\n  }\n\n  /**\n   * Touch move event handler.\n   *\n   * @param {Event} ev Touch event object.\n   */\n  _ontouchmove(ev) {\n    let len = this._process.touches.length;\n    let isfiretouchstart = false;\n\n    if (!this._process.istouchactive && len >= 2) {\n      this._process.istouchactive = this._istouchactive(\n        this._process.touches[0]\n      );\n\n      if (this._process.istouchactive) {\n        this._showoverlay();\n        this._showdrawer();\n\n        if (this._drawer.ontouchstart) {\n          isfiretouchstart = true;\n        }\n      }\n    }\n\n    if (this._process.istouchactive) {\n      ev.stopPropagation();\n      ev.preventDefault();\n\n      this._position = this._getdrawerpositionfromtouches(\n        this._process.touches[len - 2],\n        this._process.touches[len - 1]\n      );\n\n      if (isfiretouchstart) {\n        this._drawer.ontouchstart.apply(\n          this,\n          [this._drawer, this._position]\n        );\n      }\n\n      helper.setstyle(\n        this._overlay.element,\n        this._getoverlaystyle(\n          this._getoverlayopacityfromposition(this._position),\n          0\n        )\n      );\n\n      helper.setstyle(\n        this._drawer.element,\n        this._getdrawerstyle(this._position, 0)\n      );\n\n      if (this._drawer.ontouchmove) {\n        this._drawer.ontouchmove.apply(\n          this,\n          [this._drawer, this._position]\n        );\n      }\n    }\n  }\n\n  /**\n   * Touch finish event handler.\n   *\n   * @param {Event} ev Touch event object.\n   */\n  _ontouchfinish(ev) {\n    let len = this._process.touches.length;\n\n    if (this._process.istouchactive && len >= 2) {\n      this._process.time.end = new Date().getTime();\n\n      let state = this._gettouchmovestate(\n        this._process.touches,\n        this._process.time\n      );\n\n      let changestate = this.state !== state;\n\n      this[state](null, changestate, changestate);\n\n      if (this._drawer.ontouchfinish) {\n        this._drawer.ontouchfinish.apply(\n          this,\n          [\n            this._drawer,\n            this._getdrawerpositionfromtouches(\n              this._process.touches[len - 2],\n              this._process.touches[len - 1]\n            ),\n          ]\n        );\n      }\n    }\n\n    this._process.touches = [];\n    this._process.istouchactive = false;\n    this._process.time.start = 0;\n    this._process.time.end = 0;\n  }\n\n  /**\n   * Return whether or not a valid touch.\n   *\n   * @param {number} position Moving position.\n   * @param {number} [duration=null] Drawer moving time.\n   * @param {Object} [callbacks=null] Callback objects.\n   * @param {boolean} [ischangehistory=false] Make a change in history.\n   * @return {Promise} Promise object.\n   */\n  _changestate(\n    position,\n    duration = null,\n    callbacks = null,\n    ischangehistory = true\n  ) {\n    return this._handlecallback(new Promise((resolve, reject) => {\n      try {\n        this._position = position;\n\n        let du = duration === null ? this._drawer.duration : duration;\n\n        if (this._timeoutid !== null) {\n          clearTimeout(this._timeoutid);\n          this._timeoutid = null;\n        }\n\n        let state = this._getstatefromposition();\n\n        if (state === 'open') {\n          this._showoverlay();\n          this._showdrawer();\n        } else {\n          this._overlay.element.removeEventListener('click', this._overlay.touchhandler);\n        }\n\n        if (ischangehistory\n          && this._drawer.ishistory\n          && window.history\n          && window.history.pushState\n        ) {\n          if (state === 'open') {\n            window.history.pushState({\n              id: this._id,\n            }, null, null);\n          } else {\n            window.history.back();\n          }\n        }\n\n        this[support.cssanim\n          ? '_cssanimate'\n          : '_jsanimate'](du);\n\n        this._timeoutid = setTimeout(\n          () => {\n            if (state === 'open') {\n              this._overlay.element.addEventListener('click', this._overlay.touchhandler);\n            } else {\n              this._hidedrawer();\n              this._hideoverlay();\n            }\n\n            this._timeoutid = null;\n          },\n          du\n        );\n\n        this.state = state;\n\n        if (typeof callbacks === 'object' && callbacks.onchangestate) {\n          callbacks.onchangestate.apply(\n            this,\n            [this._drawer, state]\n          );\n        }\n\n        resolve.apply(this, [this._drawer]);\n      } catch (e) {\n        reject(e);\n      }\n    }), {\n      done: typeof callbacks === 'object' && callbacks.done ? callbacks.done : null,\n      fail: typeof callbacks === 'object' && callbacks.fail ? callbacks.fail : null,\n    });\n  }\n\n  /**\n   * Return whether or not a valid touch.\n   *\n   * @param {Object} touch Start touch information.\n   * @return {boolean} Result of valid touch.\n   */\n  _istouchactive(touch) {\n    let rg = this._getrange(\n      this.state === 'open' ?\n        '100%' :\n        this._drawer.swipearea\n    );\n\n    return (rg.from.x <= touch.clientX &&\n      touch.clientX <= rg.to.x &&\n      rg.from.y <= touch.clientY &&\n      touch.clientY <= rg.to.y);\n  }\n\n  /**\n   * Return the state of the drawer.\n   *\n   * @return {string} State of the drawer.\n   */\n  _getstatefromposition() {\n    let pos = this._position === null ?\n      this._getdrawerpositionfromstyle() :\n      this._position;\n\n    return Math.abs(pos) < this._sizepixel / 2 ?\n      'open' :\n      'close';\n  }\n\n  /**\n   * Return the position of the drawer.\n   *\n   * @param {Object} touchbasis Basic touch information.\n   * @param {Object} touchlast Last touch information.\n   * @return {number} Position of the drawer.\n   */\n  _getdrawerpositionfromtouches(touchbasis, touchlast) {\n    let distance = this._getdistance(\n      this._gettouchmoveinfo(touchbasis, touchlast)\n    );\n\n    let curpos = this._position === null ?\n      this._getdrawerpositionfromstyle() :\n      this._position;\n\n    let pos = Math.round(curpos + distance);\n    let minp = this._getminposition(this._drawer);\n\n    if (pos > 0) {\n      pos = 0;\n    } else if (pos < minp) {\n      pos = minp;\n    }\n\n    return pos;\n  }\n\n  /**\n   * Return the position in the style.\n   *\n   * @return {number} Position in the style.\n   */\n  _getdrawerpositionfromstyle() {\n    let value = this._drawer.element.style[this._drawer.direction];\n    return this._normalizenumber(value).value;\n  }\n\n\n  /**\n   * Return the opacity of the overlay.\n   *\n   * @param {number} position Moving position.\n   * @return {number} Position of the drawer.\n   */\n  _getoverlayopacityfromposition(position) {\n    let minp = this._getminposition(this._drawer);\n    let posratio = 1 - (Math.abs(position) / Math.abs(minp));\n    return ((this._overlay.opacity * posratio) * 10000) / 10000;\n  }\n\n  /**\n   * Return the opacity in the style.\n   *\n   * @return {number} Opacity in the style.\n   */\n  _getoverlayopacityfromstyle() {\n    return parseFloat(this._overlay.element.style.opacity);\n  }\n\n  /**\n   * Return the swipe range.\n   *\n   * @param {string|number} value Target swipe area value.\n   * @return {Object} Drag range.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _getrange(value) {\n    let basis = this._convertpixelabs(value);\n    let width = window.innerWidth;\n    let height = window.innerHeight;\n\n    switch (this._drawer.direction) {\n      case 'top':\n        return {from: {x: 0, y: 0}, to: {x: width, y: basis}};\n      case 'right':\n        return {from: {x: basis, y: 0}, to: {x: width, y: height}};\n      case 'bottom':\n        return {from: {x: 0, y: basis}, to: {x: width, y: height}};\n      case 'left':\n        return {from: {x: 0, y: 0}, to: {x: basis, y: height}};\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return a value converted to the absolute value of the pixel.\n   *\n   * @param {string|number} value Target value.\n   * @return {number} Converted to the absolute value of the pixel.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _convertpixelabs(value) {\n    let nvalue = this._normalizepixel(value);\n\n    switch (this._drawer.direction) {\n      case 'top':\n      case 'left':\n        return nvalue;\n      case 'right':\n        return window.innerWidth - nvalue;\n      case 'bottom':\n        return window.innerHeight - nvalue;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return the normalized pixel value.\n   *\n   * @param {string|number} value Target value.\n   * @return {number} Normalized pixel value.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _normalizepixel(value) {\n    let normalized = this._normalizenumber(value);\n\n    if (normalized.unit === 'number' || normalized.unit === 'pixel') {\n      return normalized.value;\n    } else if (normalized.unit === 'percent') {\n      switch (this._drawer.direction) {\n        case 'top':\n        case 'bottom':\n          return window.innerHeight * (normalized.value / 100);\n        case 'right':\n        case 'left':\n          return window.innerWidth * (normalized.value / 100);\n        default:\n          throw new Error(`'${this._drawer.direction}' does not support`);\n      }\n    }\n  }\n\n  /**\n   * Return the numeric normalized information.\n   *\n   * @param {string|number} value Target value.\n   * @return {Object} Numeric normalized information.\n   * @throws {Error} Is thrown if value is invalid.\n   */\n  _normalizenumber(value) {\n    if (typeof value === 'number') {\n      return {value: value, unit: 'number'};\n    } else if (String(value).match(/^[.\\-0-9]+$/)) {\n      return {value: Number(value), unit: 'number'};\n    } else if (value.match(/^[.\\-0-9]+px$/)) {\n      return {value: Number(value.replace(/px$/ig, '')), unit: 'pixel'};\n    } else if (value.match(/[.\\-0-9]+%$/)) {\n      return {value: Number(value.replace(/%$/ig, '')), unit: 'percent'};\n    }\n\n    throw new Error(`'${value}' does not support`);\n  }\n\n  /**\n   * Return to the minimum position for the drawer.\n   *\n   * @return {number} Minimum position for the drawer.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _getminposition() {\n    switch (this._drawer.direction) {\n      case 'top':\n      case 'bottom':\n        return -1 * this._drawer.element.offsetHeight;\n      case 'right':\n      case 'left':\n        return -1 * this._drawer.element.offsetWidth;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return the distance of the drawer.\n   *\n   * @param {Object} moveinfo Movement information of the drawer.\n   * @return {number} Distance of the drawer.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _getdistance(moveinfo) {\n    switch (this._drawer.direction) {\n      case 'top':\n        return moveinfo.y;\n      case 'right':\n        return -1 * moveinfo.x;\n      case 'bottom':\n        return -1 * moveinfo.y;\n      case 'left':\n        return moveinfo.x;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return the information of touch move.\n   *\n   * @param {Object} touchbasis Basic touch information.\n   * @param {Object} touchlast Last touch information.\n   * @return {Object} Movement distance of the x, y direction, movement direction.\n   */\n  _gettouchmoveinfo(touchbasis, touchlast) {\n    let x = touchlast.clientX - touchbasis.clientX;\n    let y = touchlast.clientY - touchbasis.clientY;\n    let axis = Math.abs(x) >= Math.abs(y) ? 'horizontal' : 'vertical';\n\n    return {x, y, axis};\n  }\n\n  /**\n   * Return the information of touch move.\n   *\n   * @param {Promise} promise Promise instance.\n   * @param {Object} callbacks Callback function with the key to 'done', 'fail', 'always' (each optional).\n   * @return {Promise} Promise instance.\n   */\n  _handlecallback(promise, callbacks) {\n    if (!callbacks) {\n      return promise;\n    }\n\n    for (let key of Object.keys(callbacks)) {\n      let callback = callbacks[key];\n\n      if (!callback) {\n        continue;\n      }\n\n      let cb = isarray(callback) ? callback : [callback];\n      let rcb = null;\n\n      switch (key) {\n        case 'done':\n          rcb = (prom, value) => prom.then(value.bind(this));\n          break;\n        case 'fail':\n          rcb = (prom, value) => prom.catch(value.bind(this));\n          break;\n        case 'always':\n          rcb = (prom, value) => prom.then(value.bind(this), value.bind(this));\n          break;\n        default:\n          break;\n      }\n\n      if (rcb) {\n        cb.reduce(rcb, promise);\n      }\n    }\n\n    return promise;\n  }\n}\n\nmodule.exports = Highendrawer;\n\n\n\n// WEBPACK FOOTER //\n// ./src/highendrawer.js","'use strict';\n\n/**\n * Vendor prefix list.\n *\n * @type {string[]}\n */\nexport const PREFIX = ['webkit', 'moz', 'o', 'ms'];\n\n/**\n * Drawer's default css style.\n *\n * @type {Object}\n */\nexport const DRAWER_STYLE = Object.freeze({\n  display: 'block',\n  position: 'fixed',\n  overflowX: 'hidden',\n  overflowY: 'auto',\n  zIndex: -1,\n  webkitOverflowScrolling: 'touch',\n});\n\n/**\n * Overlay's default css style.\n *\n * @type {Object}\n */\nexport const OVERLAY_STYLE = Object.freeze({\n  display: 'none',\n  backgroundColor: '#000',\n  position: 'fixed',\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n  zIndex: -1,\n  opacity: 0,\n});\n\n/**\n * Css transition style.\n *\n * @type {Object}\n */\nexport const TRANSITION_STYLE = Object.freeze({\n  transform: '',\n  transitionProperty: 'transform,opacity',\n  transitionTimingFunction: 'cubic-bezier(0,0,0.25,1)',\n  transitionDuration: '0ms',\n});\n\n/**\n * Default drawer property.\n *\n * @type {Drawer}\n */\nexport const DEFAULT_DRAWER_PROPERTY = Object.freeze({\n  element: null,\n  direction: 'right',\n  size: '80%',\n  maxsize: 256,\n  isswipeable: true,\n  swipearea: '8%',\n  duration: 300,\n  zindex: 9999,\n  style: {},\n  isinitcreate: true,\n  enabledmaxwidth: -1,\n  ishistory: true,\n  overlay: null,\n  oncreate: null,\n  ondestroy: null,\n  onopen: null,\n  onclose: null,\n  onchangestate: null,\n  onresize: null,\n  ontouchstart: null,\n  ontouchmove: null,\n  ontouchfinish: null,\n  onerror: null,\n});\n\n/**\n * Default overlay property.\n *\n * @type {Overlay}\n */\nexport const DEFAULT_OVERLAY_PROPERTY = Object.freeze({\n  element: null,\n  opacity: 0.2,\n  zindex: -1,\n  autocreate: false,\n});\n\n/**\n * Default processing state object.\n *\n * @type {Object}\n */\nexport const DEFAULT_PROCESS = Object.freeze({\n  touches: [],\n  istouchactive: false,\n  time: {\n    start: 0,\n    end: 0,\n  },\n});\n\n/**\n * Touch event list.\n *\n * @type {string[]}\n */\nexport const TOUCH_EVENTS = [\n  'touchstart',\n  'touchmove',\n  'touchend',\n  'touchcancel',\n];\n\n\n\n// WEBPACK FOOTER //\n// ./src/const.js","'use strict';\n\nimport {PREFIX} from './const';\nimport {isarray, ucfirst} from './util';\n\nconst dom = window.document.createElement('div');\n\nlet currentid = 0;\nlet validstylename = {};\n\n/**\n * Generate ID.\n *\n * @return {number} ID.\n */\nexport function generateid() {\n  return ++currentid;\n}\n\n/**\n * Verify that the style is present.\n *\n * @param {string[]|string} styles Css styles.\n * @return {boolean} Result of verification.\n */\nexport function hasstyle(styles) {\n  let ss = styles;\n\n  if (!isarray(styles)) {\n    ss = [styles];\n  }\n\n  for (let style of ss) {\n    if (typeof dom.style[style] !== 'undefined') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Set the CSS style to element.\n *\n * @param {Object} element Target element object.\n * @param {Object} style Css style.\n */\nexport function setstyle(element, style) {\n  for (let name of Object.keys(style)) {\n    let vsn = validstylename[name];\n\n    if (vsn) {\n      element.style[vsn] = style[name];\n    } else if (typeof element.style[name] === 'undefined') {\n      for (let i = 0; i < 2; i++) {\n        for (let pfx of PREFIX) {\n          let namewithprefix = (i === 0 ? pfx : ucfirst(pfx)) +\n            ucfirst(name);\n\n          if (typeof element.style[namewithprefix] !== 'undefined') {\n            validstylename[name] = namewithprefix;\n            element.style[namewithprefix] = style[name];\n            break;\n          }\n        }\n      }\n    } else {\n      validstylename[name] = name;\n      element.style[name] = style[name];\n    }\n  }\n}\n\n/**\n * Unset the CSS style to element.\n *\n * @param {Object} element Target element object.\n * @param {string[]|string} styles Css styles.\n */\nexport function unsetstyle(element, styles) {\n  let style = {};\n\n  for (let name of isarray(styles) ? styles : [styles]) {\n    style[name] = '';\n  }\n\n  setstyle(element, style);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/helper.js","'use strict';\n\n/**\n * Convert the first letter to uppercase.\n *\n * @param {string} str Target character string.\n * @return {string} Converted string.\n */\nexport function ucfirst(str) {\n  return str.charAt(0).toUpperCase() + str.substr(1);\n}\n\n/**\n * Whether or not the object is an array.\n *\n * @param {any} obj Target object.\n * @return {boolean} Returns true if object is an Array.\n */\nexport function isarray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js","'use strict';\n\nimport {hasstyle} from './helper';\n\n/**\n * Browser support information.\n *\n * @type {Object}\n */\nlet sup = {};\n\nsup.transform3d = hasstyle([\n  'perspectiveProperty',\n  'webkitPerspective',\n  'mozPerspective',\n  'oPerspective',\n  'msPerspective',\n]);\n\nsup.transform = hasstyle([\n  'transformProperty',\n  'webkitTransform',\n  'mozTransform',\n  'oTransform',\n  'msTransform',\n]);\n\nsup.transition = hasstyle([\n  'transitionProperty',\n  'webkitTransitionProperty',\n  'mozTransitionProperty',\n  'oTransitionProperty',\n  'msTransitionProperty',\n]);\n\nsup.cssanim = (sup.transform3d || sup.transform) &&\n  sup.transition;\n\nsup.transrate = sup.transform3d ?\n  'translate3d' :\n  'translate';\n\n/**\n * Browser support information.\n *\n * @type {Object}\n */\nexport const support = Object.freeze(sup);\n\n\n\n// WEBPACK FOOTER //\n// ./src/support.js"],"sourceRoot":""}