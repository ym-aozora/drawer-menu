{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///highendrawer.min.js","webpack:///webpack/bootstrap b5a18f8e780aee66d587","webpack:///./src/highendrawer.js","webpack:///./src/const.js","webpack:///./src/helper.js","webpack:///./src/util.js","webpack:///./src/support.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","default","_classCallCheck","instance","Constructor","TypeError","defineProperty","value","_typeof","Symbol","iterator","constructor","_extends","assign","target","i","arguments","length","source","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","_const","_util","_helper","helper","_support","Highendrawer","drawer","_this","state","_id","generateid","_drawer","DEFAULT_DRAWER_PROPERTY","_overlay","overlay","DEFAULT_OVERLAY_PROPERTY","_timeoutid","_intervalid","_process","DEFAULT_PROCESS","_enabled","_handler","_getdrawerhandler","enabledmaxwidth","window","addEventListener","innerWidth","destroy","create","history","pushState","replaceState","initcreate","_createdrawer","_createoverlay","oncreate","apply","e","onerror","_destroydrawer","_destroyoverlay","ondestroy","duration","undefined","isfireevent","ischangehistory","_changestate","onchangestate","done","onopen","fail","_getminposition","onclose","_this2","Promise","resolve","reject","then","_this3","setstyle","element","DRAWER_STYLE","support","cssanim","TRANSITION_STYLE","_resetdrawer","keys","forEach","name","_this4","removeEventListener","unsetstyle","_this5","zindex","document","createElement","isautocreated","OVERLAY_STYLE","touchhandler","close","body","appendChild","parentNode","removeChild","isunset","_setprops","ims","_getinitdrawerstyle","zIndex","opacity","display","sizepixel","_normalizepixel","size","maxsize","maxsizepixel","_sizepixel","_position","style","direction","width","height","top","right","bottom","left","Error","position","minp","transitionDuration","transform","transrate","_getoverlaystyle","_getoverlayopacityfromposition","_getdrawerstyle","_this6","start","Date","fromopy","_getoverlayopacityfromstyle","toopy","frompos","_getdrawerpositionfromstyle","topos","clearInterval","setInterval","time","nowpos","nowopy","prp","end","len","touches","moveinfo","_gettouchmoveinfo","vertical","axis","horizontal","y","x","_getstatefromposition","_this7","handler","resize","onresize","swipeable","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","TOUCH_EVENTS","next","event","_touchhandler","bind","err","return","popstate","ev","touch","push","type","_ontouchstart","_ontouchmove","_ontouchfinish","getTime","istouchpointactive","_istouchpointactive","istouchdirectionactive","_istouchdirectionactive","isfiretouchstart","istouchactive","_showoverlay","_showdrawer","ontouchstart","stopPropagation","preventDefault","_getdrawerpositionfromtouches","ontouchmove","_gettouchmovestate","changestate","ontouchfinish","_this8","callbacks","_handlecallback","du","clearTimeout","back","setTimeout","_hidedrawer","_hideoverlay","rg","_getrange","swipearea","from","clientX","to","clientY","pos","Math","abs","touchbasis","touchlast","distance","_getdistance","curpos","round","_normalizenumber","posratio","parseFloat","basis","_convertpixelabs","innerHeight","nvalue","normalized","unit","String","match","Number","replace","offsetHeight","offsetWidth","promise","_this9","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","callback","cb","isarray","rcb","prom","catch","reduce","PREFIX","freeze","overflowX","overflowY","webkitOverflowScrolling","backgroundColor","transitionProperty","transitionTimingFunction","autocreate","currentid","hasstyle","styles","ss","dom","vsn","validstylename","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","pfx","namewithprefix","ucfirst","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","str","charAt","toUpperCase","substr","toString","sup","transform3d","transition"],"mappings":"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","file":"highendrawer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Highendrawer\"] = factory();\n\telse\n\t\troot[\"Highendrawer\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n * highendrawer - Highendrawer provides javascript and css drawers to your website and applications.\n * @version v0.0.11\n * @link https://github.com/ym-aozora/highendrawer#readme\n * @license MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Highendrawer\"] = factory();\n\telse\n\t\troot[\"Highendrawer\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _const = __webpack_require__(1);\n\t\n\tvar _util = __webpack_require__(3);\n\t\n\tvar _helper = __webpack_require__(2);\n\t\n\tvar helper = _interopRequireWildcard(_helper);\n\t\n\tvar _support = __webpack_require__(4);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Class providing a drawer function.\n\t *\n\t * @public\n\t * @class\n\t * @example\n\t * var drawer = new DrawerMenu({\n\t *   element: document.getElementById('drawer')\n\t * });\n\t */\n\tvar Highendrawer = function () {\n\t\n\t  /**\n\t   * Initialize object.\n\t   *\n\t   * @constructor\n\t   * @param {Drawer} drawer Initial parameters of drawer.\n\t   */\n\t  function Highendrawer(drawer) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Highendrawer);\n\t\n\t    /**\n\t     * Drawer status ('open' or 'close')\n\t     *\n\t     * @public\n\t     * @type {string}\n\t     */\n\t    this.state = 'close';\n\t\n\t    this._id = helper.generateid();\n\t    this._drawer = _extends({}, _const.DEFAULT_DRAWER_PROPERTY, drawer);\n\t    this._overlay = this._drawer.overlay === false ? false : _extends({}, _const.DEFAULT_OVERLAY_PROPERTY, this._drawer.overlay);\n\t    this._timeoutid = null;\n\t    this._intervalid = null;\n\t    this._process = _extends({}, _const.DEFAULT_PROCESS);\n\t    this._enabled = false;\n\t    this._handler = this._getdrawerhandler();\n\t\n\t    if (this._drawer.enabledmaxwidth > -1) {\n\t      window.addEventListener('resize', function () {\n\t        if (_this._enabled && window.innerWidth > _this._drawer.enabledmaxwidth) {\n\t          _this.destroy();\n\t        } else if (!_this._enabled && window.innerWidth <= _this._drawer.enabledmaxwidth) {\n\t          _this.create();\n\t        }\n\t      });\n\t    }\n\t\n\t    if (window.history && window.history.pushState && this._drawer.history) {\n\t      window.history.replaceState({\n\t        id: this._id\n\t      }, null, null);\n\t    }\n\t\n\t    if (this._drawer.initcreate) {\n\t      this.create();\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Create the drawer set.\n\t   *\n\t   * @public\n\t   */\n\t\n\t\n\t  _createClass(Highendrawer, [{\n\t    key: 'create',\n\t    value: function create() {\n\t      try {\n\t        this._createdrawer();\n\t        this._createoverlay();\n\t        this._enabled = true;\n\t\n\t        if (this._drawer.oncreate) {\n\t          this._drawer.oncreate.apply(this, [this._drawer]);\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Destroy the drawer set.\n\t     *\n\t     * @public\n\t     */\n\t\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy() {\n\t      try {\n\t        this._destroydrawer();\n\t        this._destroyoverlay();\n\t        this._enabled = false;\n\t\n\t        if (this._drawer.ondestroy) {\n\t          this._drawer.ondestroy.apply(this, [this._drawer]);\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Open drawer.\n\t     *\n\t     * @public\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n\t     * @param {boolean} [ischangehistory=false] Make a change in history.\n\t     * @return {Promise} Promise object for open.\n\t     */\n\t\n\t  }, {\n\t    key: 'open',\n\t    value: function open() {\n\t      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t      var isfireevent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var ischangehistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t      return this._changestate(0, duration, {\n\t        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n\t        done: isfireevent ? this._drawer.onopen : null,\n\t        fail: isfireevent ? this._drawer.onerror : null\n\t      }, ischangehistory);\n\t    }\n\t\n\t    /**\n\t     * Close drawer.\n\t     *\n\t     * @public\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n\t     * @param {boolean} [ischangehistory=false] Make a change in history.\n\t     * @return {Promise} Promise object for close.\n\t     */\n\t\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t      var isfireevent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var ischangehistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t      return this._changestate(this._getminposition(), duration, {\n\t        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n\t        done: isfireevent ? this._drawer.onclose : null,\n\t        fail: isfireevent ? this._drawer.onerror : null\n\t      }, ischangehistory);\n\t    }\n\t\n\t    /**\n\t     * Toggle drawer.\n\t     *\n\t     * @public\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n\t     * @param {boolean} [ischangehistory=false] Make a change in history.\n\t     * @return {Promise} Promise object for toggle.\n\t     */\n\t\n\t  }, {\n\t    key: 'toggle',\n\t    value: function toggle() {\n\t      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\n\t      var _this2 = this;\n\t\n\t      var isfireevent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var ischangehistory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          _this2[_this2.state === 'open' ? 'close' : 'open'](duration, isfireevent, ischangehistory).then(resolve, reject);\n\t        } catch (e) {\n\t          reject(e);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Create drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_createdrawer',\n\t    value: function _createdrawer() {\n\t      var _this3 = this;\n\t\n\t      helper.setstyle(this._drawer.element, _extends({}, _const.DRAWER_STYLE, _support.support.cssanim ? _const.TRANSITION_STYLE : {}));\n\t\n\t      this._resetdrawer();\n\t\n\t      Object.keys(this._handler).forEach(function (name) {\n\t        window.addEventListener(name, _this3._handler[name]);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Destroy drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_destroydrawer',\n\t    value: function _destroydrawer() {\n\t      var _this4 = this;\n\t\n\t      Object.keys(this._handler).forEach(function (name) {\n\t        window.removeEventListener(name, _this4._handler[name]);\n\t      });\n\t\n\t      this._resetdrawer(true);\n\t\n\t      helper.unsetstyle(this._drawer.element, Object.keys(_extends({}, _const.DRAWER_STYLE, _support.support.cssanim ? _const.TRANSITION_STYLE : {})));\n\t    }\n\t\n\t    /**\n\t     * Create overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_createoverlay',\n\t    value: function _createoverlay() {\n\t      var _this5 = this;\n\t\n\t      if (this._overlay === false) {\n\t        return;\n\t      }\n\t\n\t      if (this._overlay.zindex === -1) {\n\t        this._overlay.zindex = this._drawer.zindex - 1;\n\t      }\n\t\n\t      if (!this._overlay.element) {\n\t        this._overlay.element = window.document.createElement('div');\n\t        this._overlay.isautocreated = true;\n\t\n\t        helper.setstyle(this._overlay.element, _extends({}, _const.OVERLAY_STYLE, _support.support.cssanim ? _const.TRANSITION_STYLE : {}));\n\t      }\n\t\n\t      if (!this._overlay.touchhandler) {\n\t        this._overlay.touchhandler = function (e) {\n\t          _this5.close();\n\t        };\n\t      }\n\t\n\t      window.document.body.appendChild(this._overlay.element);\n\t    }\n\t\n\t    /**\n\t     * Destroy overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_destroyoverlay',\n\t    value: function _destroyoverlay() {\n\t      if (this._overlay === false) {\n\t        return;\n\t      }\n\t\n\t      if (this._overlay.element) {\n\t        this._overlay.element.removeEventListener('click', this._overlay.touchhandler);\n\t\n\t        if (this._overlay.isautocreated) {\n\t          this._overlay.element.parentNode.removeChild(this._overlay.element);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Reset drawer.\n\t     *\n\t     * @param {boolean} [isunset] Unset style.\n\t     */\n\t\n\t  }, {\n\t    key: '_resetdrawer',\n\t    value: function _resetdrawer() {\n\t      var isunset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t      try {\n\t        this._setprops();\n\t\n\t        var ims = this._getinitdrawerstyle();\n\t\n\t        if (isunset) {\n\t          helper.unsetstyle(this._drawer.element, Object.keys(ims));\n\t        } else {\n\t          helper.setstyle(this._drawer.element, ims);\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Show drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_showdrawer',\n\t    value: function _showdrawer() {\n\t      helper.setstyle(this._drawer.element, {\n\t        zIndex: this._drawer.zindex,\n\t        opacity: 1\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Hide drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_hidedrawer',\n\t    value: function _hidedrawer() {\n\t      helper.setstyle(this._drawer.element, {\n\t        zIndex: -1,\n\t        opacity: 0\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Show overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_showoverlay',\n\t    value: function _showoverlay() {\n\t      helper.setstyle(this._overlay.element, {\n\t        zIndex: this._overlay.zindex,\n\t        display: 'block'\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Hide overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_hideoverlay',\n\t    value: function _hideoverlay() {\n\t      helper.setstyle(this._overlay.element, {\n\t        zIndex: -1,\n\t        display: 'none'\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Set properties.\n\t     */\n\t\n\t  }, {\n\t    key: '_setprops',\n\t    value: function _setprops() {\n\t      // set sizepixel\n\t      var sizepixel = this._normalizepixel(this._drawer.size);\n\t\n\t      if (this._drawer.maxsize && this._drawer.maxsize !== -1) {\n\t        var maxsizepixel = this._normalizepixel(this._drawer.maxsize);\n\t\n\t        if (sizepixel > maxsizepixel) {\n\t          sizepixel = maxsizepixel;\n\t        }\n\t      }\n\t\n\t      this._sizepixel = sizepixel;\n\t\n\t      // set position\n\t      this._position = typeof this._position === 'undefined' ? null : this._position;\n\t    }\n\t\n\t    /**\n\t     * Return initial style of drawer.\n\t     *\n\t     * @return {Object} Style for drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getinitdrawerstyle',\n\t    value: function _getinitdrawerstyle() {\n\t      var style = null;\n\t\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t          style = {\n\t            width: '100%',\n\t            height: this._sizepixel + 'px',\n\t            top: '-' + this._sizepixel + 'px',\n\t            right: 'auto',\n\t            bottom: 'auto',\n\t            left: 0\n\t          };\n\t          break;\n\t        case 'right':\n\t          style = {\n\t            width: this._sizepixel + 'px',\n\t            height: '100%',\n\t            top: 0,\n\t            right: '-' + this._sizepixel + 'px',\n\t            bottom: 'auto',\n\t            left: 'auto'\n\t          };\n\t          break;\n\t        case 'bottom':\n\t          style = {\n\t            width: '100%',\n\t            height: this._sizepixel + 'px',\n\t            top: 'auto',\n\t            right: 'auto',\n\t            bottom: '-' + this._sizepixel + 'px',\n\t            left: 0\n\t          };\n\t          break;\n\t        case 'left':\n\t          style = {\n\t            width: this._sizepixel + 'px',\n\t            height: '100%',\n\t            top: 0,\n\t            right: 'auto',\n\t            bottom: 'auto',\n\t            left: '-' + this._sizepixel + 'px'\n\t          };\n\t          break;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t\n\t      return _extends(style, this._drawer.style || {});\n\t    }\n\t\n\t    /**\n\t     * Return style for moving the drawer.\n\t     *\n\t     * @param {number} position Moving position.\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @return {Object} Move style for drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerstyle',\n\t    value: function _getdrawerstyle(position) {\n\t      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var minp = this._getminposition(this._drawer);\n\t      var style = {};\n\t\n\t      if (_support.support.cssanim) {\n\t        style.transitionDuration = (duration === null ? this._drawer.duration : duration) + 'ms';\n\t\n\t        switch (this._drawer.direction) {\n\t          case 'top':\n\t            style.transform = _support.support.transrate + '(0,' + -(minp - position) + 'px,0)';\n\t            break;\n\t          case 'right':\n\t            style.transform = _support.support.transrate + '(' + (minp - position) + 'px,0,0)';\n\t            break;\n\t          case 'bottom':\n\t            style.transform = _support.support.transrate + '(0,' + (minp - position) + 'px,0)';\n\t            break;\n\t          case 'left':\n\t            style.transform = _support.support.transrate + '(' + -(minp - position) + 'px,0,0)';\n\t            break;\n\t          default:\n\t            throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t        }\n\t      } else {\n\t        style[this._drawer.direction] = position + 'px';\n\t      }\n\t\n\t      return style;\n\t    }\n\t\n\t    /**\n\t     * Return style for moving the overlay.\n\t     *\n\t     * @param {float} opacity Overlay opacity.\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @return {Object} Move style for overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_getoverlaystyle',\n\t    value: function _getoverlaystyle(opacity) {\n\t      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var style = {\n\t        opacity: opacity\n\t      };\n\t\n\t      if (_support.support.cssanim) {\n\t        style.transitionDuration = (duration === null ? this._drawer.duration : duration) + 'ms';\n\t      }\n\t\n\t      return style;\n\t    }\n\t\n\t    /**\n\t     * Make animation with CSS3.\n\t     *\n\t     * @param {number} duration Drawer moving time.\n\t     */\n\t\n\t  }, {\n\t    key: '_cssanimate',\n\t    value: function _cssanimate(duration) {\n\t      helper.setstyle(this._overlay.element, this._getoverlaystyle(this._getoverlayopacityfromposition(this._position), duration));\n\t\n\t      helper.setstyle(this._drawer.element, this._getdrawerstyle(this._position, duration));\n\t    }\n\t\n\t    /**\n\t     * Make animation with Javascript.\n\t     *\n\t     * @param {number} duration Drawer moving time.\n\t     */\n\t\n\t  }, {\n\t    key: '_jsanimate',\n\t    value: function _jsanimate(duration) {\n\t      var _this6 = this;\n\t\n\t      var start = +new Date();\n\t      var fromopy = this._getoverlayopacityfromstyle();\n\t      var toopy = this._getoverlayopacityfromposition(this._position);\n\t      var frompos = this._getdrawerpositionfromstyle();\n\t      var topos = this._position;\n\t\n\t      if (this._intervalid) {\n\t        clearInterval(this._intervalid);\n\t      }\n\t\n\t      this._intervalid = setInterval(function () {\n\t        var time = new Date() - start;\n\t        var nowpos = null;\n\t        var nowopy = null;\n\t\n\t        if (time > duration) {\n\t          clearInterval(_this6._intervalid);\n\t          _this6._intervalid = null;\n\t          nowopy = toopy;\n\t          nowpos = topos;\n\t        } else {\n\t          var prp = (time /= duration) * (time - 2);\n\t          nowopy = fromopy - (toopy - fromopy) * prp;\n\t          nowpos = frompos - (topos - frompos) * prp;\n\t        }\n\t\n\t        helper.setstyle(_this6._overlay.element, _this6._getoverlaystyle(nowopy, duration));\n\t\n\t        helper.setstyle(_this6._drawer.element, _this6._getdrawerstyle(nowpos, duration));\n\t      }, 10);\n\t    }\n\t\n\t    /**\n\t     * Return state by touch movement.\n\t     *\n\t     * @return {string} State by touch movement.\n\t     */\n\t\n\t  }, {\n\t    key: '_gettouchmovestate',\n\t    value: function _gettouchmovestate() {\n\t      if (this._process.time.end - this._process.time.start <= 300) {\n\t        var len = this._process.touches.length;\n\t        var moveinfo = this._gettouchmoveinfo(this._process.touches[len - 2], this._process.touches[len - 1]);\n\t        var vertical = moveinfo.axis === 'vertical';\n\t        var horizontal = moveinfo.axis === 'horizontal';\n\t        var top = this._drawer.direction === 'top' && moveinfo.y >= 0;\n\t        var right = this._drawer.direction === 'right' && moveinfo.x < 0;\n\t        var bottom = this._drawer.direction === 'bottom' && moveinfo.y < 0;\n\t        var left = this._drawer.direction === 'left' && moveinfo.x >= 0;\n\t\n\t        return vertical && (bottom || top) || horizontal && (right || left) ? 'open' : 'close';\n\t      }\n\t\n\t      return this._getstatefromposition();\n\t    }\n\t\n\t    /**\n\t     * Return drawer event handler.\n\t     *\n\t     * @return {Object} Drawer event handler.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerhandler',\n\t    value: function _getdrawerhandler() {\n\t      var _this7 = this;\n\t\n\t      var handler = {};\n\t\n\t      handler.resize = function () {\n\t        _this7._resetdrawer();\n\t        _this7[_this7.state](0, false, false);\n\t\n\t        if (_this7._drawer.onresize) {\n\t          _this7._drawer.onresize.apply(_this7, [_this7._drawer]);\n\t        }\n\t      };\n\t\n\t      if (this._drawer.swipeable) {\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t          for (var _iterator = _const.TOUCH_EVENTS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var event = _step.value;\n\t\n\t            handler[event] = this._touchhandler.bind(this);\n\t          }\n\t        } catch (err) {\n\t          _didIteratorError = true;\n\t          _iteratorError = err;\n\t        } finally {\n\t          try {\n\t            if (!_iteratorNormalCompletion && _iterator.return) {\n\t              _iterator.return();\n\t            }\n\t          } finally {\n\t            if (_didIteratorError) {\n\t              throw _iteratorError;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      if (window.history && window.history.pushState && this._drawer.history) {\n\t        handler.popstate = function (e) {\n\t          if (e.state && e.state.id === _this7._id && _this7.state === 'open') {\n\t            _this7.close(null, true, false);\n\t          }\n\t        };\n\t      }\n\t\n\t      return handler;\n\t    }\n\t\n\t    /**\n\t     * Touch event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     * @return {boolean} Event bubbling.\n\t     */\n\t\n\t  }, {\n\t    key: '_touchhandler',\n\t    value: function _touchhandler(ev) {\n\t      try {\n\t        if (ev.touches.length > 1) {\n\t          return true;\n\t        }\n\t\n\t        var touch = ev.touches[0];\n\t\n\t        if (touch) {\n\t          this._process.touches.push(touch);\n\t        }\n\t\n\t        switch (ev.type) {\n\t          case 'touchstart':\n\t            this._ontouchstart(ev);\n\t            break;\n\t          case 'touchmove':\n\t            this._ontouchmove(ev);\n\t            break;\n\t          case 'touchcancel':\n\t          case 'touchend':\n\t            this._ontouchfinish(ev);\n\t            break;\n\t          default:\n\t            break;\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * Touch start event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     */\n\t\n\t  }, {\n\t    key: '_ontouchstart',\n\t    value: function _ontouchstart(ev) {\n\t      this._process.time.start = new Date().getTime();\n\t    }\n\t\n\t    /**\n\t     * Touch move event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     */\n\t\n\t  }, {\n\t    key: '_ontouchmove',\n\t    value: function _ontouchmove(ev) {\n\t      var len = this._process.touches.length;\n\t\n\t      if (len < 2) {\n\t        return;\n\t      }\n\t\n\t      if (!this._process.istouchpointactive) {\n\t        this._process.istouchpointactive = this._istouchpointactive();\n\t      }\n\t\n\t      if (!this._process.istouchpointactive) {\n\t        return;\n\t      }\n\t\n\t      if (this._process.istouchdirectionactive === null) {\n\t        this._process.istouchdirectionactive = this._istouchdirectionactive();\n\t      }\n\t\n\t      if (!this._process.istouchdirectionactive) {\n\t        return;\n\t      }\n\t\n\t      var isfiretouchstart = false;\n\t      var istouchactive = this._process.istouchpointactive && this._process.istouchdirectionactive;\n\t\n\t      if (!istouchactive) {\n\t        return;\n\t      }\n\t\n\t      if (!this._process.istouchactive) {\n\t        this._process.istouchactive = istouchactive;\n\t        this._showoverlay();\n\t        this._showdrawer();\n\t\n\t        if (this._drawer.ontouchstart) {\n\t          isfiretouchstart = true;\n\t        }\n\t      }\n\t\n\t      ev.stopPropagation();\n\t      ev.preventDefault();\n\t\n\t      this._position = this._getdrawerpositionfromtouches(this._process.touches[len - 2], this._process.touches[len - 1]);\n\t\n\t      if (isfiretouchstart) {\n\t        this._drawer.ontouchstart.apply(this, [this._drawer, this._position]);\n\t      }\n\t\n\t      helper.setstyle(this._overlay.element, this._getoverlaystyle(this._getoverlayopacityfromposition(this._position), 0));\n\t\n\t      helper.setstyle(this._drawer.element, this._getdrawerstyle(this._position, 0));\n\t\n\t      if (this._drawer.ontouchmove) {\n\t        this._drawer.ontouchmove.apply(this, [this._drawer, this._position]);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Touch finish event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     */\n\t\n\t  }, {\n\t    key: '_ontouchfinish',\n\t    value: function _ontouchfinish(ev) {\n\t      var len = this._process.touches.length;\n\t\n\t      if (this._process.istouchactive && len >= 2) {\n\t        this._process.time.end = new Date().getTime();\n\t\n\t        var state = this._gettouchmovestate();\n\t        var changestate = this.state !== state;\n\t\n\t        this[state](null, changestate, changestate);\n\t\n\t        if (this._drawer.ontouchfinish) {\n\t          this._drawer.ontouchfinish.apply(this, [this._drawer, this._getdrawerpositionfromtouches(this._process.touches[len - 2], this._process.touches[len - 1])]);\n\t        }\n\t      }\n\t\n\t      this._process.touches = [];\n\t      this._process.istouchactive = null;\n\t      this._process.istouchpointactive = null;\n\t      this._process.istouchdirectionactive = null;\n\t      this._process.time.start = 0;\n\t      this._process.time.end = 0;\n\t    }\n\t\n\t    /**\n\t     * Return whether or not a valid touch.\n\t     *\n\t     * @param {number} position Moving position.\n\t     * @param {number} [duration=null] Drawer moving time.\n\t     * @param {Object} [callbacks=null] Callback objects.\n\t     * @param {boolean} [ischangehistory=false] Make a change in history.\n\t     * @return {Promise} Promise object.\n\t     */\n\t\n\t  }, {\n\t    key: '_changestate',\n\t    value: function _changestate(position) {\n\t      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var _this8 = this;\n\t\n\t      var callbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t      var ischangehistory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\t\n\t      return this._handlecallback(new Promise(function (resolve, reject) {\n\t        try {\n\t          (function () {\n\t            _this8._position = position;\n\t\n\t            var du = duration === null ? _this8._drawer.duration : duration;\n\t\n\t            if (_this8._timeoutid !== null) {\n\t              clearTimeout(_this8._timeoutid);\n\t              _this8._timeoutid = null;\n\t            }\n\t\n\t            var state = _this8._getstatefromposition();\n\t\n\t            if (state === 'open') {\n\t              _this8._showoverlay();\n\t              _this8._showdrawer();\n\t            } else {\n\t              _this8._overlay.element.removeEventListener('click', _this8._overlay.touchhandler);\n\t            }\n\t\n\t            if (ischangehistory && _this8._drawer.history && window.history && window.history.pushState) {\n\t              if (state === 'open') {\n\t                window.history.pushState({\n\t                  id: _this8._id\n\t                }, null, null);\n\t              } else {\n\t                window.history.back();\n\t              }\n\t            }\n\t\n\t            _this8[_support.support.cssanim ? '_cssanimate' : '_jsanimate'](du);\n\t\n\t            _this8._timeoutid = setTimeout(function () {\n\t              if (state === 'open') {\n\t                _this8._overlay.element.addEventListener('click', _this8._overlay.touchhandler);\n\t              } else {\n\t                _this8._hidedrawer();\n\t                _this8._hideoverlay();\n\t              }\n\t\n\t              _this8._timeoutid = null;\n\t            }, du);\n\t\n\t            _this8.state = state;\n\t\n\t            if ((typeof callbacks === 'undefined' ? 'undefined' : _typeof(callbacks)) === 'object' && callbacks.onchangestate) {\n\t              callbacks.onchangestate.apply(_this8, [_this8._drawer, state]);\n\t            }\n\t\n\t            resolve.apply(_this8, [_this8._drawer]);\n\t          })();\n\t        } catch (e) {\n\t          reject(e);\n\t        }\n\t      }), {\n\t        done: (typeof callbacks === 'undefined' ? 'undefined' : _typeof(callbacks)) === 'object' && callbacks.done ? callbacks.done : null,\n\t        fail: (typeof callbacks === 'undefined' ? 'undefined' : _typeof(callbacks)) === 'object' && callbacks.fail ? callbacks.fail : null\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Return whether or not a valid touch point.\n\t     *\n\t     * @return {boolean} Result of valid touch point.\n\t     */\n\t\n\t  }, {\n\t    key: '_istouchpointactive',\n\t    value: function _istouchpointactive() {\n\t      var rg = this._getrange(this.state === 'open' ? this._sizepixel : this._drawer.swipearea);\n\t      var len = this._process.touches.length;\n\t\n\t      return rg.from.x <= this._process.touches[len - 2].clientX && this._process.touches[len - 2].clientX <= rg.to.x && rg.from.y <= this._process.touches[len - 2].clientY && this._process.touches[len - 2].clientY <= rg.to.y;\n\t    }\n\t\n\t    /**\n\t     * Return whether or not a valid touch direction.\n\t     *\n\t     * @return {boolean} Result of valid touch direction.\n\t     */\n\t\n\t  }, {\n\t    key: '_istouchdirectionactive',\n\t    value: function _istouchdirectionactive() {\n\t      var len = this._process.touches.length;\n\t      var moveinfo = this._gettouchmoveinfo(this._process.touches[len - 2], this._process.touches[len - 1]);\n\t      var vertical = moveinfo.axis === 'vertical';\n\t      var horizontal = moveinfo.axis === 'horizontal';\n\t\n\t      if (!(vertical && (this._drawer.direction === 'top' || this._drawer.direction === 'bottom') || horizontal && (this._drawer.direction === 'right' || this._drawer.direction === 'left'))) {\n\t        return false;\n\t      }\n\t\n\t      return this.state === 'open' && (this._drawer.direction === 'top' && moveinfo.y < 0 || this._drawer.direction === 'right' && moveinfo.x >= 0 || this._drawer.direction === 'bottom' && moveinfo.y >= 0 || this._drawer.direction === 'left' && moveinfo.x < 0) || this.state === 'close' && (this._drawer.direction === 'top' && moveinfo.y >= 0 || this._drawer.direction === 'right' && moveinfo.x < 0 || this._drawer.direction === 'bottom' && moveinfo.y < 0 || this._drawer.direction === 'left' && moveinfo.x >= 0);\n\t    }\n\t\n\t    /**\n\t     * Return the state of the drawer.\n\t     *\n\t     * @return {string} State of the drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getstatefromposition',\n\t    value: function _getstatefromposition() {\n\t      var pos = this._position === null ? this._getdrawerpositionfromstyle() : this._position;\n\t\n\t      return Math.abs(pos) < this._sizepixel / 2 ? 'open' : 'close';\n\t    }\n\t\n\t    /**\n\t     * Return the position of the drawer.\n\t     *\n\t     * @param {Object} touchbasis Basic touch information.\n\t     * @param {Object} touchlast Last touch information.\n\t     * @return {number} Position of the drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerpositionfromtouches',\n\t    value: function _getdrawerpositionfromtouches(touchbasis, touchlast) {\n\t      var distance = this._getdistance(this._gettouchmoveinfo(touchbasis, touchlast));\n\t\n\t      var curpos = this._position === null ? this._getdrawerpositionfromstyle() : this._position;\n\t\n\t      var pos = Math.round(curpos + distance);\n\t      var minp = this._getminposition(this._drawer);\n\t\n\t      if (pos > 0) {\n\t        pos = 0;\n\t      } else if (pos < minp) {\n\t        pos = minp;\n\t      }\n\t\n\t      return pos;\n\t    }\n\t\n\t    /**\n\t     * Return the position in the style.\n\t     *\n\t     * @return {number} Position in the style.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerpositionfromstyle',\n\t    value: function _getdrawerpositionfromstyle() {\n\t      var value = this._drawer.element.style[this._drawer.direction];\n\t      return this._normalizenumber(value).value;\n\t    }\n\t\n\t    /**\n\t     * Return the opacity of the overlay.\n\t     *\n\t     * @param {number} position Moving position.\n\t     * @return {number} Position of the drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getoverlayopacityfromposition',\n\t    value: function _getoverlayopacityfromposition(position) {\n\t      var minp = this._getminposition(this._drawer);\n\t      var posratio = 1 - Math.abs(position) / Math.abs(minp);\n\t      return this._overlay.opacity * posratio * 10000 / 10000;\n\t    }\n\t\n\t    /**\n\t     * Return the opacity in the style.\n\t     *\n\t     * @return {number} Opacity in the style.\n\t     */\n\t\n\t  }, {\n\t    key: '_getoverlayopacityfromstyle',\n\t    value: function _getoverlayopacityfromstyle() {\n\t      return parseFloat(this._overlay.element.style.opacity);\n\t    }\n\t\n\t    /**\n\t     * Return the swipe range.\n\t     *\n\t     * @param {string|number} value Target swipe area value.\n\t     * @return {Object} Drag range.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_getrange',\n\t    value: function _getrange(value) {\n\t      var basis = this._convertpixelabs(value);\n\t      var width = window.innerWidth;\n\t      var height = window.innerHeight;\n\t\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t          return { from: { x: 0, y: 0 }, to: { x: width, y: basis } };\n\t        case 'right':\n\t          return { from: { x: basis, y: 0 }, to: { x: width, y: height } };\n\t        case 'bottom':\n\t          return { from: { x: 0, y: basis }, to: { x: width, y: height } };\n\t        case 'left':\n\t          return { from: { x: 0, y: 0 }, to: { x: basis, y: height } };\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return a value converted to the absolute value of the pixel.\n\t     *\n\t     * @param {string|number} value Target value.\n\t     * @return {number} Converted to the absolute value of the pixel.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_convertpixelabs',\n\t    value: function _convertpixelabs(value) {\n\t      var nvalue = this._normalizepixel(value);\n\t\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t        case 'left':\n\t          return nvalue;\n\t        case 'right':\n\t          return window.innerWidth - nvalue;\n\t        case 'bottom':\n\t          return window.innerHeight - nvalue;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the normalized pixel value.\n\t     *\n\t     * @param {string|number} value Target value.\n\t     * @return {number} Normalized pixel value.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_normalizepixel',\n\t    value: function _normalizepixel(value) {\n\t      var normalized = this._normalizenumber(value);\n\t\n\t      if (normalized.unit === 'number' || normalized.unit === 'pixel') {\n\t        return normalized.value;\n\t      } else if (normalized.unit === 'percent') {\n\t        switch (this._drawer.direction) {\n\t          case 'top':\n\t          case 'bottom':\n\t            return window.innerHeight * (normalized.value / 100);\n\t          case 'right':\n\t          case 'left':\n\t            return window.innerWidth * (normalized.value / 100);\n\t          default:\n\t            throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the numeric normalized information.\n\t     *\n\t     * @param {string|number} value Target value.\n\t     * @return {Object} Numeric normalized information.\n\t     * @throws {Error} Is thrown if value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_normalizenumber',\n\t    value: function _normalizenumber(value) {\n\t      if (typeof value === 'number') {\n\t        return { value: value, unit: 'number' };\n\t      } else if (String(value).match(/^[.\\-0-9]+$/)) {\n\t        return { value: Number(value), unit: 'number' };\n\t      } else if (value.match(/^[.\\-0-9]+px$/)) {\n\t        return { value: Number(value.replace(/px$/ig, '')), unit: 'pixel' };\n\t      } else if (value.match(/[.\\-0-9]+%$/)) {\n\t        return { value: Number(value.replace(/%$/ig, '')), unit: 'percent' };\n\t      }\n\t\n\t      throw new Error('\\'' + value + '\\' does not support');\n\t    }\n\t\n\t    /**\n\t     * Return to the minimum position for the drawer.\n\t     *\n\t     * @return {number} Minimum position for the drawer.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_getminposition',\n\t    value: function _getminposition() {\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t        case 'bottom':\n\t          return -1 * this._drawer.element.offsetHeight;\n\t        case 'right':\n\t        case 'left':\n\t          return -1 * this._drawer.element.offsetWidth;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the distance of the drawer.\n\t     *\n\t     * @param {Object} moveinfo Movement information of the drawer.\n\t     * @return {number} Distance of the drawer.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdistance',\n\t    value: function _getdistance(moveinfo) {\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t          return moveinfo.y;\n\t        case 'right':\n\t          return -1 * moveinfo.x;\n\t        case 'bottom':\n\t          return -1 * moveinfo.y;\n\t        case 'left':\n\t          return moveinfo.x;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the information of touch move.\n\t     *\n\t     * @param {Object} touchbasis Basic touch information.\n\t     * @param {Object} touchlast Last touch information.\n\t     * @return {Object} Movement distance of the x, y direction, movement direction.\n\t     */\n\t\n\t  }, {\n\t    key: '_gettouchmoveinfo',\n\t    value: function _gettouchmoveinfo(touchbasis, touchlast) {\n\t      var x = touchlast.clientX - touchbasis.clientX;\n\t      var y = touchlast.clientY - touchbasis.clientY;\n\t      var axis = Math.abs(x) >= Math.abs(y) ? 'horizontal' : 'vertical';\n\t\n\t      return { x: x, y: y, axis: axis };\n\t    }\n\t\n\t    /**\n\t     * Return the information of touch move.\n\t     *\n\t     * @param {Promise} promise Promise instance.\n\t     * @param {Object} callbacks Callback function with the key to 'done', 'fail', 'always' (each optional).\n\t     * @return {Promise} Promise instance.\n\t     */\n\t\n\t  }, {\n\t    key: '_handlecallback',\n\t    value: function _handlecallback(promise, callbacks) {\n\t      var _this9 = this;\n\t\n\t      if (!callbacks) {\n\t        return promise;\n\t      }\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = Object.keys(callbacks)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var key = _step2.value;\n\t\n\t          var callback = callbacks[key];\n\t\n\t          if (!callback) {\n\t            continue;\n\t          }\n\t\n\t          var cb = (0, _util.isarray)(callback) ? callback : [callback];\n\t          var rcb = null;\n\t\n\t          switch (key) {\n\t            case 'done':\n\t              rcb = function rcb(prom, value) {\n\t                return prom.then(value.bind(_this9));\n\t              };\n\t              break;\n\t            case 'fail':\n\t              rcb = function rcb(prom, value) {\n\t                return prom.catch(value.bind(_this9));\n\t              };\n\t              break;\n\t            case 'always':\n\t              rcb = function rcb(prom, value) {\n\t                return prom.then(value.bind(_this9), value.bind(_this9));\n\t              };\n\t              break;\n\t            default:\n\t              break;\n\t          }\n\t\n\t          if (rcb) {\n\t            cb.reduce(rcb, promise);\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      return promise;\n\t    }\n\t  }]);\n\t\n\t  return Highendrawer;\n\t}();\n\t\n\texports.default = Highendrawer;\n\t\n\t\n\tmodule.exports = Highendrawer;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Vendor prefix list.\n\t *\n\t * @type {string[]}\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar PREFIX = exports.PREFIX = ['webkit', 'moz', 'o', 'ms'];\n\t\n\t/**\n\t * Drawer's default css style.\n\t *\n\t * @type {Object}\n\t */\n\tvar DRAWER_STYLE = exports.DRAWER_STYLE = Object.freeze({\n\t  display: 'block',\n\t  position: 'fixed',\n\t  overflowX: 'hidden',\n\t  overflowY: 'auto',\n\t  zIndex: -1,\n\t  opacity: 0,\n\t  webkitOverflowScrolling: 'touch'\n\t});\n\t\n\t/**\n\t * Overlay's default css style.\n\t *\n\t * @type {Object}\n\t */\n\tvar OVERLAY_STYLE = exports.OVERLAY_STYLE = Object.freeze({\n\t  display: 'none',\n\t  backgroundColor: '#000',\n\t  position: 'fixed',\n\t  top: 0,\n\t  right: 0,\n\t  bottom: 0,\n\t  left: 0,\n\t  zIndex: -1,\n\t  opacity: 0\n\t});\n\t\n\t/**\n\t * Css transition style.\n\t *\n\t * @type {Object}\n\t */\n\tvar TRANSITION_STYLE = exports.TRANSITION_STYLE = Object.freeze({\n\t  transform: '',\n\t  transitionProperty: 'transform,opacity',\n\t  transitionTimingFunction: 'cubic-bezier(0,0,0.25,1)',\n\t  transitionDuration: '0ms'\n\t});\n\t\n\t/**\n\t * Default drawer property.\n\t *\n\t * @type {Drawer}\n\t */\n\tvar DEFAULT_DRAWER_PROPERTY = exports.DEFAULT_DRAWER_PROPERTY = Object.freeze({\n\t  element: null,\n\t  direction: 'right',\n\t  size: '80%',\n\t  maxsize: -1,\n\t  swipeable: true,\n\t  swipearea: 20,\n\t  duration: 300,\n\t  zindex: 9999,\n\t  style: {},\n\t  initcreate: true,\n\t  enabledmaxwidth: -1,\n\t  history: true,\n\t  overlay: null,\n\t  oncreate: null,\n\t  ondestroy: null,\n\t  onopen: null,\n\t  onclose: null,\n\t  onchangestate: null,\n\t  onresize: null,\n\t  ontouchstart: null,\n\t  ontouchmove: null,\n\t  ontouchfinish: null,\n\t  onerror: null\n\t});\n\t\n\t/**\n\t * Default overlay property.\n\t *\n\t * @type {Overlay}\n\t */\n\tvar DEFAULT_OVERLAY_PROPERTY = exports.DEFAULT_OVERLAY_PROPERTY = Object.freeze({\n\t  element: null,\n\t  opacity: 0.2,\n\t  zindex: -1,\n\t  autocreate: false\n\t});\n\t\n\t/**\n\t * Default processing state object.\n\t *\n\t * @type {Object}\n\t */\n\tvar DEFAULT_PROCESS = exports.DEFAULT_PROCESS = Object.freeze({\n\t  touches: [],\n\t  istouchactive: null,\n\t  istouchpointactive: null,\n\t  istouchdirectionactive: null,\n\t  time: {\n\t    start: 0,\n\t    end: 0\n\t  }\n\t});\n\t\n\t/**\n\t * Touch event list.\n\t *\n\t * @type {string[]}\n\t */\n\tvar TOUCH_EVENTS = exports.TOUCH_EVENTS = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.generateid = generateid;\n\texports.hasstyle = hasstyle;\n\texports.setstyle = setstyle;\n\texports.unsetstyle = unsetstyle;\n\t\n\tvar _const = __webpack_require__(1);\n\t\n\tvar _util = __webpack_require__(3);\n\t\n\tvar dom = window.document.createElement('div');\n\t\n\tvar currentid = 0;\n\tvar validstylename = {};\n\t\n\t/**\n\t * Generate ID.\n\t *\n\t * @return {number} ID.\n\t */\n\tfunction generateid() {\n\t  return ++currentid;\n\t}\n\t\n\t/**\n\t * Verify that the style is present.\n\t *\n\t * @param {string[]|string} styles Css styles.\n\t * @return {boolean} Result of verification.\n\t */\n\tfunction hasstyle(styles) {\n\t  var ss = styles;\n\t\n\t  if (!(0, _util.isarray)(styles)) {\n\t    ss = [styles];\n\t  }\n\t\n\t  var _iteratorNormalCompletion = true;\n\t  var _didIteratorError = false;\n\t  var _iteratorError = undefined;\n\t\n\t  try {\n\t    for (var _iterator = ss[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t      var style = _step.value;\n\t\n\t      if (typeof dom.style[style] !== 'undefined') {\n\t        return true;\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError = true;\n\t    _iteratorError = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion && _iterator.return) {\n\t        _iterator.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError) {\n\t        throw _iteratorError;\n\t      }\n\t    }\n\t  }\n\t\n\t  return false;\n\t}\n\t\n\t/**\n\t * Set the CSS style to element.\n\t *\n\t * @param {Object} element Target element object.\n\t * @param {Object} style Css style.\n\t */\n\tfunction setstyle(element, style) {\n\t  var _iteratorNormalCompletion2 = true;\n\t  var _didIteratorError2 = false;\n\t  var _iteratorError2 = undefined;\n\t\n\t  try {\n\t    for (var _iterator2 = Object.keys(style)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t      var name = _step2.value;\n\t\n\t      var vsn = validstylename[name];\n\t\n\t      if (vsn) {\n\t        element.style[vsn] = style[name];\n\t      } else if (typeof element.style[name] === 'undefined') {\n\t        for (var i = 0; i < 2; i++) {\n\t          var _iteratorNormalCompletion3 = true;\n\t          var _didIteratorError3 = false;\n\t          var _iteratorError3 = undefined;\n\t\n\t          try {\n\t            for (var _iterator3 = _const.PREFIX[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t              var pfx = _step3.value;\n\t\n\t              var namewithprefix = (i === 0 ? pfx : (0, _util.ucfirst)(pfx)) + (0, _util.ucfirst)(name);\n\t\n\t              if (typeof element.style[namewithprefix] !== 'undefined') {\n\t                validstylename[name] = namewithprefix;\n\t                element.style[namewithprefix] = style[name];\n\t                break;\n\t              }\n\t            }\n\t          } catch (err) {\n\t            _didIteratorError3 = true;\n\t            _iteratorError3 = err;\n\t          } finally {\n\t            try {\n\t              if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                _iterator3.return();\n\t              }\n\t            } finally {\n\t              if (_didIteratorError3) {\n\t                throw _iteratorError3;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        validstylename[name] = name;\n\t        element.style[name] = style[name];\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError2 = true;\n\t    _iteratorError2 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t        _iterator2.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError2) {\n\t        throw _iteratorError2;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Unset the CSS style to element.\n\t *\n\t * @param {Object} element Target element object.\n\t * @param {string[]|string} styles Css styles.\n\t */\n\tfunction unsetstyle(element, styles) {\n\t  var style = {};\n\t\n\t  var _iteratorNormalCompletion4 = true;\n\t  var _didIteratorError4 = false;\n\t  var _iteratorError4 = undefined;\n\t\n\t  try {\n\t    for (var _iterator4 = ((0, _util.isarray)(styles) ? styles : [styles])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t      var name = _step4.value;\n\t\n\t      style[name] = '';\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError4 = true;\n\t    _iteratorError4 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t        _iterator4.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError4) {\n\t        throw _iteratorError4;\n\t      }\n\t    }\n\t  }\n\t\n\t  setstyle(element, style);\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Convert the first letter to uppercase.\n\t *\n\t * @param {string} str Target character string.\n\t * @return {string} Converted string.\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.ucfirst = ucfirst;\n\texports.isarray = isarray;\n\tfunction ucfirst(str) {\n\t  return str.charAt(0).toUpperCase() + str.substr(1);\n\t}\n\t\n\t/**\n\t * Whether or not the object is an array.\n\t *\n\t * @param {any} obj Target object.\n\t * @return {boolean} Returns true if object is an Array.\n\t */\n\tfunction isarray(obj) {\n\t  return Object.prototype.toString.call(obj) === '[object Array]';\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.support = undefined;\n\t\n\tvar _helper = __webpack_require__(2);\n\t\n\t/**\n\t * Browser support information.\n\t *\n\t * @type {Object}\n\t */\n\tvar sup = {};\n\t\n\tsup.transform3d = (0, _helper.hasstyle)(['perspectiveProperty', 'webkitPerspective', 'mozPerspective', 'oPerspective', 'msPerspective']);\n\t\n\tsup.transform = (0, _helper.hasstyle)(['transformProperty', 'webkitTransform', 'mozTransform', 'oTransform', 'msTransform']);\n\t\n\tsup.transition = (0, _helper.hasstyle)(['transitionProperty', 'webkitTransitionProperty', 'mozTransitionProperty', 'oTransitionProperty', 'msTransitionProperty']);\n\t\n\tsup.cssanim = (sup.transform3d || sup.transform) && sup.transition;\n\t\n\tsup.transrate = sup.transform3d ? 'translate3d' : 'translate';\n\t\n\t/**\n\t * Browser support information.\n\t *\n\t * @type {Object}\n\t */\n\tvar support = exports.support = Object.freeze(sup);\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// highendrawer.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b5a18f8e780aee66d587","'use strict';\n\nimport {\n  DEFAULT_DRAWER_PROPERTY,\n  DEFAULT_OVERLAY_PROPERTY,\n  DEFAULT_PROCESS,\n  DRAWER_STYLE,\n  OVERLAY_STYLE,\n  TOUCH_EVENTS,\n  TRANSITION_STYLE,\n} from './const';\n\nimport {isarray} from './util';\nimport * as helper from './helper';\nimport {support} from './support';\n\n/**\n * Class providing a drawer function.\n *\n * @public\n * @class\n * @example\n * var drawer = new DrawerMenu({\n *   element: document.getElementById('drawer')\n * });\n */\nexport default class Highendrawer {\n\n  /**\n   * Initialize object.\n   *\n   * @constructor\n   * @param {Drawer} drawer Initial parameters of drawer.\n   */\n  constructor(drawer) {\n    /**\n     * Drawer status ('open' or 'close')\n     *\n     * @public\n     * @type {string}\n     */\n    this.state = 'close';\n\n    this._id = helper.generateid();\n    this._drawer = Object.assign({}, DEFAULT_DRAWER_PROPERTY, drawer);\n    this._overlay = this._drawer.overlay === false ?\n      false :\n      Object.assign({}, DEFAULT_OVERLAY_PROPERTY, this._drawer.overlay);\n    this._timeoutid = null;\n    this._intervalid = null;\n    this._process = Object.assign({}, DEFAULT_PROCESS);\n    this._enabled = false;\n    this._handler = this._getdrawerhandler();\n\n    if (this._drawer.enabledmaxwidth > -1) {\n      window.addEventListener('resize', () => {\n        if (this._enabled\n          && window.innerWidth > this._drawer.enabledmaxwidth) {\n          this.destroy();\n        } else if (!this._enabled\n          && window.innerWidth <= this._drawer.enabledmaxwidth) {\n          this.create();\n        }\n      });\n    }\n\n    if (window.history\n      && window.history.pushState\n      && this._drawer.history\n    ) {\n      window.history.replaceState({\n        id: this._id,\n      }, null, null);\n    }\n\n    if (this._drawer.initcreate) {\n      this.create();\n    }\n  }\n\n  /**\n   * Create the drawer set.\n   *\n   * @public\n   */\n  create() {\n    try {\n      this._createdrawer();\n      this._createoverlay();\n      this._enabled = true;\n\n      if (this._drawer.oncreate) {\n        this._drawer.oncreate.apply(this, [this._drawer]);\n      }\n    } catch (e) {\n      if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Destroy the drawer set.\n   *\n   * @public\n   */\n  destroy() {\n    try {\n      this._destroydrawer();\n      this._destroyoverlay();\n      this._enabled = false;\n\n      if (this._drawer.ondestroy) {\n        this._drawer.ondestroy.apply(this, [this._drawer]);\n      }\n    } catch (e) {\n      if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Open drawer.\n   *\n   * @public\n   * @param {number} [duration] Drawer moving time.\n   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n   * @param {boolean} [ischangehistory=false] Make a change in history.\n   * @return {Promise} Promise object for open.\n   */\n  open(duration = null, isfireevent = true, ischangehistory = true) {\n    return this._changestate(\n      0,\n      duration,\n      {\n        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n        done: isfireevent ? this._drawer.onopen : null,\n        fail: isfireevent ? this._drawer.onerror : null,\n      },\n      ischangehistory\n    );\n  }\n\n  /**\n   * Close drawer.\n   *\n   * @public\n   * @param {number} [duration] Drawer moving time.\n   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n   * @param {boolean} [ischangehistory=false] Make a change in history.\n   * @return {Promise} Promise object for close.\n   */\n  close(duration = null, isfireevent = true, ischangehistory = true) {\n    return this._changestate(\n      this._getminposition(),\n      duration,\n      {\n        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n        done: isfireevent ? this._drawer.onclose : null,\n        fail: isfireevent ? this._drawer.onerror : null,\n      },\n      ischangehistory\n    );\n  }\n\n  /**\n   * Toggle drawer.\n   *\n   * @public\n   * @param {number} [duration] Drawer moving time.\n   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n   * @param {boolean} [ischangehistory=false] Make a change in history.\n   * @return {Promise} Promise object for toggle.\n   */\n  toggle(duration = null, isfireevent = true, ischangehistory = true) {\n    return new Promise((resolve, reject) => {\n      try {\n        this[this.state === 'open' ? 'close' : 'open'](duration, isfireevent, ischangehistory)\n          .then(resolve, reject);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  /**\n   * Create drawer.\n   */\n  _createdrawer() {\n    helper.setstyle(\n      this._drawer.element,\n      Object.assign(\n        {},\n        DRAWER_STYLE,\n        support.cssanim ? TRANSITION_STYLE : {}\n      )\n    );\n\n    this._resetdrawer();\n\n    Object.keys(this._handler).forEach((name) => {\n      window.addEventListener(name, this._handler[name]);\n    });\n  }\n\n  /**\n   * Destroy drawer.\n   */\n  _destroydrawer() {\n    Object.keys(this._handler).forEach((name) => {\n      window.removeEventListener(name, this._handler[name]);\n    });\n\n    this._resetdrawer(true);\n\n    helper.unsetstyle(\n      this._drawer.element,\n      Object.keys(\n        Object.assign(\n          {},\n          DRAWER_STYLE,\n          support.cssanim ? TRANSITION_STYLE : {}\n        )\n      )\n    );\n  }\n\n  /**\n   * Create overlay.\n   */\n  _createoverlay() {\n    if (this._overlay === false) {\n      return;\n    }\n\n    if (this._overlay.zindex === -1) {\n      this._overlay.zindex = this._drawer.zindex - 1;\n    }\n\n    if (!this._overlay.element) {\n      this._overlay.element = window.document.createElement('div');\n      this._overlay.isautocreated = true;\n\n      helper.setstyle(\n        this._overlay.element,\n        Object.assign(\n          {},\n          OVERLAY_STYLE,\n          support.cssanim ? TRANSITION_STYLE : {}\n        )\n      );\n    }\n\n    if (!this._overlay.touchhandler) {\n      this._overlay.touchhandler = (e) => {\n        this.close();\n      };\n    }\n\n    window.document.body.appendChild(this._overlay.element);\n  }\n\n  /**\n   * Destroy overlay.\n   */\n  _destroyoverlay() {\n    if (this._overlay === false) {\n      return;\n    }\n\n    if (this._overlay.element) {\n      this._overlay.element.removeEventListener('click', this._overlay.touchhandler);\n\n      if (this._overlay.isautocreated) {\n        this._overlay.element.parentNode.removeChild(this._overlay.element);\n      }\n    }\n  }\n\n  /**\n   * Reset drawer.\n   *\n   * @param {boolean} [isunset] Unset style.\n   */\n  _resetdrawer(isunset = false) {\n    try {\n      this._setprops();\n\n      let ims = this._getinitdrawerstyle();\n\n      if (isunset) {\n        helper.unsetstyle(this._drawer.element, Object.keys(ims));\n      } else {\n        helper.setstyle(this._drawer.element, ims);\n      }\n    } catch (e) {\n      if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Show drawer.\n   */\n  _showdrawer() {\n    helper.setstyle(this._drawer.element, {\n      zIndex: this._drawer.zindex,\n      opacity: 1,\n    });\n  }\n\n  /**\n   * Hide drawer.\n   */\n  _hidedrawer() {\n    helper.setstyle(this._drawer.element, {\n      zIndex: -1,\n      opacity: 0,\n    });\n  }\n\n  /**\n   * Show overlay.\n   */\n  _showoverlay() {\n    helper.setstyle(this._overlay.element, {\n      zIndex: this._overlay.zindex,\n      display: 'block',\n    });\n  }\n\n  /**\n   * Hide overlay.\n   */\n  _hideoverlay() {\n    helper.setstyle(this._overlay.element, {\n      zIndex: -1,\n      display: 'none',\n    });\n  }\n\n  /**\n   * Set properties.\n   */\n  _setprops() {\n    // set sizepixel\n    let sizepixel = this._normalizepixel(\n      this._drawer.size\n    );\n\n    if (this._drawer.maxsize && this._drawer.maxsize !== -1) {\n      let maxsizepixel = this._normalizepixel(\n        this._drawer.maxsize\n      );\n\n      if (sizepixel > maxsizepixel) {\n        sizepixel = maxsizepixel;\n      }\n    }\n\n    this._sizepixel = sizepixel;\n\n    // set position\n    this._position = typeof this._position === 'undefined' ?\n      null :\n      this._position;\n  }\n\n  /**\n   * Return initial style of drawer.\n   *\n   * @return {Object} Style for drawer.\n   */\n  _getinitdrawerstyle() {\n    let style = null;\n\n    switch (this._drawer.direction) {\n      case 'top':\n        style = {\n          width: '100%',\n          height: `${this._sizepixel}px`,\n          top: `-${this._sizepixel}px`,\n          right: 'auto',\n          bottom: 'auto',\n          left: 0,\n        };\n        break;\n      case 'right':\n        style = {\n          width: `${this._sizepixel}px`,\n          height: '100%',\n          top: 0,\n          right: `-${this._sizepixel}px`,\n          bottom: 'auto',\n          left: 'auto',\n        };\n        break;\n      case 'bottom':\n        style = {\n          width: '100%',\n          height: `${this._sizepixel}px`,\n          top: 'auto',\n          right: 'auto',\n          bottom: `-${this._sizepixel}px`,\n          left: 0,\n        };\n        break;\n      case 'left':\n        style = {\n          width: `${this._sizepixel}px`,\n          height: '100%',\n          top: 0,\n          right: 'auto',\n          bottom: 'auto',\n          left: `-${this._sizepixel}px`,\n        };\n        break;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n\n    return Object.assign(style, this._drawer.style || {});\n  }\n\n  /**\n   * Return style for moving the drawer.\n   *\n   * @param {number} position Moving position.\n   * @param {number} [duration] Drawer moving time.\n   * @return {Object} Move style for drawer.\n   */\n  _getdrawerstyle(position, duration = null) {\n    let minp = this._getminposition(this._drawer);\n    let style = {};\n\n    if (support.cssanim) {\n      style.transitionDuration = `${duration === null ? this._drawer.duration : duration}ms`;\n\n      switch (this._drawer.direction) {\n        case 'top':\n          style.transform = `${support.transrate}(0,${-(minp - position)}px,0)`;\n          break;\n        case 'right':\n          style.transform = `${support.transrate}(${minp - position}px,0,0)`;\n          break;\n        case 'bottom':\n          style.transform = `${support.transrate}(0,${minp - position}px,0)`;\n          break;\n        case 'left':\n          style.transform = `${support.transrate}(${-(minp - position)}px,0,0)`;\n          break;\n        default:\n          throw new Error(`'${this._drawer.direction}' does not support`);\n      }\n    } else {\n      style[this._drawer.direction] = `${position}px`;\n    }\n\n    return style;\n  }\n\n  /**\n   * Return style for moving the overlay.\n   *\n   * @param {float} opacity Overlay opacity.\n   * @param {number} [duration] Drawer moving time.\n   * @return {Object} Move style for overlay.\n   */\n  _getoverlaystyle(opacity, duration = null) {\n    let style = {\n      opacity,\n    };\n\n    if (support.cssanim) {\n      style.transitionDuration = `${duration === null ? this._drawer.duration : duration}ms`;\n    }\n\n    return style;\n  }\n\n  /**\n   * Make animation with CSS3.\n   *\n   * @param {number} duration Drawer moving time.\n   */\n  _cssanimate(duration) {\n    helper.setstyle(\n      this._overlay.element,\n      this._getoverlaystyle(\n        this._getoverlayopacityfromposition(this._position),\n        duration\n      )\n    );\n\n    helper.setstyle(\n      this._drawer.element,\n      this._getdrawerstyle(this._position, duration)\n    );\n  }\n\n  /**\n   * Make animation with Javascript.\n   *\n   * @param {number} duration Drawer moving time.\n   */\n  _jsanimate(duration) {\n    let start = +new Date();\n    let fromopy = this._getoverlayopacityfromstyle();\n    let toopy = this._getoverlayopacityfromposition(this._position);\n    let frompos = this._getdrawerpositionfromstyle();\n    let topos = this._position;\n\n    if (this._intervalid) {\n      clearInterval(this._intervalid);\n    }\n\n    this._intervalid = setInterval(() => {\n      let time = new Date() - start;\n      let nowpos = null;\n      let nowopy = null;\n\n      if (time > duration) {\n        clearInterval(this._intervalid);\n        this._intervalid = null;\n        nowopy = toopy;\n        nowpos = topos;\n      } else {\n        let prp = (time /= duration) * (time - 2);\n        nowopy = fromopy - ((toopy - fromopy) * prp);\n        nowpos = frompos - ((topos - frompos) * prp);\n      }\n\n      helper.setstyle(\n        this._overlay.element,\n        this._getoverlaystyle(nowopy, duration)\n      );\n\n      helper.setstyle(\n        this._drawer.element,\n        this._getdrawerstyle(nowpos, duration)\n      );\n    }, 10);\n  }\n\n  /**\n   * Return state by touch movement.\n   *\n   * @return {string} State by touch movement.\n   */\n  _gettouchmovestate() {\n    if (this._process.time.end - this._process.time.start <= 300) {\n      let len = this._process.touches.length;\n      let moveinfo = this._gettouchmoveinfo(\n        this._process.touches[len - 2],\n        this._process.touches[len - 1]\n      );\n      let vertical = moveinfo.axis === 'vertical';\n      let horizontal = moveinfo.axis === 'horizontal';\n      let top = this._drawer.direction === 'top' && moveinfo.y >= 0;\n      let right = this._drawer.direction === 'right' && moveinfo.x < 0;\n      let bottom = this._drawer.direction === 'bottom' && moveinfo.y < 0;\n      let left = this._drawer.direction === 'left' && moveinfo.x >= 0;\n\n      return (vertical && (bottom || top)) ||\n        (horizontal && (right || left)) ?\n        'open' :\n        'close';\n    }\n\n    return this._getstatefromposition();\n  }\n\n  /**\n   * Return drawer event handler.\n   *\n   * @return {Object} Drawer event handler.\n   */\n  _getdrawerhandler() {\n    let handler = {};\n\n    handler.resize = () => {\n      this._resetdrawer();\n      this[this.state](0, false, false);\n\n      if (this._drawer.onresize) {\n        this._drawer.onresize.apply(\n          this,\n          [this._drawer]\n        );\n      }\n    };\n\n    if (this._drawer.swipeable) {\n      for (let event of TOUCH_EVENTS) {\n        handler[event] = this._touchhandler.bind(this);\n      }\n    }\n\n    if (window.history\n      && window.history.pushState\n      && this._drawer.history\n    ) {\n      handler.popstate = (e) => {\n        if (e.state && e.state.id === this._id && this.state === 'open') {\n          this.close(null, true, false);\n        }\n      };\n    }\n\n    return handler;\n  }\n\n  /**\n   * Touch event handler.\n   *\n   * @param {Event} ev Touch event object.\n   * @return {boolean} Event bubbling.\n   */\n  _touchhandler(ev) {\n    try {\n      if (ev.touches.length > 1) {\n        return true;\n      }\n\n      let touch = ev.touches[0];\n\n      if (touch) {\n        this._process.touches.push(touch);\n      }\n\n      switch (ev.type) {\n        case 'touchstart':\n          this._ontouchstart(ev);\n          break;\n        case 'touchmove':\n          this._ontouchmove(ev);\n          break;\n        case 'touchcancel':\n        case 'touchend':\n          this._ontouchfinish(ev);\n          break;\n        default:\n          break;\n      }\n    } catch (e) {\n      if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Touch start event handler.\n   *\n   * @param {Event} ev Touch event object.\n   */\n  _ontouchstart(ev) {\n    this._process.time.start = new Date().getTime();\n  }\n\n  /**\n   * Touch move event handler.\n   *\n   * @param {Event} ev Touch event object.\n   */\n  _ontouchmove(ev) {\n    let len = this._process.touches.length;\n\n    if (len < 2) {\n      return;\n    }\n\n    if (!this._process.istouchpointactive) {\n      this._process.istouchpointactive = this._istouchpointactive();\n    }\n\n    if (!this._process.istouchpointactive) {\n      return;\n    }\n\n    if (this._process.istouchdirectionactive === null) {\n      this._process.istouchdirectionactive = this._istouchdirectionactive();\n    }\n\n    if (!this._process.istouchdirectionactive) {\n      return;\n    }\n\n    let isfiretouchstart = false;\n    let istouchactive = this._process.istouchpointactive &&\n        this._process.istouchdirectionactive;\n\n    if (!istouchactive) {\n      return;\n    }\n\n    if (!this._process.istouchactive) {\n      this._process.istouchactive = istouchactive;\n      this._showoverlay();\n      this._showdrawer();\n\n      if (this._drawer.ontouchstart) {\n        isfiretouchstart = true;\n      }\n    }\n\n    ev.stopPropagation();\n    ev.preventDefault();\n\n    this._position = this._getdrawerpositionfromtouches(\n      this._process.touches[len - 2],\n      this._process.touches[len - 1]\n    );\n\n    if (isfiretouchstart) {\n      this._drawer.ontouchstart.apply(\n        this,\n        [this._drawer, this._position]\n      );\n    }\n\n    helper.setstyle(\n      this._overlay.element,\n      this._getoverlaystyle(\n        this._getoverlayopacityfromposition(this._position),\n        0\n      )\n    );\n\n    helper.setstyle(\n      this._drawer.element,\n      this._getdrawerstyle(this._position, 0)\n    );\n\n    if (this._drawer.ontouchmove) {\n      this._drawer.ontouchmove.apply(\n        this,\n        [this._drawer, this._position]\n      );\n    }\n  }\n\n  /**\n   * Touch finish event handler.\n   *\n   * @param {Event} ev Touch event object.\n   */\n  _ontouchfinish(ev) {\n    let len = this._process.touches.length;\n\n    if (this._process.istouchactive && len >= 2) {\n      this._process.time.end = new Date().getTime();\n\n      let state = this._gettouchmovestate();\n      let changestate = this.state !== state;\n\n      this[state](null, changestate, changestate);\n\n      if (this._drawer.ontouchfinish) {\n        this._drawer.ontouchfinish.apply(\n          this,\n          [\n            this._drawer,\n            this._getdrawerpositionfromtouches(\n              this._process.touches[len - 2],\n              this._process.touches[len - 1]\n            ),\n          ]\n        );\n      }\n    }\n\n    this._process.touches = [];\n    this._process.istouchactive = null;\n    this._process.istouchpointactive = null;\n    this._process.istouchdirectionactive = null;\n    this._process.time.start = 0;\n    this._process.time.end = 0;\n  }\n\n  /**\n   * Return whether or not a valid touch.\n   *\n   * @param {number} position Moving position.\n   * @param {number} [duration=null] Drawer moving time.\n   * @param {Object} [callbacks=null] Callback objects.\n   * @param {boolean} [ischangehistory=false] Make a change in history.\n   * @return {Promise} Promise object.\n   */\n  _changestate(\n    position,\n    duration = null,\n    callbacks = null,\n    ischangehistory = true\n  ) {\n    return this._handlecallback(new Promise((resolve, reject) => {\n      try {\n        this._position = position;\n\n        let du = duration === null ? this._drawer.duration : duration;\n\n        if (this._timeoutid !== null) {\n          clearTimeout(this._timeoutid);\n          this._timeoutid = null;\n        }\n\n        let state = this._getstatefromposition();\n\n        if (state === 'open') {\n          this._showoverlay();\n          this._showdrawer();\n        } else {\n          this._overlay.element.removeEventListener('click', this._overlay.touchhandler);\n        }\n\n        if (ischangehistory\n          && this._drawer.history\n          && window.history\n          && window.history.pushState\n        ) {\n          if (state === 'open') {\n            window.history.pushState({\n              id: this._id,\n            }, null, null);\n          } else {\n            window.history.back();\n          }\n        }\n\n        this[support.cssanim\n          ? '_cssanimate'\n          : '_jsanimate'](du);\n\n        this._timeoutid = setTimeout(\n          () => {\n            if (state === 'open') {\n              this._overlay.element.addEventListener('click', this._overlay.touchhandler);\n            } else {\n              this._hidedrawer();\n              this._hideoverlay();\n            }\n\n            this._timeoutid = null;\n          },\n          du\n        );\n\n        this.state = state;\n\n        if (typeof callbacks === 'object' && callbacks.onchangestate) {\n          callbacks.onchangestate.apply(\n            this,\n            [this._drawer, state]\n          );\n        }\n\n        resolve.apply(this, [this._drawer]);\n      } catch (e) {\n        reject(e);\n      }\n    }), {\n      done: typeof callbacks === 'object' && callbacks.done ? callbacks.done : null,\n      fail: typeof callbacks === 'object' && callbacks.fail ? callbacks.fail : null,\n    });\n  }\n\n  /**\n   * Return whether or not a valid touch point.\n   *\n   * @return {boolean} Result of valid touch point.\n   */\n  _istouchpointactive() {\n    let rg = this._getrange(\n      this.state === 'open' ?\n        this._sizepixel :\n        this._drawer.swipearea\n    );\n    let len = this._process.touches.length;\n\n    return (rg.from.x <= this._process.touches[len - 2].clientX &&\n      this._process.touches[len - 2].clientX <= rg.to.x &&\n      rg.from.y <= this._process.touches[len - 2].clientY &&\n      this._process.touches[len - 2].clientY <= rg.to.y);\n  }\n\n  /**\n   * Return whether or not a valid touch direction.\n   *\n   * @return {boolean} Result of valid touch direction.\n   */\n  _istouchdirectionactive() {\n    let len = this._process.touches.length;\n    let moveinfo = this._gettouchmoveinfo(\n      this._process.touches[len - 2],\n      this._process.touches[len - 1]\n    );\n    let vertical = moveinfo.axis === 'vertical';\n    let horizontal = moveinfo.axis === 'horizontal';\n\n    if (!(vertical &&\n      (this._drawer.direction === 'top' ||\n      this._drawer.direction === 'bottom') ||\n      horizontal &&\n      (this._drawer.direction === 'right' ||\n      this._drawer.direction === 'left'))\n    ) {\n      return false;\n    }\n\n    return (\n      (\n        this.state === 'open' &&\n        (\n          this._drawer.direction === 'top' && moveinfo.y < 0 ||\n          this._drawer.direction === 'right' && moveinfo.x >= 0 ||\n          this._drawer.direction === 'bottom' && moveinfo.y >= 0 ||\n          this._drawer.direction === 'left' && moveinfo.x < 0\n        )\n      ) ||\n      (\n        this.state === 'close' &&\n        (\n          this._drawer.direction === 'top' && moveinfo.y >= 0 ||\n          this._drawer.direction === 'right' && moveinfo.x < 0 ||\n          this._drawer.direction === 'bottom' && moveinfo.y < 0 ||\n          this._drawer.direction === 'left' && moveinfo.x >= 0\n        )\n      )\n    );\n  }\n\n  /**\n   * Return the state of the drawer.\n   *\n   * @return {string} State of the drawer.\n   */\n  _getstatefromposition() {\n    let pos = this._position === null ?\n      this._getdrawerpositionfromstyle() :\n      this._position;\n\n    return Math.abs(pos) < this._sizepixel / 2 ?\n      'open' :\n      'close';\n  }\n\n  /**\n   * Return the position of the drawer.\n   *\n   * @param {Object} touchbasis Basic touch information.\n   * @param {Object} touchlast Last touch information.\n   * @return {number} Position of the drawer.\n   */\n  _getdrawerpositionfromtouches(touchbasis, touchlast) {\n    let distance = this._getdistance(\n      this._gettouchmoveinfo(touchbasis, touchlast)\n    );\n\n    let curpos = this._position === null ?\n      this._getdrawerpositionfromstyle() :\n      this._position;\n\n    let pos = Math.round(curpos + distance);\n    let minp = this._getminposition(this._drawer);\n\n    if (pos > 0) {\n      pos = 0;\n    } else if (pos < minp) {\n      pos = minp;\n    }\n\n    return pos;\n  }\n\n  /**\n   * Return the position in the style.\n   *\n   * @return {number} Position in the style.\n   */\n  _getdrawerpositionfromstyle() {\n    let value = this._drawer.element.style[this._drawer.direction];\n    return this._normalizenumber(value).value;\n  }\n\n\n  /**\n   * Return the opacity of the overlay.\n   *\n   * @param {number} position Moving position.\n   * @return {number} Position of the drawer.\n   */\n  _getoverlayopacityfromposition(position) {\n    let minp = this._getminposition(this._drawer);\n    let posratio = 1 - (Math.abs(position) / Math.abs(minp));\n    return ((this._overlay.opacity * posratio) * 10000) / 10000;\n  }\n\n  /**\n   * Return the opacity in the style.\n   *\n   * @return {number} Opacity in the style.\n   */\n  _getoverlayopacityfromstyle() {\n    return parseFloat(this._overlay.element.style.opacity);\n  }\n\n  /**\n   * Return the swipe range.\n   *\n   * @param {string|number} value Target swipe area value.\n   * @return {Object} Drag range.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _getrange(value) {\n    let basis = this._convertpixelabs(value);\n    let width = window.innerWidth;\n    let height = window.innerHeight;\n\n    switch (this._drawer.direction) {\n      case 'top':\n        return {from: {x: 0, y: 0}, to: {x: width, y: basis}};\n      case 'right':\n        return {from: {x: basis, y: 0}, to: {x: width, y: height}};\n      case 'bottom':\n        return {from: {x: 0, y: basis}, to: {x: width, y: height}};\n      case 'left':\n        return {from: {x: 0, y: 0}, to: {x: basis, y: height}};\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return a value converted to the absolute value of the pixel.\n   *\n   * @param {string|number} value Target value.\n   * @return {number} Converted to the absolute value of the pixel.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _convertpixelabs(value) {\n    let nvalue = this._normalizepixel(value);\n\n    switch (this._drawer.direction) {\n      case 'top':\n      case 'left':\n        return nvalue;\n      case 'right':\n        return window.innerWidth - nvalue;\n      case 'bottom':\n        return window.innerHeight - nvalue;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return the normalized pixel value.\n   *\n   * @param {string|number} value Target value.\n   * @return {number} Normalized pixel value.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _normalizepixel(value) {\n    let normalized = this._normalizenumber(value);\n\n    if (normalized.unit === 'number' || normalized.unit === 'pixel') {\n      return normalized.value;\n    } else if (normalized.unit === 'percent') {\n      switch (this._drawer.direction) {\n        case 'top':\n        case 'bottom':\n          return window.innerHeight * (normalized.value / 100);\n        case 'right':\n        case 'left':\n          return window.innerWidth * (normalized.value / 100);\n        default:\n          throw new Error(`'${this._drawer.direction}' does not support`);\n      }\n    }\n  }\n\n  /**\n   * Return the numeric normalized information.\n   *\n   * @param {string|number} value Target value.\n   * @return {Object} Numeric normalized information.\n   * @throws {Error} Is thrown if value is invalid.\n   */\n  _normalizenumber(value) {\n    if (typeof value === 'number') {\n      return {value: value, unit: 'number'};\n    } else if (String(value).match(/^[.\\-0-9]+$/)) {\n      return {value: Number(value), unit: 'number'};\n    } else if (value.match(/^[.\\-0-9]+px$/)) {\n      return {value: Number(value.replace(/px$/ig, '')), unit: 'pixel'};\n    } else if (value.match(/[.\\-0-9]+%$/)) {\n      return {value: Number(value.replace(/%$/ig, '')), unit: 'percent'};\n    }\n\n    throw new Error(`'${value}' does not support`);\n  }\n\n  /**\n   * Return to the minimum position for the drawer.\n   *\n   * @return {number} Minimum position for the drawer.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _getminposition() {\n    switch (this._drawer.direction) {\n      case 'top':\n      case 'bottom':\n        return -1 * this._drawer.element.offsetHeight;\n      case 'right':\n      case 'left':\n        return -1 * this._drawer.element.offsetWidth;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return the distance of the drawer.\n   *\n   * @param {Object} moveinfo Movement information of the drawer.\n   * @return {number} Distance of the drawer.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _getdistance(moveinfo) {\n    switch (this._drawer.direction) {\n      case 'top':\n        return moveinfo.y;\n      case 'right':\n        return -1 * moveinfo.x;\n      case 'bottom':\n        return -1 * moveinfo.y;\n      case 'left':\n        return moveinfo.x;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return the information of touch move.\n   *\n   * @param {Object} touchbasis Basic touch information.\n   * @param {Object} touchlast Last touch information.\n   * @return {Object} Movement distance of the x, y direction, movement direction.\n   */\n  _gettouchmoveinfo(touchbasis, touchlast) {\n    let x = touchlast.clientX - touchbasis.clientX;\n    let y = touchlast.clientY - touchbasis.clientY;\n    let axis = Math.abs(x) >= Math.abs(y) ? 'horizontal' : 'vertical';\n\n    return {x, y, axis};\n  }\n\n  /**\n   * Return the information of touch move.\n   *\n   * @param {Promise} promise Promise instance.\n   * @param {Object} callbacks Callback function with the key to 'done', 'fail', 'always' (each optional).\n   * @return {Promise} Promise instance.\n   */\n  _handlecallback(promise, callbacks) {\n    if (!callbacks) {\n      return promise;\n    }\n\n    for (let key of Object.keys(callbacks)) {\n      let callback = callbacks[key];\n\n      if (!callback) {\n        continue;\n      }\n\n      let cb = isarray(callback) ? callback : [callback];\n      let rcb = null;\n\n      switch (key) {\n        case 'done':\n          rcb = (prom, value) => prom.then(value.bind(this));\n          break;\n        case 'fail':\n          rcb = (prom, value) => prom.catch(value.bind(this));\n          break;\n        case 'always':\n          rcb = (prom, value) => prom.then(value.bind(this), value.bind(this));\n          break;\n        default:\n          break;\n      }\n\n      if (rcb) {\n        cb.reduce(rcb, promise);\n      }\n    }\n\n    return promise;\n  }\n}\n\nmodule.exports = Highendrawer;\n\n\n\n// WEBPACK FOOTER //\n// ./src/highendrawer.js","'use strict';\n\n/**\n * Vendor prefix list.\n *\n * @type {string[]}\n */\nexport const PREFIX = ['webkit', 'moz', 'o', 'ms'];\n\n/**\n * Drawer's default css style.\n *\n * @type {Object}\n */\nexport const DRAWER_STYLE = Object.freeze({\n  display: 'block',\n  position: 'fixed',\n  overflowX: 'hidden',\n  overflowY: 'auto',\n  zIndex: -1,\n  opacity: 0,\n  webkitOverflowScrolling: 'touch',\n});\n\n/**\n * Overlay's default css style.\n *\n * @type {Object}\n */\nexport const OVERLAY_STYLE = Object.freeze({\n  display: 'none',\n  backgroundColor: '#000',\n  position: 'fixed',\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n  zIndex: -1,\n  opacity: 0,\n});\n\n/**\n * Css transition style.\n *\n * @type {Object}\n */\nexport const TRANSITION_STYLE = Object.freeze({\n  transform: '',\n  transitionProperty: 'transform,opacity',\n  transitionTimingFunction: 'cubic-bezier(0,0,0.25,1)',\n  transitionDuration: '0ms',\n});\n\n/**\n * Default drawer property.\n *\n * @type {Drawer}\n */\nexport const DEFAULT_DRAWER_PROPERTY = Object.freeze({\n  element: null,\n  direction: 'right',\n  size: '80%',\n  maxsize: -1,\n  swipeable: true,\n  swipearea: 20,\n  duration: 300,\n  zindex: 9999,\n  style: {},\n  initcreate: true,\n  enabledmaxwidth: -1,\n  history: true,\n  overlay: null,\n  oncreate: null,\n  ondestroy: null,\n  onopen: null,\n  onclose: null,\n  onchangestate: null,\n  onresize: null,\n  ontouchstart: null,\n  ontouchmove: null,\n  ontouchfinish: null,\n  onerror: null,\n});\n\n/**\n * Default overlay property.\n *\n * @type {Overlay}\n */\nexport const DEFAULT_OVERLAY_PROPERTY = Object.freeze({\n  element: null,\n  opacity: 0.2,\n  zindex: -1,\n  autocreate: false,\n});\n\n/**\n * Default processing state object.\n *\n * @type {Object}\n */\nexport const DEFAULT_PROCESS = Object.freeze({\n  touches: [],\n  istouchactive: null,\n  istouchpointactive: null,\n  istouchdirectionactive: null,\n  time: {\n    start: 0,\n    end: 0,\n  },\n});\n\n/**\n * Touch event list.\n *\n * @type {string[]}\n */\nexport const TOUCH_EVENTS = [\n  'touchstart',\n  'touchmove',\n  'touchend',\n  'touchcancel',\n];\n\n\n\n// WEBPACK FOOTER //\n// ./src/const.js","'use strict';\n\nimport {PREFIX} from './const';\nimport {isarray, ucfirst} from './util';\n\nconst dom = window.document.createElement('div');\n\nlet currentid = 0;\nlet validstylename = {};\n\n/**\n * Generate ID.\n *\n * @return {number} ID.\n */\nexport function generateid() {\n  return ++currentid;\n}\n\n/**\n * Verify that the style is present.\n *\n * @param {string[]|string} styles Css styles.\n * @return {boolean} Result of verification.\n */\nexport function hasstyle(styles) {\n  let ss = styles;\n\n  if (!isarray(styles)) {\n    ss = [styles];\n  }\n\n  for (let style of ss) {\n    if (typeof dom.style[style] !== 'undefined') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Set the CSS style to element.\n *\n * @param {Object} element Target element object.\n * @param {Object} style Css style.\n */\nexport function setstyle(element, style) {\n  for (let name of Object.keys(style)) {\n    let vsn = validstylename[name];\n\n    if (vsn) {\n      element.style[vsn] = style[name];\n    } else if (typeof element.style[name] === 'undefined') {\n      for (let i = 0; i < 2; i++) {\n        for (let pfx of PREFIX) {\n          let namewithprefix = (i === 0 ? pfx : ucfirst(pfx)) +\n            ucfirst(name);\n\n          if (typeof element.style[namewithprefix] !== 'undefined') {\n            validstylename[name] = namewithprefix;\n            element.style[namewithprefix] = style[name];\n            break;\n          }\n        }\n      }\n    } else {\n      validstylename[name] = name;\n      element.style[name] = style[name];\n    }\n  }\n}\n\n/**\n * Unset the CSS style to element.\n *\n * @param {Object} element Target element object.\n * @param {string[]|string} styles Css styles.\n */\nexport function unsetstyle(element, styles) {\n  let style = {};\n\n  for (let name of isarray(styles) ? styles : [styles]) {\n    style[name] = '';\n  }\n\n  setstyle(element, style);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/helper.js","'use strict';\n\n/**\n * Convert the first letter to uppercase.\n *\n * @param {string} str Target character string.\n * @return {string} Converted string.\n */\nexport function ucfirst(str) {\n  return str.charAt(0).toUpperCase() + str.substr(1);\n}\n\n/**\n * Whether or not the object is an array.\n *\n * @param {any} obj Target object.\n * @return {boolean} Returns true if object is an Array.\n */\nexport function isarray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js","'use strict';\n\nimport {hasstyle} from './helper';\n\n/**\n * Browser support information.\n *\n * @type {Object}\n */\nlet sup = {};\n\nsup.transform3d = hasstyle([\n  'perspectiveProperty',\n  'webkitPerspective',\n  'mozPerspective',\n  'oPerspective',\n  'msPerspective',\n]);\n\nsup.transform = hasstyle([\n  'transformProperty',\n  'webkitTransform',\n  'mozTransform',\n  'oTransform',\n  'msTransform',\n]);\n\nsup.transition = hasstyle([\n  'transitionProperty',\n  'webkitTransitionProperty',\n  'mozTransitionProperty',\n  'oTransitionProperty',\n  'msTransitionProperty',\n]);\n\nsup.cssanim = (sup.transform3d || sup.transform) &&\n  sup.transition;\n\nsup.transrate = sup.transform3d ?\n  'translate3d' :\n  'translate';\n\n/**\n * Browser support information.\n *\n * @type {Object}\n */\nexport const support = Object.freeze(sup);\n\n\n\n// WEBPACK FOOTER //\n// ./src/support.js"],"sourceRoot":""}