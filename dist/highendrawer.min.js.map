{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///highendrawer.min.js","webpack:///webpack/bootstrap 7bc3ca92a1a5af4a24ee","webpack:///./src/highendrawer.js","webpack:///./src/const.js","webpack:///./src/helper.js","webpack:///./src/util.js","webpack:///./src/support.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","default","_classCallCheck","instance","Constructor","TypeError","defineProperty","value","_typeof","Symbol","iterator","constructor","_extends","assign","target","i","arguments","length","source","_createClass","defineProperties","props","descriptor","enumerable","configurable","writable","protoProps","staticProps","_const","_util","_helper","helper","_support","Highendrawer","drawer","_this","_id","generateid","_drawer","DEFAULT_DRAWER_PROPERTY","_overlay","overlay","DEFAULT_OVERLAY_PROPERTY","_timeoutid","_intervalid","_process","DEFAULT_PROCESS","_enabled","_handler","_getdrawerhandler","enabledmaxwidth","window","addEventListener","innerWidth","destroy","create","isinitcreate","_createdrawer","_createoverlay","oncreate","apply","e","onerror","_destroydrawer","_destroyoverlay","ondestroy","duration","undefined","isfireevent","iseventprocess","_changestate","onchangestate","done","onopen","fail","_getminposition","onclose","_this2","Promise","resolve","reject","_getstate","then","_this3","setstyle","element","DRAWER_STYLE","support","cssanim","TRANSITION_STYLE","_resetdrawer","keys","forEach","name","_this4","removeEventListener","unsetstyle","_this5","zindex","document","createElement","isautocreated","OVERLAY_STYLE","touchhandler","close","body","appendChild","parentNode","removeChild","isunset","_setprops","ims","_getinitdrawerstyle","zIndex","sizepixel","_normalizepixel","size","maxsizepixel","maxsize","_sizepixel","_position","style","direction","width","height","top","right","bottom","left","Error","position","minp","transitionDuration","transform","transrate","opacity","_getoverlaystyle","_getoverlayopacityfromposition","_getdrawerstyle","_this6","start","Date","fromopy","_getoverlayopacityfromstyle","toopy","frompos","_getdrawerpositionfromstyle","topos","clearInterval","setInterval","time","nowpos","nowopy","prp","touches","end","len","moveinfo","_gettouchmoveinfo","ish","axis","isv","ist","y","isr","x","isb","isl","_this7","handler","resize","onresize","isswipeable","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","TOUCH_EVENTS","next","event","_touchhandler","bind","err","return","history","pushState","ishistory","popstate","state","ev","touch","push","type","_ontouchstart","_ontouchmove","_ontouchfinish","getTime","isfiretouchstart","istouchactive","_istouchactive","_showoverlay","_showdrawer","ontouchstart","stopPropagation","preventDefault","_getdrawerpositionfromtouches","ontouchmove","_gettouchmovestate","ontouchfinish","_this8","callbacks","_handlecallback","du","clearTimeout","back","setTimeout","_hidedrawer","_hideoverlay","rg","_getrange","swipearea","from","clientX","to","clientY","pos","Math","abs","touchbasis","touchlast","distance","_getdistance","curpos","round","_normalizenumber","posratio","parseFloat","basis","_convertpixelabs","innerHeight","nvalue","normalized","unit","String","match","Number","replace","offsetHeight","offsetWidth","promise","_this9","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","callback","cb","isarray","rcb","prom","catch","reduce","PREFIX","freeze","display","overflowX","overflowY","webkitOverflowScrolling","backgroundColor","transitionProperty","transitionTimingFunction","autocreate","currentid","hasstyle","styles","ss","dom","vsn","validstylename","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","pfx","namewithprefix","ucfirst","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","str","charAt","toUpperCase","substr","toString","sup","transform3d","transition"],"mappings":"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","file":"highendrawer.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Highendrawer\"] = factory();\n\telse\n\t\troot[\"Highendrawer\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/*!\n * highendrawer - Highendrawer provides javascript and css drawers to your website and applications.\n * @version v0.0.1\n * @link https://github.com/ym-aozora/highendrawer#readme\n * @license MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Highendrawer\"] = factory();\n\telse\n\t\troot[\"Highendrawer\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _const = __webpack_require__(1);\n\t\n\tvar _util = __webpack_require__(3);\n\t\n\tvar _helper = __webpack_require__(2);\n\t\n\tvar helper = _interopRequireWildcard(_helper);\n\t\n\tvar _support = __webpack_require__(4);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Class providing a drawer function.\n\t *\n\t * @public\n\t * @class\n\t * @example\n\t * var drawer = new DrawerMenu({\n\t *   element: document.getElementById('drawer')\n\t * });\n\t */\n\tvar Highendrawer = function () {\n\t\n\t  /**\n\t   * Initialize object.\n\t   *\n\t   * @constructor\n\t   * @param {Drawer} drawer Initial parameters of drawer.\n\t   */\n\t  function Highendrawer(drawer) {\n\t    var _this = this;\n\t\n\t    _classCallCheck(this, Highendrawer);\n\t\n\t    this._id = helper.generateid();\n\t    this._drawer = _extends({}, _const.DEFAULT_DRAWER_PROPERTY, drawer);\n\t    this._overlay = this._drawer.overlay === false ? false : _extends({}, _const.DEFAULT_OVERLAY_PROPERTY, this._drawer.overlay);\n\t    this._timeoutid = null;\n\t    this._intervalid = null;\n\t    this._process = _extends({}, _const.DEFAULT_PROCESS);\n\t    this._enabled = false;\n\t    this._handler = this._getdrawerhandler();\n\t\n\t    if (this._drawer.enabledmaxwidth > -1) {\n\t      window.addEventListener('resize', function () {\n\t        if (_this._enabled && window.innerWidth > _this._drawer.enabledmaxwidth) {\n\t          _this.destroy();\n\t        } else if (!_this._enabled && window.innerWidth <= _this._drawer.enabledmaxwidth) {\n\t          _this.create();\n\t        }\n\t      });\n\t    }\n\t\n\t    if (this._drawer.isinitcreate) {\n\t      this.create();\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Create the drawer set.\n\t   *\n\t   * @public\n\t   */\n\t\n\t\n\t  _createClass(Highendrawer, [{\n\t    key: 'create',\n\t    value: function create() {\n\t      try {\n\t        this._createdrawer();\n\t        this._createoverlay();\n\t        this._enabled = true;\n\t\n\t        if (this._drawer.oncreate) {\n\t          this._drawer.oncreate.apply(this, [this._drawer]);\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Destroy the drawer set.\n\t     *\n\t     * @public\n\t     */\n\t\n\t  }, {\n\t    key: 'destroy',\n\t    value: function destroy() {\n\t      try {\n\t        this._destroydrawer();\n\t        this._destroyoverlay();\n\t        this._enabled = false;\n\t\n\t        if (this._drawer.ondestroy) {\n\t          this._drawer.ondestroy.apply(this, [this._drawer]);\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Open drawer.\n\t     *\n\t     * @public\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n\t     * @param {boolean} [iseventprocess=false] Event processing in progress.\n\t     * @return {Promise} Promise object for open.\n\t     */\n\t\n\t  }, {\n\t    key: 'open',\n\t    value: function open() {\n\t      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t      var isfireevent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var iseventprocess = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      return this._changestate(0, duration, {\n\t        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n\t        done: isfireevent ? this._drawer.onopen : null,\n\t        fail: isfireevent ? this._drawer.onerror : null\n\t      }, iseventprocess);\n\t    }\n\t\n\t    /**\n\t     * Close drawer.\n\t     *\n\t     * @public\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n\t     * @param {boolean} [iseventprocess=false] Event processing in progress.\n\t     * @return {Promise} Promise object for close.\n\t     */\n\t\n\t  }, {\n\t    key: 'close',\n\t    value: function close() {\n\t      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t      var isfireevent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var iseventprocess = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      return this._changestate(this._getminposition(), duration, {\n\t        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n\t        done: isfireevent ? this._drawer.onclose : null,\n\t        fail: isfireevent ? this._drawer.onerror : null\n\t      }, iseventprocess);\n\t    }\n\t\n\t    /**\n\t     * Toggle drawer.\n\t     *\n\t     * @public\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n\t     * @param {boolean} [iseventprocess=false] Event processing in progress.\n\t     * @return {Promise} Promise object for toggle.\n\t     */\n\t\n\t  }, {\n\t    key: 'toggle',\n\t    value: function toggle() {\n\t      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\n\t      var _this2 = this;\n\t\n\t      var isfireevent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t      var iseventprocess = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        try {\n\t          _this2[_this2._getstate() === 'open' ? 'close' : 'open'](duration, isfireevent, iseventprocess).then(resolve, reject);\n\t        } catch (e) {\n\t          reject(e);\n\t        }\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Create drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_createdrawer',\n\t    value: function _createdrawer() {\n\t      var _this3 = this;\n\t\n\t      helper.setstyle(this._drawer.element, _extends({}, _const.DRAWER_STYLE, _support.support.cssanim ? _const.TRANSITION_STYLE : {}));\n\t\n\t      this._resetdrawer();\n\t\n\t      Object.keys(this._handler).forEach(function (name) {\n\t        window.addEventListener(name, _this3._handler[name]);\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Destroy drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_destroydrawer',\n\t    value: function _destroydrawer() {\n\t      var _this4 = this;\n\t\n\t      Object.keys(this._handler).forEach(function (name) {\n\t        window.removeEventListener(name, _this4._handler[name]);\n\t      });\n\t\n\t      this._resetdrawer(true);\n\t\n\t      helper.unsetstyle(this._drawer.element, Object.keys(_extends({}, _const.DRAWER_STYLE, _support.support.cssanim ? _const.TRANSITION_STYLE : {})));\n\t    }\n\t\n\t    /**\n\t     * Create overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_createoverlay',\n\t    value: function _createoverlay() {\n\t      var _this5 = this;\n\t\n\t      if (this._overlay === false) {\n\t        return;\n\t      }\n\t\n\t      if (this._overlay.zindex === -1) {\n\t        this._overlay.zindex = this._drawer.zindex - 1;\n\t      }\n\t\n\t      if (!this._overlay.element) {\n\t        this._overlay.element = window.document.createElement('div');\n\t        this._overlay.isautocreated = true;\n\t\n\t        helper.setstyle(this._overlay.element, _extends({}, _const.OVERLAY_STYLE, _support.support.cssanim ? _const.TRANSITION_STYLE : {}));\n\t      }\n\t\n\t      if (!this._overlay.touchhandler) {\n\t        this._overlay.touchhandler = function (e) {\n\t          _this5.close();\n\t        };\n\t      }\n\t\n\t      this._overlay.element.addEventListener('click', this._overlay.touchhandler);\n\t      window.document.body.appendChild(this._overlay.element);\n\t    }\n\t\n\t    /**\n\t     * Destroy overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_destroyoverlay',\n\t    value: function _destroyoverlay() {\n\t      if (this._overlay === false) {\n\t        return;\n\t      }\n\t\n\t      if (this._overlay.element) {\n\t        if (this._overlay.touchhandler) {\n\t          this._overlay.element.removeEventListener('click', this._overlay.touchhandler);\n\t        }\n\t\n\t        if (this._overlay.isautocreated) {\n\t          this._overlay.element.parentNode.removeChild(this._overlay.element);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Reset drawer.\n\t     *\n\t     * @param {boolean} [isunset] Unset style.\n\t     */\n\t\n\t  }, {\n\t    key: '_resetdrawer',\n\t    value: function _resetdrawer() {\n\t      var isunset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t      try {\n\t        this._setprops();\n\t\n\t        var ims = this._getinitdrawerstyle();\n\t\n\t        if (isunset) {\n\t          helper.unsetstyle(this._drawer.element, Object.keys(ims));\n\t        } else {\n\t          helper.setstyle(this._drawer.element, ims);\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Show drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_showdrawer',\n\t    value: function _showdrawer() {\n\t      helper.setstyle(this._drawer.element, {\n\t        zIndex: this._drawer.zindex\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Hide drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_hidedrawer',\n\t    value: function _hidedrawer() {\n\t      helper.setstyle(this._drawer.element, {\n\t        zIndex: -1\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Show overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_showoverlay',\n\t    value: function _showoverlay() {\n\t      helper.setstyle(this._overlay.element, {\n\t        zIndex: this._overlay.zindex\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Hide overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_hideoverlay',\n\t    value: function _hideoverlay() {\n\t      helper.setstyle(this._overlay.element, {\n\t        zIndex: -1\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Set properties.\n\t     */\n\t\n\t  }, {\n\t    key: '_setprops',\n\t    value: function _setprops() {\n\t      // set sizepixel\n\t      var sizepixel = this._normalizepixel(this._drawer.size);\n\t\n\t      var maxsizepixel = this._normalizepixel(this._drawer.maxsize);\n\t\n\t      if (sizepixel > maxsizepixel) {\n\t        sizepixel = maxsizepixel;\n\t      }\n\t\n\t      this._sizepixel = sizepixel;\n\t\n\t      // set position\n\t      this._position = typeof this._position === 'undefined' ? null : this._position;\n\t    }\n\t\n\t    /**\n\t     * Return initial style of drawer.\n\t     *\n\t     * @return {Object} Style for drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getinitdrawerstyle',\n\t    value: function _getinitdrawerstyle() {\n\t      var style = null;\n\t\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t          style = {\n\t            width: '100%',\n\t            height: this._sizepixel + 'px',\n\t            top: '-' + this._sizepixel + 'px',\n\t            right: 'auto',\n\t            bottom: 'auto',\n\t            left: 0\n\t          };\n\t          break;\n\t        case 'right':\n\t          style = {\n\t            width: this._sizepixel + 'px',\n\t            height: '100%',\n\t            top: 0,\n\t            right: '-' + this._sizepixel + 'px',\n\t            bottom: 'auto',\n\t            left: 'auto'\n\t          };\n\t          break;\n\t        case 'bottom':\n\t          style = {\n\t            width: '100%',\n\t            height: this._sizepixel + 'px',\n\t            top: 'auto',\n\t            right: 'auto',\n\t            bottom: '-' + this._sizepixel + 'px',\n\t            left: 0\n\t          };\n\t          break;\n\t        case 'left':\n\t          style = {\n\t            width: this._sizepixel + 'px',\n\t            height: '100%',\n\t            top: 0,\n\t            right: 'auto',\n\t            bottom: 'auto',\n\t            left: '-' + this._sizepixel + 'px'\n\t          };\n\t          break;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t\n\t      return _extends(style, this._drawer.style || {});\n\t    }\n\t\n\t    /**\n\t     * Return style for moving the drawer.\n\t     *\n\t     * @param {number} position Moving position.\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @return {Object} Move style for drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerstyle',\n\t    value: function _getdrawerstyle(position) {\n\t      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var minp = this._getminposition(this._drawer);\n\t      var style = {};\n\t\n\t      if (_support.support.cssanim) {\n\t        style.transitionDuration = (duration === null ? this._drawer.duration : duration) + 'ms';\n\t\n\t        switch (this._drawer.direction) {\n\t          case 'top':\n\t            style.transform = _support.support.transrate + '(0,' + -(minp - position) + 'px,0)';\n\t            break;\n\t          case 'right':\n\t            style.transform = _support.support.transrate + '(' + (minp - position) + 'px,0,0)';\n\t            break;\n\t          case 'bottom':\n\t            style.transform = _support.support.transrate + '(0,' + (minp - position) + 'px,0)';\n\t            break;\n\t          case 'left':\n\t            style.transform = _support.support.transrate + '(' + -(minp - position) + 'px,0,0)';\n\t            break;\n\t          default:\n\t            throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t        }\n\t      } else {\n\t        style[this._drawer.direction] = position + 'px';\n\t      }\n\t\n\t      return style;\n\t    }\n\t\n\t    /**\n\t     * Return style for moving the overlay.\n\t     *\n\t     * @param {float} opacity Overlay opacity.\n\t     * @param {number} [duration] Drawer moving time.\n\t     * @return {Object} Move style for overlay.\n\t     */\n\t\n\t  }, {\n\t    key: '_getoverlaystyle',\n\t    value: function _getoverlaystyle(opacity) {\n\t      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var style = {\n\t        opacity: opacity\n\t      };\n\t\n\t      if (_support.support.cssanim) {\n\t        style.transitionDuration = (duration === null ? this._drawer.duration : duration) + 'ms';\n\t      }\n\t\n\t      return style;\n\t    }\n\t\n\t    /**\n\t     * Make animation with CSS3.\n\t     *\n\t     * @param {number} duration Drawer moving time.\n\t     */\n\t\n\t  }, {\n\t    key: '_cssanimate',\n\t    value: function _cssanimate(duration) {\n\t      helper.setstyle(this._overlay.element, this._getoverlaystyle(this._getoverlayopacityfromposition(this._position), duration));\n\t\n\t      helper.setstyle(this._drawer.element, this._getdrawerstyle(this._position, duration));\n\t    }\n\t\n\t    /**\n\t     * Make animation with Javascript.\n\t     *\n\t     * @param {number} duration Drawer moving time.\n\t     */\n\t\n\t  }, {\n\t    key: '_jsanimate',\n\t    value: function _jsanimate(duration) {\n\t      var _this6 = this;\n\t\n\t      var start = +new Date();\n\t      var fromopy = this._getoverlayopacityfromstyle();\n\t      var toopy = this._getoverlayopacityfromposition(this._position);\n\t      var frompos = this._getdrawerpositionfromstyle();\n\t      var topos = this._position;\n\t\n\t      if (this._intervalid) {\n\t        clearInterval(this._intervalid);\n\t      }\n\t\n\t      this._intervalid = setInterval(function () {\n\t        var time = new Date() - start;\n\t        var nowpos = null;\n\t        var nowopy = null;\n\t\n\t        if (time > duration) {\n\t          clearInterval(_this6._intervalid);\n\t          _this6._intervalid = null;\n\t          nowopy = toopy;\n\t          nowpos = topos;\n\t        } else {\n\t          var prp = (time /= duration) * (time - 2);\n\t          nowopy = fromopy - (toopy - fromopy) * prp;\n\t          nowpos = frompos - (topos - frompos) * prp;\n\t        }\n\t\n\t        helper.setstyle(_this6._overlay.element, _this6._getoverlaystyle(nowopy, duration));\n\t\n\t        helper.setstyle(_this6._drawer.element, _this6._getdrawerstyle(nowpos, duration));\n\t      }, 10);\n\t    }\n\t\n\t    /**\n\t     * Return state by touch movement.\n\t     *\n\t     * @param {Array} touches Touch object array.\n\t     * @param {Object} time Time information on start and end of movement.\n\t     * @return {string} State by touch movement.\n\t     */\n\t\n\t  }, {\n\t    key: '_gettouchmovestate',\n\t    value: function _gettouchmovestate(touches, time) {\n\t      if (time.end - time.start <= 300) {\n\t        var len = touches.length;\n\t\n\t        if (len >= 2) {\n\t          var moveinfo = this._gettouchmoveinfo(touches[len - 2], touches[len - 1]);\n\t          var ish = moveinfo.axis === 'horizontal';\n\t          var isv = moveinfo.axis === 'vertical';\n\t          var ist = this._drawer.direction === 'top' && moveinfo.y >= 0;\n\t          var isr = this._drawer.direction === 'right' && moveinfo.x < 0;\n\t          var isb = this._drawer.direction === 'bottom' && moveinfo.y < 0;\n\t          var isl = this._drawer.direction === 'left' && moveinfo.x >= 0;\n\t\n\t          return ish && (isr || isl) || isv && (isb || ist) ? 'open' : 'close';\n\t        }\n\t      }\n\t\n\t      return this._getstate();\n\t    }\n\t\n\t    /**\n\t     * Return drawer event handler.\n\t     *\n\t     * @return {Object} Drawer event handler.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerhandler',\n\t    value: function _getdrawerhandler() {\n\t      var _this7 = this;\n\t\n\t      var handler = {};\n\t\n\t      handler.resize = function () {\n\t        _this7._resetdrawer();\n\t        _this7[_this7._getstate()](0, false, true);\n\t\n\t        if (_this7._drawer.onresize) {\n\t          _this7._drawer.onresize.apply(_this7, [_this7._drawer]);\n\t        }\n\t      };\n\t\n\t      if (this._drawer.isswipeable) {\n\t        var _iteratorNormalCompletion = true;\n\t        var _didIteratorError = false;\n\t        var _iteratorError = undefined;\n\t\n\t        try {\n\t          for (var _iterator = _const.TOUCH_EVENTS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t            var event = _step.value;\n\t\n\t            handler[event] = this._touchhandler.bind(this);\n\t          }\n\t        } catch (err) {\n\t          _didIteratorError = true;\n\t          _iteratorError = err;\n\t        } finally {\n\t          try {\n\t            if (!_iteratorNormalCompletion && _iterator.return) {\n\t              _iterator.return();\n\t            }\n\t          } finally {\n\t            if (_didIteratorError) {\n\t              throw _iteratorError;\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      if (window.history && window.history.pushState && this._drawer.ishistory) {\n\t        handler.popstate = function (e) {\n\t          if (e.state && e.state.id === _this7._id && _this7._getstate() === 'open') {\n\t            _this7.close(null, true, true);\n\t          }\n\t        };\n\t      }\n\t\n\t      return handler;\n\t    }\n\t\n\t    /**\n\t     * Touch event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     * @return {boolean} Event bubbling.\n\t     */\n\t\n\t  }, {\n\t    key: '_touchhandler',\n\t    value: function _touchhandler(ev) {\n\t      try {\n\t        if (ev.touches.length > 1) {\n\t          return true;\n\t        }\n\t\n\t        var touch = ev.touches[0];\n\t\n\t        if (touch) {\n\t          this._process.touches.push(touch);\n\t        }\n\t\n\t        switch (ev.type) {\n\t          case 'touchstart':\n\t            this._ontouchstart(ev);\n\t            break;\n\t          case 'touchmove':\n\t            this._ontouchmove(ev);\n\t            break;\n\t          case 'touchcancel':\n\t          case 'touchend':\n\t            this._ontouchfinish(ev);\n\t            break;\n\t          default:\n\t            break;\n\t        }\n\t      } catch (e) {\n\t        if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n\t          this._drawer.onerror.apply(this, [e]);\n\t        } else {\n\t          throw e;\n\t        }\n\t      }\n\t\n\t      return true;\n\t    }\n\t\n\t    /**\n\t     * Touch start event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     */\n\t\n\t  }, {\n\t    key: '_ontouchstart',\n\t    value: function _ontouchstart(ev) {\n\t      this._process.time.start = new Date().getTime();\n\t    }\n\t\n\t    /**\n\t     * Touch move event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     */\n\t\n\t  }, {\n\t    key: '_ontouchmove',\n\t    value: function _ontouchmove(ev) {\n\t      var len = this._process.touches.length;\n\t      var isfiretouchstart = false;\n\t\n\t      if (!this._process.istouchactive && len >= 2) {\n\t        this._process.istouchactive = this._istouchactive(this._process.touches[0]);\n\t\n\t        if (this._process.istouchactive) {\n\t          this._showoverlay();\n\t          this._showdrawer();\n\t\n\t          if (this._drawer.ontouchstart) {\n\t            isfiretouchstart = true;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (this._process.istouchactive) {\n\t        ev.stopPropagation();\n\t        ev.preventDefault();\n\t\n\t        this._position = this._getdrawerpositionfromtouches(this._process.touches[len - 2], this._process.touches[len - 1]);\n\t\n\t        if (isfiretouchstart) {\n\t          this._drawer.ontouchstart.apply(this, [this._drawer, this._position]);\n\t        }\n\t\n\t        helper.setstyle(this._overlay.element, this._getoverlaystyle(this._getoverlayopacityfromposition(this._position), 0));\n\t\n\t        helper.setstyle(this._drawer.element, this._getdrawerstyle(this._position, 0));\n\t\n\t        if (this._drawer.ontouchmove) {\n\t          this._drawer.ontouchmove.apply(this, [this._drawer, this._position]);\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Touch finish event handler.\n\t     *\n\t     * @param {Event} ev Touch event object.\n\t     */\n\t\n\t  }, {\n\t    key: '_ontouchfinish',\n\t    value: function _ontouchfinish(ev) {\n\t      var len = this._process.touches.length;\n\t\n\t      if (this._process.istouchactive && len >= 2) {\n\t        this._process.time.end = new Date().getTime();\n\t\n\t        var state = this._gettouchmovestate(this._process.touches, this._process.time);\n\t\n\t        this[state]();\n\t\n\t        if (this._drawer.ontouchfinish) {\n\t          this._drawer.ontouchfinish.apply(this, [this._drawer, this._getdrawerpositionfromtouches(this._process.touches[len - 2], this._process.touches[len - 1])]);\n\t        }\n\t      }\n\t\n\t      this._process.touches = [];\n\t      this._process.istouchactive = false;\n\t      this._process.time.start = 0;\n\t      this._process.time.end = 0;\n\t    }\n\t\n\t    /**\n\t     * Return whether or not a valid touch.\n\t     *\n\t     * @param {number} position Moving position.\n\t     * @param {number} [duration=null] Drawer moving time.\n\t     * @param {Object} [callbacks=null] Callback objects.\n\t     * @param {boolean} [iseventprocess=false] Event processing in progress.\n\t     * @return {Promise} Promise object.\n\t     */\n\t\n\t  }, {\n\t    key: '_changestate',\n\t    value: function _changestate(position) {\n\t      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t      var _this8 = this;\n\t\n\t      var callbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\t      var iseventprocess = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\t\n\t      return this._handlecallback(new Promise(function (resolve, reject) {\n\t        try {\n\t          (function () {\n\t            _this8._position = position;\n\t\n\t            var du = duration === null ? _this8._drawer.duration : duration;\n\t\n\t            if (_this8._timeoutid !== null) {\n\t              clearTimeout(_this8._timeoutid);\n\t              _this8._timeoutid = null;\n\t            }\n\t\n\t            var state = _this8._getstate();\n\t\n\t            if (state === 'open') {\n\t              _this8._showoverlay();\n\t              _this8._showdrawer();\n\t            }\n\t\n\t            if (window.history && window.history.pushState && _this8._drawer.ishistory && !iseventprocess) {\n\t              if (state === 'open') {\n\t                window.history.pushState({\n\t                  id: _this8._id\n\t                }, null, null);\n\t              } else {\n\t                window.history.back();\n\t              }\n\t            }\n\t\n\t            _this8[_support.support.cssanim ? '_cssanimate' : '_jsanimate'](du);\n\t\n\t            _this8._timeoutid = setTimeout(function () {\n\t              if (state === 'close') {\n\t                _this8._hidedrawer();\n\t                _this8._hideoverlay();\n\t              }\n\t\n\t              _this8._timeoutid = null;\n\t            }, du);\n\t\n\t            if ((typeof callbacks === 'undefined' ? 'undefined' : _typeof(callbacks)) === 'object' && callbacks.onchangestate) {\n\t              callbacks.onchangestate.apply(_this8, [_this8._drawer, state]);\n\t            }\n\t\n\t            resolve.apply(_this8, [_this8._drawer]);\n\t          })();\n\t        } catch (e) {\n\t          reject(e);\n\t        }\n\t      }), {\n\t        done: (typeof callbacks === 'undefined' ? 'undefined' : _typeof(callbacks)) === 'object' && callbacks.done ? callbacks.done : null,\n\t        fail: (typeof callbacks === 'undefined' ? 'undefined' : _typeof(callbacks)) === 'object' && callbacks.fail ? callbacks.fail : null\n\t      });\n\t    }\n\t\n\t    /**\n\t     * Return whether or not a valid touch.\n\t     *\n\t     * @param {Object} touch Start touch information.\n\t     * @return {boolean} Result of valid touch.\n\t     */\n\t\n\t  }, {\n\t    key: '_istouchactive',\n\t    value: function _istouchactive(touch) {\n\t      var rg = this._getrange(this._getstate() === 'open' ? '100%' : this._drawer.swipearea);\n\t\n\t      return rg.from.x <= touch.clientX && touch.clientX <= rg.to.x && rg.from.y <= touch.clientY && touch.clientY <= rg.to.y;\n\t    }\n\t\n\t    /**\n\t     * Return the state of the drawer.\n\t     *\n\t     * @return {string} State of the drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getstate',\n\t    value: function _getstate() {\n\t      var pos = this._position === null ? this._getdrawerpositionfromstyle() : this._position;\n\t\n\t      return Math.abs(pos) < this._sizepixel / 2 ? 'open' : 'close';\n\t    }\n\t\n\t    /**\n\t     * Return the position of the drawer.\n\t     *\n\t     * @param {Object} touchbasis Basic touch information.\n\t     * @param {Object} touchlast Last touch information.\n\t     * @return {number} Position of the drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerpositionfromtouches',\n\t    value: function _getdrawerpositionfromtouches(touchbasis, touchlast) {\n\t      var distance = this._getdistance(this._gettouchmoveinfo(touchbasis, touchlast));\n\t\n\t      var curpos = this._position === null ? this._getdrawerpositionfromstyle() : this._position;\n\t\n\t      var pos = Math.round(curpos + distance);\n\t      var minp = this._getminposition(this._drawer);\n\t\n\t      if (pos > 0) {\n\t        pos = 0;\n\t      } else if (pos < minp) {\n\t        pos = minp;\n\t      }\n\t\n\t      return pos;\n\t    }\n\t\n\t    /**\n\t     * Return the position in the style.\n\t     *\n\t     * @return {number} Position in the style.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdrawerpositionfromstyle',\n\t    value: function _getdrawerpositionfromstyle() {\n\t      var value = this._drawer.element.style[this._drawer.direction];\n\t      return this._normalizenumber(value).value;\n\t    }\n\t\n\t    /**\n\t     * Return the opacity of the overlay.\n\t     *\n\t     * @param {number} position Moving position.\n\t     * @return {number} Position of the drawer.\n\t     */\n\t\n\t  }, {\n\t    key: '_getoverlayopacityfromposition',\n\t    value: function _getoverlayopacityfromposition(position) {\n\t      var minp = this._getminposition(this._drawer);\n\t      var posratio = 1 - Math.abs(position) / Math.abs(minp);\n\t      return this._overlay.opacity * posratio * 10000 / 10000;\n\t    }\n\t\n\t    /**\n\t     * Return the opacity in the style.\n\t     *\n\t     * @return {number} Opacity in the style.\n\t     */\n\t\n\t  }, {\n\t    key: '_getoverlayopacityfromstyle',\n\t    value: function _getoverlayopacityfromstyle() {\n\t      return parseFloat(this._overlay.element.style.opacity);\n\t    }\n\t\n\t    /**\n\t     * Return the swipe range.\n\t     *\n\t     * @param {string|number} value Target swipe area value.\n\t     * @return {Object} Drag range.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_getrange',\n\t    value: function _getrange(value) {\n\t      var basis = this._convertpixelabs(value);\n\t      var width = window.innerWidth;\n\t      var height = window.innerHeight;\n\t\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t          return { from: { x: 0, y: 0 }, to: { x: width, y: basis } };\n\t        case 'right':\n\t          return { from: { x: basis, y: 0 }, to: { x: width, y: height } };\n\t        case 'bottom':\n\t          return { from: { x: 0, y: basis }, to: { x: width, y: height } };\n\t        case 'left':\n\t          return { from: { x: 0, y: 0 }, to: { x: basis, y: height } };\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return a value converted to the absolute value of the pixel.\n\t     *\n\t     * @param {string|number} value Target value.\n\t     * @return {number} Converted to the absolute value of the pixel.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_convertpixelabs',\n\t    value: function _convertpixelabs(value) {\n\t      var nvalue = this._normalizepixel(value);\n\t\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t        case 'left':\n\t          return nvalue;\n\t        case 'right':\n\t          return window.innerWidth - nvalue;\n\t        case 'bottom':\n\t          return window.innerHeight - nvalue;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the normalized pixel value.\n\t     *\n\t     * @param {string|number} value Target value.\n\t     * @return {number} Normalized pixel value.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_normalizepixel',\n\t    value: function _normalizepixel(value) {\n\t      var normalized = this._normalizenumber(value);\n\t\n\t      if (normalized.unit === 'number' || normalized.unit === 'pixel') {\n\t        return normalized.value;\n\t      } else if (normalized.unit === 'percent') {\n\t        switch (this._drawer.direction) {\n\t          case 'top':\n\t          case 'bottom':\n\t            return window.innerHeight * (normalized.value / 100);\n\t          case 'right':\n\t          case 'left':\n\t            return window.innerWidth * (normalized.value / 100);\n\t          default:\n\t            throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t        }\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the numeric normalized information.\n\t     *\n\t     * @param {string|number} value Target value.\n\t     * @return {Object} Numeric normalized information.\n\t     * @throws {Error} Is thrown if value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_normalizenumber',\n\t    value: function _normalizenumber(value) {\n\t      if (typeof value === 'number') {\n\t        return { value: value, unit: 'number' };\n\t      } else if (String(value).match(/^[.\\-0-9]+$/)) {\n\t        return { value: Number(value), unit: 'number' };\n\t      } else if (value.match(/^[.\\-0-9]+px$/)) {\n\t        return { value: Number(value.replace(/px$/ig, '')), unit: 'pixel' };\n\t      } else if (value.match(/[.\\-0-9]+%$/)) {\n\t        return { value: Number(value.replace(/%$/ig, '')), unit: 'percent' };\n\t      }\n\t\n\t      throw new Error('\\'' + value + '\\' does not support');\n\t    }\n\t\n\t    /**\n\t     * Return to the minimum position for the drawer.\n\t     *\n\t     * @return {number} Minimum position for the drawer.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_getminposition',\n\t    value: function _getminposition() {\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t        case 'bottom':\n\t          return -1 * this._drawer.element.offsetHeight;\n\t        case 'right':\n\t        case 'left':\n\t          return -1 * this._drawer.element.offsetWidth;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the distance of the drawer.\n\t     *\n\t     * @param {Object} moveinfo Movement information of the drawer.\n\t     * @return {number} Distance of the drawer.\n\t     * @throws {Error} Is thrown if direction value is invalid.\n\t     */\n\t\n\t  }, {\n\t    key: '_getdistance',\n\t    value: function _getdistance(moveinfo) {\n\t      switch (this._drawer.direction) {\n\t        case 'top':\n\t          return moveinfo.y;\n\t        case 'right':\n\t          return -1 * moveinfo.x;\n\t        case 'bottom':\n\t          return -1 * moveinfo.y;\n\t        case 'left':\n\t          return moveinfo.x;\n\t        default:\n\t          throw new Error('\\'' + this._drawer.direction + '\\' does not support');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Return the information of touch move.\n\t     *\n\t     * @param {Object} touchbasis Basic touch information.\n\t     * @param {Object} touchlast Last touch information.\n\t     * @return {Object} Movement distance of the x, y direction, movement direction.\n\t     */\n\t\n\t  }, {\n\t    key: '_gettouchmoveinfo',\n\t    value: function _gettouchmoveinfo(touchbasis, touchlast) {\n\t      var x = touchlast.clientX - touchbasis.clientX;\n\t      var y = touchlast.clientY - touchbasis.clientY;\n\t      var axis = Math.abs(x) >= Math.abs(y) ? 'horizontal' : 'vertical';\n\t\n\t      return { x: x, y: y, axis: axis };\n\t    }\n\t\n\t    /**\n\t     * Return the information of touch move.\n\t     *\n\t     * @param {Promise} promise Promise instance.\n\t     * @param {Object} callbacks Callback function with the key to 'done', 'fail', 'always' (each optional).\n\t     * @return {Promise} Promise instance.\n\t     */\n\t\n\t  }, {\n\t    key: '_handlecallback',\n\t    value: function _handlecallback(promise, callbacks) {\n\t      var _this9 = this;\n\t\n\t      if (!callbacks) {\n\t        return promise;\n\t      }\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = Object.keys(callbacks)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var key = _step2.value;\n\t\n\t          var callback = callbacks[key];\n\t\n\t          if (!callback) {\n\t            continue;\n\t          }\n\t\n\t          var cb = (0, _util.isarray)(callback) ? callback : [callback];\n\t          var rcb = null;\n\t\n\t          switch (key) {\n\t            case 'done':\n\t              rcb = function rcb(prom, value) {\n\t                return prom.then(value.bind(_this9));\n\t              };\n\t              break;\n\t            case 'fail':\n\t              rcb = function rcb(prom, value) {\n\t                return prom.catch(value.bind(_this9));\n\t              };\n\t              break;\n\t            case 'always':\n\t              rcb = function rcb(prom, value) {\n\t                return prom.then(value.bind(_this9), value.bind(_this9));\n\t              };\n\t              break;\n\t            default:\n\t              break;\n\t          }\n\t\n\t          if (rcb) {\n\t            cb.reduce(rcb, promise);\n\t          }\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      return promise;\n\t    }\n\t  }]);\n\t\n\t  return Highendrawer;\n\t}();\n\t\n\texports.default = Highendrawer;\n\t\n\t\n\tmodule.exports = Highendrawer;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Vendor prefix list.\n\t *\n\t * @type {string[]}\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar PREFIX = exports.PREFIX = ['webkit', 'moz', 'o', 'ms'];\n\t\n\t/**\n\t * Drawer's default css style.\n\t *\n\t * @type {Object}\n\t */\n\tvar DRAWER_STYLE = exports.DRAWER_STYLE = Object.freeze({\n\t  display: 'block',\n\t  position: 'fixed',\n\t  overflowX: 'hidden',\n\t  overflowY: 'auto',\n\t  zIndex: -1,\n\t  webkitOverflowScrolling: 'touch'\n\t});\n\t\n\t/**\n\t * Overlay's default css style.\n\t *\n\t * @type {Object}\n\t */\n\tvar OVERLAY_STYLE = exports.OVERLAY_STYLE = Object.freeze({\n\t  display: 'block',\n\t  backgroundColor: '#000',\n\t  position: 'fixed',\n\t  top: 0,\n\t  right: 0,\n\t  bottom: 0,\n\t  left: 0,\n\t  zIndex: -1,\n\t  opacity: 0\n\t});\n\t\n\t/**\n\t * Css transition style.\n\t *\n\t * @type {Object}\n\t */\n\tvar TRANSITION_STYLE = exports.TRANSITION_STYLE = Object.freeze({\n\t  transform: '',\n\t  transitionProperty: 'transform,opacity',\n\t  transitionTimingFunction: 'cubic-bezier(0,0,0.25,1)',\n\t  transitionDuration: '0ms'\n\t});\n\t\n\t/**\n\t * Default drawer property.\n\t *\n\t * @type {Drawer}\n\t */\n\tvar DEFAULT_DRAWER_PROPERTY = exports.DEFAULT_DRAWER_PROPERTY = Object.freeze({\n\t  element: null,\n\t  direction: 'right',\n\t  size: '80%',\n\t  maxsize: 256,\n\t  isswipeable: true,\n\t  swipearea: '8%',\n\t  duration: 300,\n\t  zindex: 9999,\n\t  style: {},\n\t  isinitcreate: true,\n\t  enabledmaxwidth: -1,\n\t  ishistory: true,\n\t  overlay: null,\n\t  oncreate: null,\n\t  ondestroy: null,\n\t  onopen: null,\n\t  onclose: null,\n\t  onchangestate: null,\n\t  onresize: null,\n\t  ontouchstart: null,\n\t  ontouchmove: null,\n\t  ontouchfinish: null,\n\t  onerror: null\n\t});\n\t\n\t/**\n\t * Default overlay property.\n\t *\n\t * @type {Overlay}\n\t */\n\tvar DEFAULT_OVERLAY_PROPERTY = exports.DEFAULT_OVERLAY_PROPERTY = Object.freeze({\n\t  element: null,\n\t  opacity: 0.2,\n\t  zindex: -1,\n\t  autocreate: false\n\t});\n\t\n\t/**\n\t * Default processing state object.\n\t *\n\t * @type {Object}\n\t */\n\tvar DEFAULT_PROCESS = exports.DEFAULT_PROCESS = Object.freeze({\n\t  touches: [],\n\t  istouchactive: false,\n\t  time: {\n\t    start: 0,\n\t    end: 0\n\t  }\n\t});\n\t\n\t/**\n\t * Touch event list.\n\t *\n\t * @type {string[]}\n\t */\n\tvar TOUCH_EVENTS = exports.TOUCH_EVENTS = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.generateid = generateid;\n\texports.hasstyle = hasstyle;\n\texports.setstyle = setstyle;\n\texports.unsetstyle = unsetstyle;\n\t\n\tvar _const = __webpack_require__(1);\n\t\n\tvar _util = __webpack_require__(3);\n\t\n\tvar dom = window.document.createElement('div');\n\t\n\tvar currentid = 0;\n\tvar validstylename = {};\n\t\n\t/**\n\t * Generate ID.\n\t *\n\t * @return {number} ID.\n\t */\n\tfunction generateid() {\n\t  return ++currentid;\n\t}\n\t\n\t/**\n\t * Verify that the style is present.\n\t *\n\t * @param {string[]|string} styles Css styles.\n\t * @return {boolean} Result of verification.\n\t */\n\tfunction hasstyle(styles) {\n\t  var ss = styles;\n\t\n\t  if (!(0, _util.isarray)(styles)) {\n\t    ss = [styles];\n\t  }\n\t\n\t  var _iteratorNormalCompletion = true;\n\t  var _didIteratorError = false;\n\t  var _iteratorError = undefined;\n\t\n\t  try {\n\t    for (var _iterator = ss[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t      var style = _step.value;\n\t\n\t      if (typeof dom.style[style] !== 'undefined') {\n\t        return true;\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError = true;\n\t    _iteratorError = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion && _iterator.return) {\n\t        _iterator.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError) {\n\t        throw _iteratorError;\n\t      }\n\t    }\n\t  }\n\t\n\t  return false;\n\t}\n\t\n\t/**\n\t * Set the CSS style to element.\n\t *\n\t * @param {Object} element Target element object.\n\t * @param {Object} style Css style.\n\t */\n\tfunction setstyle(element, style) {\n\t  var _iteratorNormalCompletion2 = true;\n\t  var _didIteratorError2 = false;\n\t  var _iteratorError2 = undefined;\n\t\n\t  try {\n\t    for (var _iterator2 = Object.keys(style)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t      var name = _step2.value;\n\t\n\t      var vsn = validstylename[name];\n\t\n\t      if (vsn) {\n\t        element.style[vsn] = style[name];\n\t      } else if (typeof element.style[name] === 'undefined') {\n\t        for (var i = 0; i < 2; i++) {\n\t          var _iteratorNormalCompletion3 = true;\n\t          var _didIteratorError3 = false;\n\t          var _iteratorError3 = undefined;\n\t\n\t          try {\n\t            for (var _iterator3 = _const.PREFIX[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t              var pfx = _step3.value;\n\t\n\t              var namewithprefix = (i === 0 ? pfx : (0, _util.ucfirst)(pfx)) + (0, _util.ucfirst)(name);\n\t\n\t              if (typeof element.style[namewithprefix] !== 'undefined') {\n\t                validstylename[name] = namewithprefix;\n\t                element.style[namewithprefix] = style[name];\n\t                break;\n\t              }\n\t            }\n\t          } catch (err) {\n\t            _didIteratorError3 = true;\n\t            _iteratorError3 = err;\n\t          } finally {\n\t            try {\n\t              if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t                _iterator3.return();\n\t              }\n\t            } finally {\n\t              if (_didIteratorError3) {\n\t                throw _iteratorError3;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        validstylename[name] = name;\n\t        element.style[name] = style[name];\n\t      }\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError2 = true;\n\t    _iteratorError2 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t        _iterator2.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError2) {\n\t        throw _iteratorError2;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Unset the CSS style to element.\n\t *\n\t * @param {Object} element Target element object.\n\t * @param {string[]|string} styles Css styles.\n\t */\n\tfunction unsetstyle(element, styles) {\n\t  var style = {};\n\t\n\t  var _iteratorNormalCompletion4 = true;\n\t  var _didIteratorError4 = false;\n\t  var _iteratorError4 = undefined;\n\t\n\t  try {\n\t    for (var _iterator4 = ((0, _util.isarray)(styles) ? styles : [styles])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n\t      var name = _step4.value;\n\t\n\t      style[name] = '';\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError4 = true;\n\t    _iteratorError4 = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n\t        _iterator4.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError4) {\n\t        throw _iteratorError4;\n\t      }\n\t    }\n\t  }\n\t\n\t  setstyle(element, style);\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Convert the first letter to uppercase.\n\t *\n\t * @param {string} str Target character string.\n\t * @return {string} Converted string.\n\t */\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.ucfirst = ucfirst;\n\texports.isarray = isarray;\n\tfunction ucfirst(str) {\n\t  return str.charAt(0).toUpperCase() + str.substr(1);\n\t}\n\t\n\t/**\n\t * Whether or not the object is an array.\n\t *\n\t * @param {any} obj Target object.\n\t * @return {boolean} Returns true if object is an Array.\n\t */\n\tfunction isarray(obj) {\n\t  return Object.prototype.toString.call(obj) === '[object Array]';\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.support = undefined;\n\t\n\tvar _helper = __webpack_require__(2);\n\t\n\t/**\n\t * Browser support information.\n\t *\n\t * @type {Object}\n\t */\n\tvar sup = {};\n\t\n\tsup.transform3d = (0, _helper.hasstyle)(['perspectiveProperty', 'webkitPerspective', 'mozPerspective', 'oPerspective', 'msPerspective']);\n\t\n\tsup.transform = (0, _helper.hasstyle)(['transformProperty', 'webkitTransform', 'mozTransform', 'oTransform', 'msTransform']);\n\t\n\tsup.transition = (0, _helper.hasstyle)(['transitionProperty', 'webkitTransitionProperty', 'mozTransitionProperty', 'oTransitionProperty', 'msTransitionProperty']);\n\t\n\tsup.cssanim = (sup.transform3d || sup.transform) && sup.transition;\n\t\n\tsup.transrate = sup.transform3d ? 'translate3d' : 'translate';\n\t\n\t/**\n\t * Browser support information.\n\t *\n\t * @type {Object}\n\t */\n\tvar support = exports.support = Object.freeze(sup);\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// highendrawer.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7bc3ca92a1a5af4a24ee","'use strict';\n\nimport {\n  DEFAULT_DRAWER_PROPERTY,\n  DEFAULT_OVERLAY_PROPERTY,\n  DEFAULT_PROCESS,\n  DRAWER_STYLE,\n  OVERLAY_STYLE,\n  TOUCH_EVENTS,\n  TRANSITION_STYLE,\n} from './const';\n\nimport {isarray} from './util';\nimport * as helper from './helper';\nimport {support} from './support';\n\n/**\n * Class providing a drawer function.\n *\n * @public\n * @class\n * @example\n * var drawer = new DrawerMenu({\n *   element: document.getElementById('drawer')\n * });\n */\nexport default class Highendrawer {\n\n  /**\n   * Initialize object.\n   *\n   * @constructor\n   * @param {Drawer} drawer Initial parameters of drawer.\n   */\n  constructor(drawer) {\n    this._id = helper.generateid();\n    this._drawer = Object.assign({}, DEFAULT_DRAWER_PROPERTY, drawer);\n    this._overlay = this._drawer.overlay === false ?\n      false :\n      Object.assign({}, DEFAULT_OVERLAY_PROPERTY, this._drawer.overlay);\n    this._timeoutid = null;\n    this._intervalid = null;\n    this._process = Object.assign({}, DEFAULT_PROCESS);\n    this._enabled = false;\n    this._handler = this._getdrawerhandler();\n\n    if (this._drawer.enabledmaxwidth > -1) {\n      window.addEventListener('resize', () => {\n        if (this._enabled\n          && window.innerWidth > this._drawer.enabledmaxwidth) {\n          this.destroy();\n        } else if (!this._enabled\n          && window.innerWidth <= this._drawer.enabledmaxwidth) {\n          this.create();\n        }\n      });\n    }\n\n    if (this._drawer.isinitcreate) {\n      this.create();\n    }\n  }\n\n  /**\n   * Create the drawer set.\n   *\n   * @public\n   */\n  create() {\n    try {\n      this._createdrawer();\n      this._createoverlay();\n      this._enabled = true;\n\n      if (this._drawer.oncreate) {\n        this._drawer.oncreate.apply(this, [this._drawer]);\n      }\n    } catch (e) {\n      if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Destroy the drawer set.\n   *\n   * @public\n   */\n  destroy() {\n    try {\n      this._destroydrawer();\n      this._destroyoverlay();\n      this._enabled = false;\n\n      if (this._drawer.ondestroy) {\n        this._drawer.ondestroy.apply(this, [this._drawer]);\n      }\n    } catch (e) {\n      if (this._drawer && this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Open drawer.\n   *\n   * @public\n   * @param {number} [duration] Drawer moving time.\n   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n   * @param {boolean} [iseventprocess=false] Event processing in progress.\n   * @return {Promise} Promise object for open.\n   */\n  open(duration = null, isfireevent = true, iseventprocess = false) {\n    return this._changestate(\n      0,\n      duration,\n      {\n        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n        done: isfireevent ? this._drawer.onopen : null,\n        fail: isfireevent ? this._drawer.onerror : null,\n      },\n      iseventprocess\n    );\n  }\n\n  /**\n   * Close drawer.\n   *\n   * @public\n   * @param {number} [duration] Drawer moving time.\n   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n   * @param {boolean} [iseventprocess=false] Event processing in progress.\n   * @return {Promise} Promise object for close.\n   */\n  close(duration = null, isfireevent = true, iseventprocess = false) {\n    return this._changestate(\n      this._getminposition(),\n      duration,\n      {\n        onchangestate: isfireevent ? this._drawer.onchangestate : null,\n        done: isfireevent ? this._drawer.onclose : null,\n        fail: isfireevent ? this._drawer.onerror : null,\n      },\n      iseventprocess\n    );\n  }\n\n  /**\n   * Toggle drawer.\n   *\n   * @public\n   * @param {number} [duration] Drawer moving time.\n   * @param {boolean} [isfireevent] Whether to fire an event on the drawer.\n   * @param {boolean} [iseventprocess=false] Event processing in progress.\n   * @return {Promise} Promise object for toggle.\n   */\n  toggle(duration = null, isfireevent = true, iseventprocess = false) {\n    return new Promise((resolve, reject) => {\n      try {\n        this[this._getstate() === 'open' ? 'close' : 'open'](duration, isfireevent, iseventprocess)\n          .then(resolve, reject);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  /**\n   * Create drawer.\n   */\n  _createdrawer() {\n    helper.setstyle(\n      this._drawer.element,\n      Object.assign(\n        {},\n        DRAWER_STYLE,\n        support.cssanim ? TRANSITION_STYLE : {}\n      )\n    );\n\n    this._resetdrawer();\n\n    Object.keys(this._handler).forEach((name) => {\n      window.addEventListener(name, this._handler[name]);\n    });\n  }\n\n  /**\n   * Destroy drawer.\n   */\n  _destroydrawer() {\n    Object.keys(this._handler).forEach((name) => {\n      window.removeEventListener(name, this._handler[name]);\n    });\n\n    this._resetdrawer(true);\n\n    helper.unsetstyle(\n      this._drawer.element,\n      Object.keys(\n        Object.assign(\n          {},\n          DRAWER_STYLE,\n          support.cssanim ? TRANSITION_STYLE : {}\n        )\n      )\n    );\n  }\n\n  /**\n   * Create overlay.\n   */\n  _createoverlay() {\n    if (this._overlay === false) {\n      return;\n    }\n\n    if (this._overlay.zindex === -1) {\n      this._overlay.zindex = this._drawer.zindex - 1;\n    }\n\n    if (!this._overlay.element) {\n      this._overlay.element = window.document.createElement('div');\n      this._overlay.isautocreated = true;\n\n      helper.setstyle(\n        this._overlay.element,\n        Object.assign(\n          {},\n          OVERLAY_STYLE,\n          support.cssanim ? TRANSITION_STYLE : {}\n        )\n      );\n    }\n\n    if (!this._overlay.touchhandler) {\n      this._overlay.touchhandler = (e) => {\n        this.close();\n      };\n    }\n\n    this._overlay.element.addEventListener('click', this._overlay.touchhandler);\n    window.document.body.appendChild(this._overlay.element);\n  }\n\n  /**\n   * Destroy overlay.\n   */\n  _destroyoverlay() {\n    if (this._overlay === false) {\n      return;\n    }\n\n    if (this._overlay.element) {\n      if (this._overlay.touchhandler) {\n        this._overlay.element.removeEventListener('click', this._overlay.touchhandler);\n      }\n\n      if (this._overlay.isautocreated) {\n        this._overlay.element.parentNode.removeChild(this._overlay.element);\n      }\n    }\n  }\n\n  /**\n   * Reset drawer.\n   *\n   * @param {boolean} [isunset] Unset style.\n   */\n  _resetdrawer(isunset = false) {\n    try {\n      this._setprops();\n\n      let ims = this._getinitdrawerstyle();\n\n      if (isunset) {\n        helper.unsetstyle(this._drawer.element, Object.keys(ims));\n      } else {\n        helper.setstyle(this._drawer.element, ims);\n      }\n    } catch (e) {\n      if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   * Show drawer.\n   */\n  _showdrawer() {\n    helper.setstyle(this._drawer.element, {\n      zIndex: this._drawer.zindex,\n    });\n  }\n\n  /**\n   * Hide drawer.\n   */\n  _hidedrawer() {\n    helper.setstyle(this._drawer.element, {\n      zIndex: -1,\n    });\n  }\n\n  /**\n   * Show overlay.\n   */\n  _showoverlay() {\n    helper.setstyle(this._overlay.element, {\n      zIndex: this._overlay.zindex,\n    });\n  }\n\n  /**\n   * Hide overlay.\n   */\n  _hideoverlay() {\n    helper.setstyle(this._overlay.element, {\n      zIndex: -1,\n    });\n  }\n\n  /**\n   * Set properties.\n   */\n  _setprops() {\n    // set sizepixel\n    let sizepixel = this._normalizepixel(\n      this._drawer.size\n    );\n\n    let maxsizepixel = this._normalizepixel(\n      this._drawer.maxsize\n    );\n\n    if (sizepixel > maxsizepixel) {\n      sizepixel = maxsizepixel;\n    }\n\n    this._sizepixel = sizepixel;\n\n    // set position\n    this._position = typeof this._position === 'undefined' ?\n      null :\n      this._position;\n  }\n\n  /**\n   * Return initial style of drawer.\n   *\n   * @return {Object} Style for drawer.\n   */\n  _getinitdrawerstyle() {\n    let style = null;\n\n    switch (this._drawer.direction) {\n      case 'top':\n        style = {\n          width: '100%',\n          height: `${this._sizepixel}px`,\n          top: `-${this._sizepixel}px`,\n          right: 'auto',\n          bottom: 'auto',\n          left: 0,\n        };\n        break;\n      case 'right':\n        style = {\n          width: `${this._sizepixel}px`,\n          height: '100%',\n          top: 0,\n          right: `-${this._sizepixel}px`,\n          bottom: 'auto',\n          left: 'auto',\n        };\n        break;\n      case 'bottom':\n        style = {\n          width: '100%',\n          height: `${this._sizepixel}px`,\n          top: 'auto',\n          right: 'auto',\n          bottom: `-${this._sizepixel}px`,\n          left: 0,\n        };\n        break;\n      case 'left':\n        style = {\n          width: `${this._sizepixel}px`,\n          height: '100%',\n          top: 0,\n          right: 'auto',\n          bottom: 'auto',\n          left: `-${this._sizepixel}px`,\n        };\n        break;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n\n    return Object.assign(style, this._drawer.style || {});\n  }\n\n  /**\n   * Return style for moving the drawer.\n   *\n   * @param {number} position Moving position.\n   * @param {number} [duration] Drawer moving time.\n   * @return {Object} Move style for drawer.\n   */\n  _getdrawerstyle(position, duration = null) {\n    let minp = this._getminposition(this._drawer);\n    let style = {};\n\n    if (support.cssanim) {\n      style.transitionDuration = `${duration === null ? this._drawer.duration : duration}ms`;\n\n      switch (this._drawer.direction) {\n        case 'top':\n          style.transform = `${support.transrate}(0,${-(minp - position)}px,0)`;\n          break;\n        case 'right':\n          style.transform = `${support.transrate}(${minp - position}px,0,0)`;\n          break;\n        case 'bottom':\n          style.transform = `${support.transrate}(0,${minp - position}px,0)`;\n          break;\n        case 'left':\n          style.transform = `${support.transrate}(${-(minp - position)}px,0,0)`;\n          break;\n        default:\n          throw new Error(`'${this._drawer.direction}' does not support`);\n      }\n    } else {\n      style[this._drawer.direction] = `${position}px`;\n    }\n\n    return style;\n  }\n\n  /**\n   * Return style for moving the overlay.\n   *\n   * @param {float} opacity Overlay opacity.\n   * @param {number} [duration] Drawer moving time.\n   * @return {Object} Move style for overlay.\n   */\n  _getoverlaystyle(opacity, duration = null) {\n    let style = {\n      opacity,\n    };\n\n    if (support.cssanim) {\n      style.transitionDuration = `${duration === null ? this._drawer.duration : duration}ms`;\n    }\n\n    return style;\n  }\n\n  /**\n   * Make animation with CSS3.\n   *\n   * @param {number} duration Drawer moving time.\n   */\n  _cssanimate(duration) {\n    helper.setstyle(\n      this._overlay.element,\n      this._getoverlaystyle(\n        this._getoverlayopacityfromposition(this._position),\n        duration\n      )\n    );\n\n    helper.setstyle(\n      this._drawer.element,\n      this._getdrawerstyle(this._position, duration)\n    );\n  }\n\n  /**\n   * Make animation with Javascript.\n   *\n   * @param {number} duration Drawer moving time.\n   */\n  _jsanimate(duration) {\n    let start = +new Date();\n    let fromopy = this._getoverlayopacityfromstyle();\n    let toopy = this._getoverlayopacityfromposition(this._position);\n    let frompos = this._getdrawerpositionfromstyle();\n    let topos = this._position;\n\n    if (this._intervalid) {\n      clearInterval(this._intervalid);\n    }\n\n    this._intervalid = setInterval(() => {\n      let time = new Date() - start;\n      let nowpos = null;\n      let nowopy = null;\n\n      if (time > duration) {\n        clearInterval(this._intervalid);\n        this._intervalid = null;\n        nowopy = toopy;\n        nowpos = topos;\n      } else {\n        let prp = (time /= duration) * (time - 2);\n        nowopy = fromopy - ((toopy - fromopy) * prp);\n        nowpos = frompos - ((topos - frompos) * prp);\n      }\n\n      helper.setstyle(\n        this._overlay.element,\n        this._getoverlaystyle(nowopy, duration)\n      );\n\n      helper.setstyle(\n        this._drawer.element,\n        this._getdrawerstyle(nowpos, duration)\n      );\n    }, 10);\n  }\n\n  /**\n   * Return state by touch movement.\n   *\n   * @param {Array} touches Touch object array.\n   * @param {Object} time Time information on start and end of movement.\n   * @return {string} State by touch movement.\n   */\n  _gettouchmovestate(touches, time) {\n    if (time.end - time.start <= 300) {\n      let len = touches.length;\n\n      if (len >= 2) {\n        let moveinfo = this._gettouchmoveinfo(\n          touches[len - 2],\n          touches[len - 1]\n        );\n        let ish = moveinfo.axis === 'horizontal';\n        let isv = moveinfo.axis === 'vertical';\n        let ist = this._drawer.direction === 'top' && moveinfo.y >= 0;\n        let isr = this._drawer.direction === 'right' && moveinfo.x < 0;\n        let isb = this._drawer.direction === 'bottom' && moveinfo.y < 0;\n        let isl = this._drawer.direction === 'left' && moveinfo.x >= 0;\n\n        return (ish && (isr || isl)) || (isv && (isb || ist)) ?\n          'open' :\n          'close';\n      }\n    }\n\n    return this._getstate();\n  }\n\n  /**\n   * Return drawer event handler.\n   *\n   * @return {Object} Drawer event handler.\n   */\n  _getdrawerhandler() {\n    let handler = {};\n\n    handler.resize = () => {\n      this._resetdrawer();\n      this[this._getstate()](0, false, true);\n\n      if (this._drawer.onresize) {\n        this._drawer.onresize.apply(\n          this,\n          [this._drawer]\n        );\n      }\n    };\n\n    if (this._drawer.isswipeable) {\n      for (let event of TOUCH_EVENTS) {\n        handler[event] = this._touchhandler.bind(this);\n      }\n    }\n\n    if (window.history\n      && window.history.pushState\n      && this._drawer.ishistory\n    ) {\n      handler.popstate = (e) => {\n        if (e.state && e.state.id === this._id && this._getstate() === 'open') {\n          this.close(null, true, true);\n        }\n      };\n    }\n\n    return handler;\n  }\n\n  /**\n   * Touch event handler.\n   *\n   * @param {Event} ev Touch event object.\n   * @return {boolean} Event bubbling.\n   */\n  _touchhandler(ev) {\n    try {\n      if (ev.touches.length > 1) {\n        return true;\n      }\n\n      let touch = ev.touches[0];\n\n      if (touch) {\n        this._process.touches.push(touch);\n      }\n\n      switch (ev.type) {\n        case 'touchstart':\n          this._ontouchstart(ev);\n          break;\n        case 'touchmove':\n          this._ontouchmove(ev);\n          break;\n        case 'touchcancel':\n        case 'touchend':\n          this._ontouchfinish(ev);\n          break;\n        default:\n          break;\n      }\n    } catch (e) {\n      if (this._drawer.onerror && typeof this._drawer.onerror === 'function') {\n        this._drawer.onerror.apply(this, [e]);\n      } else {\n        throw e;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Touch start event handler.\n   *\n   * @param {Event} ev Touch event object.\n   */\n  _ontouchstart(ev) {\n    this._process.time.start = new Date().getTime();\n  }\n\n  /**\n   * Touch move event handler.\n   *\n   * @param {Event} ev Touch event object.\n   */\n  _ontouchmove(ev) {\n    let len = this._process.touches.length;\n    let isfiretouchstart = false;\n\n    if (!this._process.istouchactive && len >= 2) {\n      this._process.istouchactive = this._istouchactive(\n        this._process.touches[0]\n      );\n\n      if (this._process.istouchactive) {\n        this._showoverlay();\n        this._showdrawer();\n\n        if (this._drawer.ontouchstart) {\n          isfiretouchstart = true;\n        }\n      }\n    }\n\n    if (this._process.istouchactive) {\n      ev.stopPropagation();\n      ev.preventDefault();\n\n      this._position = this._getdrawerpositionfromtouches(\n        this._process.touches[len - 2],\n        this._process.touches[len - 1]\n      );\n\n      if (isfiretouchstart) {\n        this._drawer.ontouchstart.apply(\n          this,\n          [this._drawer, this._position]\n        );\n      }\n\n      helper.setstyle(\n        this._overlay.element,\n        this._getoverlaystyle(\n          this._getoverlayopacityfromposition(this._position),\n          0\n        )\n      );\n\n      helper.setstyle(\n        this._drawer.element,\n        this._getdrawerstyle(this._position, 0)\n      );\n\n      if (this._drawer.ontouchmove) {\n        this._drawer.ontouchmove.apply(\n          this,\n          [this._drawer, this._position]\n        );\n      }\n    }\n  }\n\n  /**\n   * Touch finish event handler.\n   *\n   * @param {Event} ev Touch event object.\n   */\n  _ontouchfinish(ev) {\n    let len = this._process.touches.length;\n\n    if (this._process.istouchactive && len >= 2) {\n      this._process.time.end = new Date().getTime();\n\n      let state = this._gettouchmovestate(\n        this._process.touches,\n        this._process.time\n      );\n\n      this[state]();\n\n      if (this._drawer.ontouchfinish) {\n        this._drawer.ontouchfinish.apply(\n          this,\n          [\n            this._drawer,\n            this._getdrawerpositionfromtouches(\n              this._process.touches[len - 2],\n              this._process.touches[len - 1]\n            ),\n          ]\n        );\n      }\n    }\n\n    this._process.touches = [];\n    this._process.istouchactive = false;\n    this._process.time.start = 0;\n    this._process.time.end = 0;\n  }\n\n  /**\n   * Return whether or not a valid touch.\n   *\n   * @param {number} position Moving position.\n   * @param {number} [duration=null] Drawer moving time.\n   * @param {Object} [callbacks=null] Callback objects.\n   * @param {boolean} [iseventprocess=false] Event processing in progress.\n   * @return {Promise} Promise object.\n   */\n  _changestate(\n    position,\n    duration = null,\n    callbacks = null,\n    iseventprocess = false\n  ) {\n    return this._handlecallback(new Promise((resolve, reject) => {\n      try {\n        this._position = position;\n\n        let du = duration === null ? this._drawer.duration : duration;\n\n        if (this._timeoutid !== null) {\n          clearTimeout(this._timeoutid);\n          this._timeoutid = null;\n        }\n\n        let state = this._getstate();\n\n        if (state === 'open') {\n          this._showoverlay();\n          this._showdrawer();\n        }\n\n        if (window.history\n          && window.history.pushState\n          && this._drawer.ishistory\n          && !iseventprocess\n        ) {\n          if (state === 'open') {\n            window.history.pushState({\n              id: this._id,\n            }, null, null);\n          } else {\n            window.history.back();\n          }\n        }\n\n        this[support.cssanim\n          ? '_cssanimate'\n          : '_jsanimate'](du);\n\n        this._timeoutid = setTimeout(\n          () => {\n            if (state === 'close') {\n              this._hidedrawer();\n              this._hideoverlay();\n            }\n\n            this._timeoutid = null;\n          },\n          du\n        );\n\n        if (typeof callbacks === 'object' && callbacks.onchangestate) {\n          callbacks.onchangestate.apply(\n            this,\n            [this._drawer, state]\n          );\n        }\n\n        resolve.apply(this, [this._drawer]);\n      } catch (e) {\n        reject(e);\n      }\n    }), {\n      done: typeof callbacks === 'object' && callbacks.done ? callbacks.done : null,\n      fail: typeof callbacks === 'object' && callbacks.fail ? callbacks.fail : null,\n    });\n  }\n\n  /**\n   * Return whether or not a valid touch.\n   *\n   * @param {Object} touch Start touch information.\n   * @return {boolean} Result of valid touch.\n   */\n  _istouchactive(touch) {\n    let rg = this._getrange(\n      this._getstate() === 'open' ?\n        '100%' :\n        this._drawer.swipearea\n    );\n\n    return (rg.from.x <= touch.clientX &&\n      touch.clientX <= rg.to.x &&\n      rg.from.y <= touch.clientY &&\n      touch.clientY <= rg.to.y);\n  }\n\n  /**\n   * Return the state of the drawer.\n   *\n   * @return {string} State of the drawer.\n   */\n  _getstate() {\n    let pos = this._position === null ?\n      this._getdrawerpositionfromstyle() :\n      this._position;\n\n    return Math.abs(pos) < this._sizepixel / 2 ?\n      'open' :\n      'close';\n  }\n\n  /**\n   * Return the position of the drawer.\n   *\n   * @param {Object} touchbasis Basic touch information.\n   * @param {Object} touchlast Last touch information.\n   * @return {number} Position of the drawer.\n   */\n  _getdrawerpositionfromtouches(touchbasis, touchlast) {\n    let distance = this._getdistance(\n      this._gettouchmoveinfo(touchbasis, touchlast)\n    );\n\n    let curpos = this._position === null ?\n      this._getdrawerpositionfromstyle() :\n      this._position;\n\n    let pos = Math.round(curpos + distance);\n    let minp = this._getminposition(this._drawer);\n\n    if (pos > 0) {\n      pos = 0;\n    } else if (pos < minp) {\n      pos = minp;\n    }\n\n    return pos;\n  }\n\n  /**\n   * Return the position in the style.\n   *\n   * @return {number} Position in the style.\n   */\n  _getdrawerpositionfromstyle() {\n    let value = this._drawer.element.style[this._drawer.direction];\n    return this._normalizenumber(value).value;\n  }\n\n\n  /**\n   * Return the opacity of the overlay.\n   *\n   * @param {number} position Moving position.\n   * @return {number} Position of the drawer.\n   */\n  _getoverlayopacityfromposition(position) {\n    let minp = this._getminposition(this._drawer);\n    let posratio = 1 - (Math.abs(position) / Math.abs(minp));\n    return ((this._overlay.opacity * posratio) * 10000) / 10000;\n  }\n\n  /**\n   * Return the opacity in the style.\n   *\n   * @return {number} Opacity in the style.\n   */\n  _getoverlayopacityfromstyle() {\n    return parseFloat(this._overlay.element.style.opacity);\n  }\n\n  /**\n   * Return the swipe range.\n   *\n   * @param {string|number} value Target swipe area value.\n   * @return {Object} Drag range.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _getrange(value) {\n    let basis = this._convertpixelabs(value);\n    let width = window.innerWidth;\n    let height = window.innerHeight;\n\n    switch (this._drawer.direction) {\n      case 'top':\n        return {from: {x: 0, y: 0}, to: {x: width, y: basis}};\n      case 'right':\n        return {from: {x: basis, y: 0}, to: {x: width, y: height}};\n      case 'bottom':\n        return {from: {x: 0, y: basis}, to: {x: width, y: height}};\n      case 'left':\n        return {from: {x: 0, y: 0}, to: {x: basis, y: height}};\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return a value converted to the absolute value of the pixel.\n   *\n   * @param {string|number} value Target value.\n   * @return {number} Converted to the absolute value of the pixel.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _convertpixelabs(value) {\n    let nvalue = this._normalizepixel(value);\n\n    switch (this._drawer.direction) {\n      case 'top':\n      case 'left':\n        return nvalue;\n      case 'right':\n        return window.innerWidth - nvalue;\n      case 'bottom':\n        return window.innerHeight - nvalue;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return the normalized pixel value.\n   *\n   * @param {string|number} value Target value.\n   * @return {number} Normalized pixel value.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _normalizepixel(value) {\n    let normalized = this._normalizenumber(value);\n\n    if (normalized.unit === 'number' || normalized.unit === 'pixel') {\n      return normalized.value;\n    } else if (normalized.unit === 'percent') {\n      switch (this._drawer.direction) {\n        case 'top':\n        case 'bottom':\n          return window.innerHeight * (normalized.value / 100);\n        case 'right':\n        case 'left':\n          return window.innerWidth * (normalized.value / 100);\n        default:\n          throw new Error(`'${this._drawer.direction}' does not support`);\n      }\n    }\n  }\n\n  /**\n   * Return the numeric normalized information.\n   *\n   * @param {string|number} value Target value.\n   * @return {Object} Numeric normalized information.\n   * @throws {Error} Is thrown if value is invalid.\n   */\n  _normalizenumber(value) {\n    if (typeof value === 'number') {\n      return {value: value, unit: 'number'};\n    } else if (String(value).match(/^[.\\-0-9]+$/)) {\n      return {value: Number(value), unit: 'number'};\n    } else if (value.match(/^[.\\-0-9]+px$/)) {\n      return {value: Number(value.replace(/px$/ig, '')), unit: 'pixel'};\n    } else if (value.match(/[.\\-0-9]+%$/)) {\n      return {value: Number(value.replace(/%$/ig, '')), unit: 'percent'};\n    }\n\n    throw new Error(`'${value}' does not support`);\n  }\n\n  /**\n   * Return to the minimum position for the drawer.\n   *\n   * @return {number} Minimum position for the drawer.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _getminposition() {\n    switch (this._drawer.direction) {\n      case 'top':\n      case 'bottom':\n        return -1 * this._drawer.element.offsetHeight;\n      case 'right':\n      case 'left':\n        return -1 * this._drawer.element.offsetWidth;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return the distance of the drawer.\n   *\n   * @param {Object} moveinfo Movement information of the drawer.\n   * @return {number} Distance of the drawer.\n   * @throws {Error} Is thrown if direction value is invalid.\n   */\n  _getdistance(moveinfo) {\n    switch (this._drawer.direction) {\n      case 'top':\n        return moveinfo.y;\n      case 'right':\n        return -1 * moveinfo.x;\n      case 'bottom':\n        return -1 * moveinfo.y;\n      case 'left':\n        return moveinfo.x;\n      default:\n        throw new Error(`'${this._drawer.direction}' does not support`);\n    }\n  }\n\n  /**\n   * Return the information of touch move.\n   *\n   * @param {Object} touchbasis Basic touch information.\n   * @param {Object} touchlast Last touch information.\n   * @return {Object} Movement distance of the x, y direction, movement direction.\n   */\n  _gettouchmoveinfo(touchbasis, touchlast) {\n    let x = touchlast.clientX - touchbasis.clientX;\n    let y = touchlast.clientY - touchbasis.clientY;\n    let axis = Math.abs(x) >= Math.abs(y) ? 'horizontal' : 'vertical';\n\n    return {x, y, axis};\n  }\n\n  /**\n   * Return the information of touch move.\n   *\n   * @param {Promise} promise Promise instance.\n   * @param {Object} callbacks Callback function with the key to 'done', 'fail', 'always' (each optional).\n   * @return {Promise} Promise instance.\n   */\n  _handlecallback(promise, callbacks) {\n    if (!callbacks) {\n      return promise;\n    }\n\n    for (let key of Object.keys(callbacks)) {\n      let callback = callbacks[key];\n\n      if (!callback) {\n        continue;\n      }\n\n      let cb = isarray(callback) ? callback : [callback];\n      let rcb = null;\n\n      switch (key) {\n        case 'done':\n          rcb = (prom, value) => prom.then(value.bind(this));\n          break;\n        case 'fail':\n          rcb = (prom, value) => prom.catch(value.bind(this));\n          break;\n        case 'always':\n          rcb = (prom, value) => prom.then(value.bind(this), value.bind(this));\n          break;\n        default:\n          break;\n      }\n\n      if (rcb) {\n        cb.reduce(rcb, promise);\n      }\n    }\n\n    return promise;\n  }\n}\n\nmodule.exports = Highendrawer;\n\n\n\n// WEBPACK FOOTER //\n// ./src/highendrawer.js","'use strict';\n\n/**\n * Vendor prefix list.\n *\n * @type {string[]}\n */\nexport const PREFIX = ['webkit', 'moz', 'o', 'ms'];\n\n/**\n * Drawer's default css style.\n *\n * @type {Object}\n */\nexport const DRAWER_STYLE = Object.freeze({\n  display: 'block',\n  position: 'fixed',\n  overflowX: 'hidden',\n  overflowY: 'auto',\n  zIndex: -1,\n  webkitOverflowScrolling: 'touch',\n});\n\n/**\n * Overlay's default css style.\n *\n * @type {Object}\n */\nexport const OVERLAY_STYLE = Object.freeze({\n  display: 'block',\n  backgroundColor: '#000',\n  position: 'fixed',\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n  zIndex: -1,\n  opacity: 0,\n});\n\n/**\n * Css transition style.\n *\n * @type {Object}\n */\nexport const TRANSITION_STYLE = Object.freeze({\n  transform: '',\n  transitionProperty: 'transform,opacity',\n  transitionTimingFunction: 'cubic-bezier(0,0,0.25,1)',\n  transitionDuration: '0ms',\n});\n\n/**\n * Default drawer property.\n *\n * @type {Drawer}\n */\nexport const DEFAULT_DRAWER_PROPERTY = Object.freeze({\n  element: null,\n  direction: 'right',\n  size: '80%',\n  maxsize: 256,\n  isswipeable: true,\n  swipearea: '8%',\n  duration: 300,\n  zindex: 9999,\n  style: {},\n  isinitcreate: true,\n  enabledmaxwidth: -1,\n  ishistory: true,\n  overlay: null,\n  oncreate: null,\n  ondestroy: null,\n  onopen: null,\n  onclose: null,\n  onchangestate: null,\n  onresize: null,\n  ontouchstart: null,\n  ontouchmove: null,\n  ontouchfinish: null,\n  onerror: null,\n});\n\n/**\n * Default overlay property.\n *\n * @type {Overlay}\n */\nexport const DEFAULT_OVERLAY_PROPERTY = Object.freeze({\n  element: null,\n  opacity: 0.2,\n  zindex: -1,\n  autocreate: false,\n});\n\n/**\n * Default processing state object.\n *\n * @type {Object}\n */\nexport const DEFAULT_PROCESS = Object.freeze({\n  touches: [],\n  istouchactive: false,\n  time: {\n    start: 0,\n    end: 0,\n  },\n});\n\n/**\n * Touch event list.\n *\n * @type {string[]}\n */\nexport const TOUCH_EVENTS = [\n  'touchstart',\n  'touchmove',\n  'touchend',\n  'touchcancel',\n];\n\n\n\n// WEBPACK FOOTER //\n// ./src/const.js","'use strict';\n\nimport {PREFIX} from './const';\nimport {isarray, ucfirst} from './util';\n\nconst dom = window.document.createElement('div');\n\nlet currentid = 0;\nlet validstylename = {};\n\n/**\n * Generate ID.\n *\n * @return {number} ID.\n */\nexport function generateid() {\n  return ++currentid;\n}\n\n/**\n * Verify that the style is present.\n *\n * @param {string[]|string} styles Css styles.\n * @return {boolean} Result of verification.\n */\nexport function hasstyle(styles) {\n  let ss = styles;\n\n  if (!isarray(styles)) {\n    ss = [styles];\n  }\n\n  for (let style of ss) {\n    if (typeof dom.style[style] !== 'undefined') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Set the CSS style to element.\n *\n * @param {Object} element Target element object.\n * @param {Object} style Css style.\n */\nexport function setstyle(element, style) {\n  for (let name of Object.keys(style)) {\n    let vsn = validstylename[name];\n\n    if (vsn) {\n      element.style[vsn] = style[name];\n    } else if (typeof element.style[name] === 'undefined') {\n      for (let i = 0; i < 2; i++) {\n        for (let pfx of PREFIX) {\n          let namewithprefix = (i === 0 ? pfx : ucfirst(pfx)) +\n            ucfirst(name);\n\n          if (typeof element.style[namewithprefix] !== 'undefined') {\n            validstylename[name] = namewithprefix;\n            element.style[namewithprefix] = style[name];\n            break;\n          }\n        }\n      }\n    } else {\n      validstylename[name] = name;\n      element.style[name] = style[name];\n    }\n  }\n}\n\n/**\n * Unset the CSS style to element.\n *\n * @param {Object} element Target element object.\n * @param {string[]|string} styles Css styles.\n */\nexport function unsetstyle(element, styles) {\n  let style = {};\n\n  for (let name of isarray(styles) ? styles : [styles]) {\n    style[name] = '';\n  }\n\n  setstyle(element, style);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/helper.js","'use strict';\n\n/**\n * Convert the first letter to uppercase.\n *\n * @param {string} str Target character string.\n * @return {string} Converted string.\n */\nexport function ucfirst(str) {\n  return str.charAt(0).toUpperCase() + str.substr(1);\n}\n\n/**\n * Whether or not the object is an array.\n *\n * @param {any} obj Target object.\n * @return {boolean} Returns true if object is an Array.\n */\nexport function isarray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js","'use strict';\n\nimport {hasstyle} from './helper';\n\n/**\n * Browser support information.\n *\n * @type {Object}\n */\nlet sup = {};\n\nsup.transform3d = hasstyle([\n  'perspectiveProperty',\n  'webkitPerspective',\n  'mozPerspective',\n  'oPerspective',\n  'msPerspective',\n]);\n\nsup.transform = hasstyle([\n  'transformProperty',\n  'webkitTransform',\n  'mozTransform',\n  'oTransform',\n  'msTransform',\n]);\n\nsup.transition = hasstyle([\n  'transitionProperty',\n  'webkitTransitionProperty',\n  'mozTransitionProperty',\n  'oTransitionProperty',\n  'msTransitionProperty',\n]);\n\nsup.cssanim = (sup.transform3d || sup.transform) &&\n  sup.transition;\n\nsup.transrate = sup.transform3d ?\n  'translate3d' :\n  'translate';\n\n/**\n * Browser support information.\n *\n * @type {Object}\n */\nexport const support = Object.freeze(sup);\n\n\n\n// WEBPACK FOOTER //\n// ./src/support.js"],"sourceRoot":""}